   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "ecatslv.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.XMC_ECAT_GetALEventRegister,"ax",%progbits
  20              	 .align 2
  21              	 .thumb
  22              	 .thumb_func
  24              	XMC_ECAT_GetALEventRegister:
  25              	.LFB136:
  26              	 .file 1 "C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc/xmc_ecat.h"
   1:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
   2:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
   3:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @file xmc_ecat.h
   4:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @date 2015-12-27
   5:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
   6:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @cond
   7:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
   8:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * XMClib v2.1.18 - XMC Peripheral Driver Library 
   9:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  10:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Copyright (c) 2015-2018, Infineon Technologies AG
  11:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * All rights reserved.                        
  12:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *                                             
  13:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  14:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * following conditions are met:   
  15:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *                                                                              
  16:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  17:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * disclaimer.                        
  18:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * 
  19:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  20:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  21:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * 
  22:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  23:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * products derived from this software without specific prior written permission.                  
  24:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *                                                                              
  25:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  26:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  27:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  28:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  29:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  30:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  31:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  32:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *                                                                              
  33:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  34:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Infineon Technologies AG dave@infineon.com).                                                    
  35:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
  36:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  37:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Change History
  38:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * --------------
  39:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  40:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * 2015-12-27:
  41:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *     - Initial Version<br>
  42:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  43:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @endcond
  44:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
  45:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
  46:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
  47:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @addtogroup XMClib XMC Peripheral Library
  48:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @{
  49:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
  50:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
  51:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
  52:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @addtogroup ECAT
  53:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @brief EtherCAT Low level driver for XMC4800/XMC4300 series.
  54:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  55:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * EtherCAT is an Ethernet-based fieldbus system.
  56:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * The EtherCAT Slave Controller (ECAT) read the data addressed to them while the telegram passes t
  57:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * An EtherCAT Slave Controller (ESC) takes care of the EtherCAT communication as an interface betw
  58:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * fieldbus and the slave application. EtherCAT uses standard IEEE 802.3 Ethernet frames, thus a st
  59:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * controller can be used and no special hardware is required on master side. EtherCAT has a reserv
  60:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * 0x88A4 that distinguishes it from other Ethernet frames. Thus, EtherCAT can run in parallel to o
  61:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * protocols. EtherCAT does not require the IP protocol, however it can be encapsulated in IP/UDP. 
  62:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Slave Controller processes the frame in hardware. Thus, communication performance is independent
  63:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * power.
  64:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  65:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * The XMC_ECAT low level driver provides functions to configure and initialize the ECAT hardware p
  66:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * For EHTERCAT stack integration, the necessary hardware accees layer APIs shall be explicitly imp
  67:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * upon the stack provider. The XMC_ECAT lld layer provides only the hardware initialization functi
  68:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * basic functionalities.
  69:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @{
  70:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
  71:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
  72:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #ifndef XMC_ECAT_H
  73:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #define XMC_ECAT_H
  74:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
  75:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**************************************************************************************************
  76:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * HEADER FILES
  77:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
  78:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
  79:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #include "xmc_common.h"
  80:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
  81:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #if defined (ECAT0)
  82:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
  83:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #include "xmc_ecat_map.h"
  84:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
  85:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**************************************************************************************************
  86:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * MACROS
  87:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
  88:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
  89:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**************************************************************************************************
  90:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * ENUMS
  91:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
  92:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
  93:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
  94:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * ECAT status return values
  95:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
  96:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** typedef enum XMC_ECAT_STATUS
  97:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** {
  98:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_STATUS_OK    = 0U, /**< Driver accepted application request */
  99:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_STATUS_BUSY  = 1U, /**< Driver is busy and cannot handle request */
 100:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_STATUS_ERROR = 2U  /**< Driver could not fulfil application request */
 101:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** } XMC_ECAT_STATUS_t;
 102:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 103:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 104:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * EtherCAT event enumeration types
 105:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 106:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** typedef enum XMC_ECAT_EVENT
 107:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** {
 108:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_AL_CONTROL = ECAT_AL_EVENT_MASK_AL_CE_MASK_Msk, /**< Application control event mas
 109:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_DC_LATCH = ECAT_AL_EVENT_MASK_DC_LE_MASK_Msk,  /**< Distributed Clock latch event 
 110:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_DC_SYNC0 = ECAT_AL_EVENT_MASK_ST_S0_MASK_Msk, /**< State of distributed clock sync
 111:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_DC_SYNC1 = ECAT_AL_EVENT_MASK_ST_S1_MASK_Msk, /**< State of distributed clock sync
 112:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM_ACTIVATION_REGISTER = ECAT_AL_EVENT_MASK_SM_A_MASK_Msk, /**< SyncManager activa
 113:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_EEPROM = ECAT_AL_EVENT_MASK_EEP_E_MASK_Msk, /**< EEPROM Emulation event mask*/
 114:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_WATCHDOG = ECAT_AL_EVENT_MASK_WP_D_MASK_Msk, /**< WATCHDOG process data event mask
 115:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM0 = ECAT_AL_EVENT_MASK_SMI_0_MASK_Msk, /**< Sync Manager 0 event mask*/
 116:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM1 = ECAT_AL_EVENT_MASK_SMI_1_MASK_Msk, /**< Sync Manager 1 event mask*/
 117:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM2 = ECAT_AL_EVENT_MASK_SMI_2_MASK_Msk, /**< Sync Manager 2 event mask*/
 118:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM3 = ECAT_AL_EVENT_MASK_SMI_3_MASK_Msk, /**< Sync Manager 3 event mask*/
 119:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM4 = ECAT_AL_EVENT_MASK_SMI_4_MASK_Msk, /**< Sync Manager 4 event mask*/
 120:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM5 = ECAT_AL_EVENT_MASK_SMI_5_MASK_Msk, /**< Sync Manager 5 event mask*/
 121:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM6 = ECAT_AL_EVENT_MASK_SMI_6_MASK_Msk, /**< Sync Manager 6 event mask*/
 122:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM7 = ECAT_AL_EVENT_MASK_SMI_7_MASK_Msk  /**< Sync Manager 7 event mask*/
 123:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** } XMC_ECAT_EVENT_t;
 124:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 125:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**************************************************************************************************
 126:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * DATA STRUCTURES
 127:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
 128:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 129:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /* Anonymous structure/union guard start */
 130:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #if defined (__CC_ARM)
 131:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #pragma push
 132:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #pragma anon_unions
 133:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #elif defined (__TASKING__)
 134:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #pragma warning 586
 135:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #endif
 136:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 137:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 138:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * ECAT port control data structure
 139:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 140:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** typedef struct XMC_ECAT_PORT_CTRL
 141:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** {
 142:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   union 
 143:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   {
 144:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     struct
 145:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     {
 146:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t enable_rstreq: 1;     /**< Master can trigger a reset of the XMC4700 / XMC4800 (::bo
 147:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 7;                   /**< Reserved bits */
 148:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t latch_input0: 2;      /**< Latch input 0 selection (::XMC_ECAT_PORT_LATCHIN0_t) */
 149:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 2;                   /**< Reserved bits */
 150:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t latch_input1: 2;      /**< Latch input 1 selection (::XMC_ECAT_PORT_LATCHIN1_t) */
 151:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 2;                   /**< Reserved bits */
 152:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t phyaddr_offset: 5;    /**< Ethernet PHY address offset, address of port 0 */
 153:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 1;                   /**< Reserved bits */
 154:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t mdio: 2;              /**< Bidirectional, push-pull management data I/O line (::XMC_
 155:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 8;                   /**< Reserved bits */
 156:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     };
 157:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 158:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t raw;
 159:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   } common;
 160:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 161:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   union 
 162:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   {  
 163:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     struct
 164:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     {
 165:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd0: 2;     /**< Receive data bit 0 (::XMC_ECAT_PORT0_CTRL_RXD0_t) */
 166:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd1: 2;     /**< Receive data bit 1 (::XMC_ECAT_PORT0_CTRL_RXD1_t) */
 167:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd2: 2;     /**< Receive data bit 2 (::XMC_ECAT_PORT0_CTRL_RXD2_t) */
 168:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd3: 2;     /**< Receive data bit 3 (::XMC_ECAT_PORT0_CTRL_RXD3_t) */
 169:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_err: 2;   /**< RX Error (::XMC_ECAT_PORT0_CTRL_RX_ERR_t) */
 170:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_dv: 2;    /**< RX Data valid (::XMC_ECAT_PORT0_CTRL_RX_DV_t) */
 171:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_clk: 2;   /**< RX Clock (::XMC_ECAT_PORT0_CTRL_RX_CLK_t) */
 172:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 2;          /**< Reserved bits */
 173:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t link: 2;     /**< Link status (::XMC_ECAT_PORT0_CTRL_LINK_t) */
 174:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 10;         /**< Reserved bits */
 175:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t tx_clk: 2;   /**< TX Clock (::XMC_ECAT_PORT0_CTRL_TX_CLK_t) */
 176:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t tx_shift: 2; /**< TX signal delay (::XMC_ECAT_PORT0_CTRL_TX_SHIFT_t) */
 177:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     };
 178:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 179:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t raw;
 180:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   } port0;
 181:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 182:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   union 
 183:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   {      
 184:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     struct
 185:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     {
 186:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd0: 2;     /**< Receive data bit 0 (::XMC_ECAT_PORT_CTRL_RXD0_t) */
 187:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd1: 2;     /**< Receive data bit 1 (::XMC_ECAT_PORT_CTRL_RXD1_t) */
 188:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd2: 2;     /**< Receive data bit 2 (::XMC_ECAT_PORT_CTRL_RXD2_t) */
 189:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd3: 2;     /**< Receive data bit 3 (::XMC_ECAT_PORT_CTRL_RXD3_t) */
 190:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_err: 2;   /**< RX Error (::XMC_ECAT_PORT_CTRL_RX_ERR_t) */
 191:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_dv: 2;    /**< RX Data valid (::XMC_ECAT_PORT_CTRL_RX_DV_t) */
 192:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_clk: 2;   /**< RX Clock (::XMC_ECAT_PORT_CTRL_RX_CLK_t) */
 193:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 2;          /**< Reserved bits */
 194:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t link: 2;     /**< Link status (::XMC_ECAT_PORT_CTRL_LINK_t) */
 195:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 10;         /**< Reserved bits */
 196:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t tx_clk: 2;   /**< TX Clock (::XMC_ECAT_PORT_CTRL_TX_CLK_t) */
 197:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t tx_shift: 2; /**< TX signal delay (::XMC_ECAT_PORT1_CTRL_TX_SHIFT_t) */
 198:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     };
 199:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 200:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t raw;
 201:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   } port1;
 202:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   
 203:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** } XMC_ECAT_PORT_CTRL_t;
 204:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 205:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 206:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * ECAT EEPROM configuration area data structure
 207:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 208:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** typedef union XMC_ECAT_CONFIG
 209:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** {
 210:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   struct
 211:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   {
 212:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t : 8;
 213:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 214:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t : 2;
 215:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t enable_dc_sync_out : 1;
 216:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t enable_dc_latch_in : 1;
 217:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t enable_enhanced_link_p0 : 1;
 218:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t enable_enhanced_link_p1 : 1;
 219:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t : 2;
 220:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 221:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t : 16;
 222:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 223:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     uint16_t sync_pulse_length; /**< Initialization value for Pulse Length of SYNC Signals register
 224:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 225:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t : 16;
 226:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 227:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     uint16_t station_alias; /**< Initialization value for Configured Station Alias Address register
 228:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 229:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     uint16_t : 16;
 230:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 231:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     uint16_t : 16;
 232:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 233:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****     uint16_t checksum;
 234:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   };
 235:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 236:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   uint32_t dword[4]; /**< Four 32 bit double word equivalent to 8 16 bit configuration area word. *
 237:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** } XMC_ECAT_CONFIG_t;
 238:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 239:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /* Anonymous structure/union guard end */
 240:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #if defined (__CC_ARM)
 241:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #pragma pop
 242:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #elif defined (__TASKING__)
 243:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #pragma warning restore
 244:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #endif
 245:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 246:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**************************************************************************************************
 247:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * API PROTOTYPES
 248:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
 249:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 250:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #ifdef __cplusplus
 251:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** extern "C" {
 252:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** #endif
 253:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 254:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 255:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param config XMC_ECAT_CONFIG_t
 256:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return XMC_ECAT_STATUS_t ECAT Initialization status
 257:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 258:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 259:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Initialize the Ethernet MAC peripheral <br>
 260:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 261:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 262:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function sets the link speed, applies the duplex mode, sets auto-negotiation
 263:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * and loop-back settings.
 264:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 265:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_Init(XMC_ECAT_CONFIG_t *const config);
 266:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 267:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 268:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param None
 269:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 270:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 271:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 272:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Enable the EtherCAT peripheral <br>
 273:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 274:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 275:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function de-asserts the peripheral reset.
 276:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 277:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_Enable(void);
 278:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 279:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 280:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param None
 281:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 282:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 283:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 284:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Disable the EtherCAT peripheral <br>
 285:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 286:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 287:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function asserts the peripheral reset.
 288:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 289:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_Disable(void);
 290:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 291:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 292:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param phy_addr PHY address
 293:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param reg_addr Register address
 294:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param data The destination to which the read data needs to be copied to.
 295:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 296:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return XMC_ECAT_STATUS_t EtherCAT Read PHY API return status
 297:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 298:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 299:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Read a PHY register <br>
 300:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 301:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 302:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function reads a PHY register. It essentially polls busy bit during max
 303:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * PHY_TIMEOUT time and reads the information into 'data' when not busy.
 304:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 305:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** XMC_ECAT_STATUS_t XMC_ECAT_ReadPhy(uint8_t phy_addr, uint8_t reg_addr, uint16_t *data);
 306:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 307:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 308:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param phy_addr PHY address
 309:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param reg_addr Register address
 310:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param data The data to write
 311:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return XMC_ECAT_STATUS_t EtherCAT Write PHY API return status
 312:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 313:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 314:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Write a PHY register <br>
 315:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 316:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 317:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function reads a PHY register. It essentially writes the data and polls
 318:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * the busy bit until it is no longer busy.
 319:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 320:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** XMC_ECAT_STATUS_t XMC_ECAT_WritePhy(uint8_t phy_addr, uint8_t reg_addr, uint16_t data);
 321:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 322:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 323:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param port_ctrl Port control configuration
 324:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 325:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 326:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 327:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Set port control configuration <br>
 328:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 329:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 330:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function sets the port control by writing the configuration into the ECAT CON register.
 331:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 332:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 333:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** __STATIC_INLINE void XMC_ECAT_SetPortControl(const XMC_ECAT_PORT_CTRL_t port_ctrl)
 334:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** {
 335:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   ECAT0_CON->CON = (uint32_t)port_ctrl.common.raw;
 336:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   ECAT0_CON->CONP0 = (uint32_t)port_ctrl.port0.raw;
 337:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   ECAT0_CON->CONP1 = (uint32_t)port_ctrl.port1.raw;
 338:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** }
 339:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 340:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 341:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param event Single or logically OR'd events specified in the enum type @refXMC_ECAT_EVENT_t
 342:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 343:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 344:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 345:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Enable ECAT event(s) <br>
 346:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 347:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 348:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function can be used to enable ECAT event(s).
 349:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 350:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_EnableEvent(uint32_t event);
 351:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 352:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 353:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param event Single or logically OR'd events specified in the enum type @refXMC_ECAT_EVENT_t
 354:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 355:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 356:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 357:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Disable an ECAT event(s) <br>
 358:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 359:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 360:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function can be used to disable ECAT event(s).
 361:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 362:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_DisableEvent(uint32_t event);
 363:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 364:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 365:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param None
 366:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return uint32_t Event status
 367:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 368:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 369:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Get event status <br>
 370:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 371:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 372:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function returns the ECAT status and interrupt status as a single word. The user
 373:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * can then check the status of the events by using an appropriate mask.
 374:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 375:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** uint32_t XMC_ECAT_GetEventStatus(void);
 376:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 377:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 378:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 379:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param channel SyncManager channel number.
 380:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 381:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 382:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 383:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Disables selected SyncManager channel <br>
 384:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 385:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 386:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Sets bit 0 of the corresponding 0x807 register.
 387:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 388:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_DisableSyncManChannel(const uint8_t channel);
 389:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 390:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 391:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param channel SyncManager channel number.
 392:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 393:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 394:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 395:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Enables selected SyncManager channel <br>
 396:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 397:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 398:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Resets bit 0 of the corresponding 0x807 register.
 399:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 400:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_EnableSyncManChannel(const uint8_t channel);
 401:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** 
 402:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 403:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param None
 404:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return uint16_t Content of register 0x220-0x221
 405:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 406:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 407:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Get content of AL event register <br>
 408:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 409:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 410:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  * Get the first two bytes of the AL Event register (0x220-0x221).
 411:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 412:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** __STATIC_INLINE uint16_t XMC_ECAT_GetALEventRegister(void)
 413:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** {
  27              	 .loc 1 413 0
  28              	 .cfi_startproc
  29              	 
  30              	 
  31              	 
  32 0000 80B4     	 push {r7}
  33              	.LCFI0:
  34              	 .cfi_def_cfa_offset 4
  35              	 .cfi_offset 7,-4
  36 0002 00AF     	 add r7,sp,#0
  37              	.LCFI1:
  38              	 .cfi_def_cfa_register 7
 414:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h ****   return ((uint16_t)ECAT0->AL_EVENT_REQ);
  39              	 .loc 1 414 0
  40 0004 044B     	 ldr r3,.L3
  41 0006 D3F82032 	 ldr r3,[r3,#544]
  42 000a 9BB2     	 uxth r3,r3
 415:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/XMCLib/inc\xmc_ecat.h **** }
  43              	 .loc 1 415 0
  44 000c 1846     	 mov r0,r3
  45 000e BD46     	 mov sp,r7
  46              	.LCFI2:
  47              	 .cfi_def_cfa_register 13
  48              	 
  49 0010 5DF8047B 	 ldr r7,[sp],#4
  50              	.LCFI3:
  51              	 .cfi_restore 7
  52              	 .cfi_def_cfa_offset 0
  53 0014 7047     	 bx lr
  54              	.L4:
  55 0016 00BF     	 .align 2
  56              	.L3:
  57 0018 00000154 	 .word 1409351680
  58              	 .cfi_endproc
  59              	.LFE136:
  61              	 .section .text.HW_EscRead,"ax",%progbits
  62              	 .align 2
  63              	 .thumb
  64              	 .thumb_func
  66              	HW_EscRead:
  67              	.LFB169:
  68              	 .file 2 "C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC/xmc_eschw.h"
   1:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
   2:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @file xmc_eschw.h
   3:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @date 2018-01-24
   4:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
   5:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * NOTE:
   6:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * This file is copied by DAVE. Any manual modification done to this file will be lost when the cod
   7:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
   8:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @cond
   9:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  **************************************************************************************************
  10:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * ECAT_SSC v4.0.18 - ECAT_SSC APP initializes the XMC ESC and sets up the interface for Beckhoff E
  11:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  12:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Copyright (c) 2016-2018, Infineon Technologies AG
  13:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * All rights reserved.
  14:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  15:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  16:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * following conditions are met:
  17:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  18:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  19:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   disclaimer.
  20:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  21:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  22:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   disclaimer in the documentation and/or other materials provided with the distribution.
  23:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  24:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  25:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   products derived from this software without specific prior written permission.
  26:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  27:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  28:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  29:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  30:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  31:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  32:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  33:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  35:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  36:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * with Infineon Technologies AG (dave@infineon.com).
  37:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  **************************************************************************************************
  38:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  39:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Change History
  40:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * --------------
  41:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  42:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * 2016-02-05:
  43:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *     - Initial version
  44:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  45:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * 2018-01-24:
  46:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *     - Added HW_ClearTimer()
  47:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  48:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @endcond
  49:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  50:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
  51:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  52:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #ifndef XMC_ESCHW_H
  53:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define XMC_ESCHW_H
  54:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  55:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**************************************************************************************************
  56:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * HEADER FILES
  57:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  **************************************************************************************************
  58:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #include "SSC/Src/esc.h"
  59:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #include "xmc_ecat.h"
  60:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #include "../E_EEPROM_XMC4/e_eeprom_xmc4.h"
  61:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  62:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  /*************************************************************************************************
  63:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   * MACROS
  64:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   *************************************************************************************************
  65:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  66:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define ECAT_TIMER_INC_P_MS (1U) /**< Timer increment value */
  67:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  68:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define pEsc ((uint8_t *)ECAT0)  /**< EtherCAT module address */
  69:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  70:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** extern uint8_t aEepromData[];
  71:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  72:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**************************************************************************************************
  73:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * API Prototypes
  74:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  **************************************************************************************************
  75:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  76:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #ifdef __cplusplus
  77:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** extern "C" {
  78:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #endif
  79:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  80:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
  81:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @ingroup ECAT_SSC_apidoc
  82:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @{
  83:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
  84:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  85:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadDWord(DWordValue, Address)     ((DWordValue) = (UINT32)(((volatile UINT32 *)pEsc)
  86:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  87:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadDWordIsr(DWordValue, Address)  HW_EscReadDWord(DWordValue, Address)              
  88:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  89:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadWord(WordValue, Address)       ((WordValue) = (((volatile UINT16 *)pEsc)[((Addres
  90:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  91:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadWordIsr(WordValue, Address)    HW_EscReadWord(WordValue, Address)                
  92:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  93:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadByte(ByteValue, Address)       ((ByteValue) = (((volatile UINT8 *)pEsc)[(Address)
  94:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  95:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadByteIsr(ByteValue, Address)    HW_EscReadByte(ByteValue, Address)                
  96:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  97:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteDWord(DWordValue, Address)    ((((volatile UINT32 *)pEsc)[(Address>>2)]) = (DWor
  98:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  99:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteDWordIsr(DWordValue, Address) HW_EscWriteWord(DWordValue, Address)              
 100:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 101:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteWord(WordValue, Address)      ((((volatile UINT16 *)pEsc)[((Address)>>1)]) = (Wo
 102:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 103:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteWordIsr(WordValue, Address)   HW_EscWriteWord(WordValue, Address)               
 104:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 105:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteByte(ByteValue, Address)      ((((volatile UINT8 *)pEsc)[(Address)]) = (ByteValu
 106:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 107:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteByteIsr(ByteValue, Address)   HW_EscWriteByte(ByteValue, Address)               
 108:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 109:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 110:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief 16Bit ESC read access
 111:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 112:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local destination buffer.
 113:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 114:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 115:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 116:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 117:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 118:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 119:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 120:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Reads from the EtherCAT Slave Controller. This function is used to access ESC registers and the 
 121:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 122:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 123:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscRead(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 124:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
  69              	 .loc 2 124 0
  70              	 .cfi_startproc
  71              	 
  72              	 
  73 0000 80B5     	 push {r7,lr}
  74              	.LCFI4:
  75              	 .cfi_def_cfa_offset 8
  76              	 .cfi_offset 7,-8
  77              	 .cfi_offset 14,-4
  78 0002 82B0     	 sub sp,sp,#8
  79              	.LCFI5:
  80              	 .cfi_def_cfa_offset 16
  81 0004 00AF     	 add r7,sp,#0
  82              	.LCFI6:
  83              	 .cfi_def_cfa_register 7
  84 0006 7860     	 str r0,[r7,#4]
  85 0008 0B46     	 mov r3,r1
  86 000a 7B80     	 strh r3,[r7,#2]
  87 000c 1346     	 mov r3,r2
  88 000e 3B80     	 strh r3,[r7]
 125:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   memcpy(pData, &pEsc[Address], Len);
  89              	 .loc 2 125 0
  90 0010 7B88     	 ldrh r3,[r7,#2]
  91 0012 03F1A843 	 add r3,r3,#1409286144
  92 0016 03F58033 	 add r3,r3,#65536
  93 001a 3A88     	 ldrh r2,[r7]
  94 001c 7868     	 ldr r0,[r7,#4]
  95 001e 1946     	 mov r1,r3
  96 0020 FFF7FEFF 	 bl memcpy
 126:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
  97              	 .loc 2 126 0
  98 0024 0837     	 adds r7,r7,#8
  99              	.LCFI7:
 100              	 .cfi_def_cfa_offset 8
 101 0026 BD46     	 mov sp,r7
 102              	.LCFI8:
 103              	 .cfi_def_cfa_register 13
 104              	 
 105 0028 80BD     	 pop {r7,pc}
 106              	 .cfi_endproc
 107              	.LFE169:
 109 002a 00BF     	 .section .text.HW_GetALEventRegister,"ax",%progbits
 110              	 .align 2
 111              	 .thumb
 112              	 .thumb_func
 114              	HW_GetALEventRegister:
 115              	.LFB175:
 127:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 128:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 129:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief Interrupt specific 16Bit ESC read access
 130:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 131:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local destination buffer.
 132:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 133:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 134:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 135:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 136:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 137:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 138:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 139:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Reads from the EtherCAT Slave Controller. This function is used to access ESC registers and the 
 140:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 141:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 142:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscReadIsr(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 143:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 144:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   HW_EscRead(pData, Address, Len);
 145:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 146:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 147:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 148:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief Reads data from the ESC and copies to slave mailbox memory.
 149:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 150:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local destination buffer.
 151:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 152:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 153:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 154:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 155:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 156:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 157:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 158:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Reads data from the ESC and copies to slave mailbox memory. If the local mailbox memory is also 
 159:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * application memory this function is equal to HW_EscRead.
 160:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 161:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 162:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscReadMbxMem(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 163:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 164:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   HW_EscRead(pData, Address, Len);
 165:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 166:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 167:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 168:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief 16Bit ESC write access
 169:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 170:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local source buffer.
 171:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 172:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 173:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 174:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 175:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 176:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 177:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 178:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Writes from the EtherCAT Slave Controller. This function is used to access ESC registers and the
 179:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 180:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 181:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscWrite(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 182:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 183:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   memcpy(&pEsc[Address], pData, Len);
 184:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 185:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 186:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 187:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief Interrupt specific 16Bit ESC write access
 188:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 189:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local source buffer.
 190:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 191:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 192:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 193:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 194:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 195:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 196:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 197:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Writes from the EtherCAT Slave Controller. This function is used to access ESC registers and the
 198:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 199:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 200:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscWriteIsr(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 201:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 202:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   HW_EscWrite(pData, Address, Len);
 203:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 204:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 205:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 206:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief Writes data from the slave mailbox memory to ESC memory.
 207:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 208:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local source mailbox buffer.
 209:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 210:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 211:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 212:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 213:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 214:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 215:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 216:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Writes data from the slave mailbox memory to ESC memory. If the local mailbox memory is also loc
 217:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * application memory this function is equal to HW_EscWrite.
 218:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 219:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 220:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscWriteMbxMem(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 221:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 222:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   HW_EscWrite(pData, Address, Len);
 223:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 224:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 225:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 226:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief Get the first two bytes of the AL Event register
 227:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 228:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param None
 229:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 230:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return Content of register 0x220-0x221
 231:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 232:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 233:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 234:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 235:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 236:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 237:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE UINT16 HW_GetALEventRegister(void)
 238:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 116              	 .loc 2 238 0
 117              	 .cfi_startproc
 118              	 
 119              	 
 120 0000 80B5     	 push {r7,lr}
 121              	.LCFI9:
 122              	 .cfi_def_cfa_offset 8
 123              	 .cfi_offset 7,-8
 124              	 .cfi_offset 14,-4
 125 0002 00AF     	 add r7,sp,#0
 126              	.LCFI10:
 127              	 .cfi_def_cfa_register 7
 239:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   return XMC_ECAT_GetALEventRegister();
 128              	 .loc 2 239 0
 129 0004 FFF7FEFF 	 bl XMC_ECAT_GetALEventRegister
 130 0008 0346     	 mov r3,r0
 240:C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 131              	 .loc 2 240 0
 132 000a 1846     	 mov r0,r3
 133 000c 80BD     	 pop {r7,pc}
 134              	 .cfi_endproc
 135              	.LFE175:
 137              	 .comm bBootMode,1,1
 138              	 .comm bEcatOutputUpdateRunning,1,1
 139              	 .comm bEcatInputUpdateRunning,1,1
 140              	 .comm bEcatFirstOutputsReceived,1,1
 141              	 .comm bWdTrigger,1,1
 142              	 .comm bDcSyncActive,1,1
 143              	 .comm EsmTimeoutCounter,2,2
 144              	 .comm bDcRunning,1,1
 145              	 .comm u16SmSync0Counter,2,2
 146              	 .comm u16SmSync0Value,2,2
 147              	 .comm bSmSyncSequenceValid,1,1
 148              	 .comm i16WaitForPllRunningTimeout,2,2
 149              	 .comm i16WaitForPllRunningCnt,2,2
 150              	 .comm Sync0WdCounter,2,2
 151              	 .comm Sync0WdValue,2,2
 152              	 .comm Sync1WdCounter,2,2
 153              	 .comm Sync1WdValue,2,2
 154              	 .comm LatchInputSync0Value,2,2
 155              	 .comm LatchInputSync0Counter,2,2
 156              	 .comm b32BitDc,1,1
 157              	 .comm bEscIntEnabled,1,1
 158              	 .comm b3BufferMode,1,1
 159              	 .comm bLocalErrorFlag,1,1
 160              	 .comm u16LocalErrorCode,2,2
 161              	 .comm bApplEsmPending,1,1
 162              	 .comm bEcatWaitForAlControlRes,1,1
 163              	 .comm nEcatStateTrans,2,2
 164              	 .comm u8EcatErrorLed,1,1
 165              	 .comm u8EcatRunLed,1,1
 166              	 .comm nPdInputSize,2,2
 167              	 .comm nPdOutputSize,2,2
 168              	 .comm nMaxSyncMan,1,1
 169              	 .comm nMaxEscAddress,2,2
 170              	 .comm nAlStatus,1,1
 171              	 .comm EcatWdValue,2,2
 172              	 .comm nEscAddrOutputData,2,2
 173              	 .comm nEscAddrInputData,2,2
 174              	 .comm u16ALEventMask,2,2
 175              	 .comm u8dummy,1,1
 176              	 .global SMActivate
 177 000e 00BF     	 .section .bss.SMActivate,"aw",%nobits
 180              	SMActivate:
 181 0000 00       	 .space 1
 182              	 .comm SyncManInfo,8,4
 183              	 .global EepromLoaded
 184              	 .section .bss.EepromLoaded,"aw",%nobits
 187              	EepromLoaded:
 188 0000 00       	 .space 1
 189              	 .section .text.ResetALEventMask,"ax",%progbits
 190              	 .align 2
 191              	 .global ResetALEventMask
 192              	 .thumb
 193              	 .thumb_func
 195              	ResetALEventMask:
 196              	.LFB177:
 197              	 .file 3 "../SSC/Src/ecatslv.c"
   1:../SSC/Src/ecatslv.c **** /*
   2:../SSC/Src/ecatslv.c **** * This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & 
   3:../SSC/Src/ecatslv.c **** * The corresponding license agreement applies. This hint shall not be removed.
   4:../SSC/Src/ecatslv.c **** */
   5:../SSC/Src/ecatslv.c **** 
   6:../SSC/Src/ecatslv.c **** /**
   7:../SSC/Src/ecatslv.c **** \addtogroup ESM EtherCAT State Machine
   8:../SSC/Src/ecatslv.c **** @{
   9:../SSC/Src/ecatslv.c **** */
  10:../SSC/Src/ecatslv.c **** 
  11:../SSC/Src/ecatslv.c **** /**
  12:../SSC/Src/ecatslv.c **** \file ecatslv.c
  13:../SSC/Src/ecatslv.c **** \author EthercatSSC@beckhoff.com
  14:../SSC/Src/ecatslv.c **** \brief Implementation
  15:../SSC/Src/ecatslv.c **** This file contains the EtherCAT State Machine.
  16:../SSC/Src/ecatslv.c **** 
  17:../SSC/Src/ecatslv.c **** \version 5.12
  18:../SSC/Src/ecatslv.c **** 
  19:../SSC/Src/ecatslv.c **** <br>Changes to version V5.11:<br>
  20:../SSC/Src/ecatslv.c **** V5.12 BOOT1: add a bootloader sample application (only the ESM and FoE is supported)<br>
  21:../SSC/Src/ecatslv.c **** V5.12 ECAT1: update SM Parameter measurement (based on the system time), enhancement for input only
  22:../SSC/Src/ecatslv.c **** V5.12 ECAT4: update Sync1 watchdog calculation (in case of subordinated cycles take one addiitonal 
  23:../SSC/Src/ecatslv.c **** V5.12 ECAT5: update Sync error counter/flag handling,check enum memory alignment depending on the p
  24:../SSC/Src/ecatslv.c **** V5.12 ECAT7: set error single flash also in case of an application error<br>
  25:../SSC/Src/ecatslv.c **** V5.12 ESM1: overwrite the current error in case of a local error with a lower target state,Do not o
  26:../SSC/Src/ecatslv.c **** V5.12 ESM2: enable the PD SM in case of a clear error transition<br>
  27:../SSC/Src/ecatslv.c **** V5.12 ESM3: set internal ESM timeout to -10% of the configured value (to return an errorcode before
  28:../SSC/Src/ecatslv.c **** V5.12 ESM4: enable the AL Event mask in case of pending ESM transition<br>
  29:../SSC/Src/ecatslv.c **** V5.12 TEST2: add pending ESM test,trigger complete ESM transition from ecat main<br>
  30:../SSC/Src/ecatslv.c **** <br>Changes to version V5.10:<br>
  31:../SSC/Src/ecatslv.c **** V5.11 COE3: change 0x10F3.2 (Sync Error limit) from UINT32 to UINT16 (according to the ETG.1020)<br
  32:../SSC/Src/ecatslv.c **** V5.11 DIAG4: change parameter handling in DIAG_CreateNewMessage()<br>
  33:../SSC/Src/ecatslv.c **** V5.11 ECAT10: change PROTO handling to prevent compiler errors<br>
  34:../SSC/Src/ecatslv.c **** V5.11 ECAT4: enhance SM/Sync monitoring for input/output only slaves<br>
  35:../SSC/Src/ecatslv.c **** V5.11 ECAT5: "Add missing ""bEscIntEnabled"" initialization if ""AL_EVENT_ENBALED"" is 0"""<br>
  36:../SSC/Src/ecatslv.c **** V5.11 ECAT7: add missing big endian swapping<br>
  37:../SSC/Src/ecatslv.c **** V5.11 ESC1: update max address calculation<br>
  38:../SSC/Src/ecatslv.c **** V5.11 ESM1: update calculation of subordinated cycles<br>
  39:../SSC/Src/ecatslv.c **** V5.11 ESM2: DC_SUPPORTED, Sync0 is not supported and Sync0 is generated according register values t
  40:../SSC/Src/ecatslv.c **** V5.11 ESM3: update checking of the user configured sync type<br>
  41:../SSC/Src/ecatslv.c **** V5.11 ESM4: prevent to go from ErrSafeOP to OP without re enabling Sync0/1<br>
  42:../SSC/Src/ecatslv.c **** V5.11 ESM5: DPRAM range was double checked<br>
  43:../SSC/Src/ecatslv.c **** V5.11 ESM6: in the SO transition wait by default until the master has send process data<br>
  44:../SSC/Src/ecatslv.c **** V5.11 HW1: "move hardware independent functions ""HW_DisableSyncManChannel()"", ""HW_EnableSyncManC
  45:../SSC/Src/ecatslv.c **** V5.11 HW2: check during ESM handling if the SM address and length is aligned according the ESC acce
  46:../SSC/Src/ecatslv.c **** V5.11 TEST9: "add behaviour 0x2020.7 (SDO requests on 0x3006.0 are set to pending until an FoE read
  47:../SSC/Src/ecatslv.c **** <br>Changes to version V5.01:<br>
  48:../SSC/Src/ecatslv.c **** V5.10 COE1: Define one entry description for all 0x1C3x objects and change data type of SI11,12,13 
  49:../SSC/Src/ecatslv.c **** V5.10 DIAG1: Define diagmessage textIDs<br>
  50:../SSC/Src/ecatslv.c **** V5.10 ECAT13: Update Synchronisation handling (FreeRun,SM Sync, Sync0, Sync1)<br>
  51:../SSC/Src/ecatslv.c ****               Compare DC UINT configuration (by ESC Config data) vs. DC activation register setting
  52:../SSC/Src/ecatslv.c ****               Update 0x1C3x entries<br>
  53:../SSC/Src/ecatslv.c **** V5.10 ESC2: Check if defined SM settings do not exceed the available DPRAM range (in error case AL 
  54:../SSC/Src/ecatslv.c **** V5.10 ESC3: Handle DC cControl register values in case of 32Bit ESC access (a Sync activation mask 
  55:../SSC/Src/ecatslv.c **** V5.10 ESC4: Mask lower 4 Bit of AL status to get Run led value<br>
  56:../SSC/Src/ecatslv.c ****             Invalid RunLed code was calculated if ESC set ECAT Run Led<br>
  57:../SSC/Src/ecatslv.c **** V5.10 ESC5: Add missing swapping<br>
  58:../SSC/Src/ecatslv.c **** V5.10 ESM2: Update "bApplEsmPending" flag during a transition to a lower state<br>
  59:../SSC/Src/ecatslv.c **** V5.10 ESM3: Add "volatile" directive for ESM dummy variables<br>
  60:../SSC/Src/ecatslv.c **** V5.10 HW5: Block ESC interrupts during Timer ISR<br>
  61:../SSC/Src/ecatslv.c **** V5.10 TEST9: Add option to prevent SM3 unlock during PS<br>
  62:../SSC/Src/ecatslv.c **** <br>Changes to version V5.0:<br>
  63:../SSC/Src/ecatslv.c **** V5.01 APPL3: Include library demo application<br>
  64:../SSC/Src/ecatslv.c **** V5.01 ESC2: Add missed value swapping<br>
  65:../SSC/Src/ecatslv.c **** V5.01 ESM1: Don't overwrite the error reason in case of an failed PS transition<br>
  66:../SSC/Src/ecatslv.c **** V5.01 ESM2: Don't check the "appl trigger" flag in case on an regular transition to a lower state (
  67:../SSC/Src/ecatslv.c **** V5.01 ESM3: Call Error acknowledge indication only if error was acknowledged by the master<br>
  68:../SSC/Src/ecatslv.c **** V5.01 HW3: Update blink code of an SM watchdog error<br>
  69:../SSC/Src/ecatslv.c **** <br>Changes to version V4.42:<br>
  70:../SSC/Src/ecatslv.c **** V5.0 ECAT1: Support Explicit Device ID.<br>
  71:../SSC/Src/ecatslv.c **** V5.0 ECAT2: Application specific functions are moved to application files.<br>
  72:../SSC/Src/ecatslv.c **** V5.0 ECAT3: Global dummy variables used for dummy ESC operations.<br>
  73:../SSC/Src/ecatslv.c **** V5.0 ESC1: ESC 32Bit Access added.<br>
  74:../SSC/Src/ecatslv.c **** V5.0 ESC2: Support ESC EtherCAT LED Indication.<br>
  75:../SSC/Src/ecatslv.c **** V5.0 ESC3: Support EEPROM Emulation.<br>
  76:../SSC/Src/ecatslv.c **** V5.0 ESM1: Update "LocalErrorFlag" handling.<br>
  77:../SSC/Src/ecatslv.c **** V5.0 ESM2: Update Error Acknowledge by ALControl INIT (without error acknowledge)<br>
  78:../SSC/Src/ecatslv.c **** V5.0 ESM3: Handle pending ESM transition<br>
  79:../SSC/Src/ecatslv.c **** V5.0 ESM4: ECAT_StateChange() will only be called form application. In case of an communication err
  80:../SSC/Src/ecatslv.c **** V5.0 MBX1: Support configuration without mailbox protocol support.<br>
  81:../SSC/Src/ecatslv.c **** V5.0 TEST1: Add test application. See Application Note ET9300 for more details.<br>
  82:../SSC/Src/ecatslv.c **** <br>Changes to version V4.40:<br>
  83:../SSC/Src/ecatslv.c **** V4.42 ESM1: Reset local error flag if master set the acknowledge bit (0x120.4)<br>
  84:../SSC/Src/ecatslv.c **** <br>Changes to version V4.30:<br>
  85:../SSC/Src/ecatslv.c **** V4.40 ESM5: Enable output SyncManager if local error acknowledged<br>
  86:../SSC/Src/ecatslv.c **** V4.40 HW0: Use common hardware access functions<br>
  87:../SSC/Src/ecatslv.c **** V4.40 PDO3: Add support if only input process data is used<br>
  88:../SSC/Src/ecatslv.c **** V4.40 ECAT4: Add read SM activation register to acknowledge SM Change event<br>
  89:../SSC/Src/ecatslv.c **** V4.40 PDO2: Check if max process data size was exceed<br>
  90:../SSC/Src/ecatslv.c **** V4.40 DIAG1: add diagnosis message support<br>
  91:../SSC/Src/ecatslv.c **** V4.40 ESM4: Change Check WD setup; add define OP_PD_REQUIRED (defines if process data required in s
  92:../SSC/Src/ecatslv.c **** V4.40 WD1: change WD behaviour depending if process data required in OP state<br>
  93:../SSC/Src/ecatslv.c **** V4.40 MBX4: Change processing order of mailbox SyncManager flags<br>
  94:../SSC/Src/ecatslv.c **** V4.40 ECAT1: Merge content of HW_Main (spihw.c /mcihw.c) to ECAT_Main<br>
  95:../SSC/Src/ecatslv.c **** V4.40 ECAT2: Added CheckIfLocalError() to check local flags and set ALStatus /Al Status code if req
  96:../SSC/Src/ecatslv.c **** V4.40 ESM2: Add AL_ControlRes() to complete pending state requests. Change SafeOP to OP state respo
  97:../SSC/Src/ecatslv.c **** V4.40 ESM1: Prevent double call of StopOutputHandler()<br>
  98:../SSC/Src/ecatslv.c **** V4.40 BOOT1: Enable Mailbox SyncManger on state change to BOOT state (to enable FoE)<br>
  99:../SSC/Src/ecatslv.c **** V4.40 ESM3: Change State machine behaviour according to ETG.1000 V1.0.2 (state change #26)<br>
 100:../SSC/Src/ecatslv.c **** V4.40 LED1: Set error blink code<br>
 101:../SSC/Src/ecatslv.c **** V4.40 TIMER1: Added DC_CheckWatchdog() triggered from ECAT_CheckTimer(). Change local Sync0 watchdo
 102:../SSC/Src/ecatslv.c **** V4.40 WD1: Change check process data watchdog settings<br>
 103:../SSC/Src/ecatslv.c **** <br>Changes to version V4.20:<br>
 104:../SSC/Src/ecatslv.c **** V4.30 OBJ 3: initialize the object dictionary in state change INIT->PREOP; clear object dictionary 
 105:../SSC/Src/ecatslv.c **** V4.30 SYNC: add 0x1C32:10; 0x1C33:10 (Sync0 cycle), change synchronisation control functionality<br
 106:../SSC/Src/ecatslv.c **** V4.30 CiA402: add CiA402_Init() call in state change from PREOP to SAFEOP if DC synchronisation is 
 107:../SSC/Src/ecatslv.c ****                    else the Init function is called when bus cycle time is calculated [CalcSMCycleT
 108:../SSC/Src/ecatslv.c ****                    trigger error handling if the EtherCAT state machine gets a transition from OP t
 109:../SSC/Src/ecatslv.c **** V4.20 ECAT 1: add LEGACY_MODE behaviour in ECAT_CheckWatchdog()<br>
 110:../SSC/Src/ecatslv.c **** V4.20 DC 1: Add DC pending state machine handling and Dc watchdog functionality<br>
 111:../SSC/Src/ecatslv.c **** V4.20 ESM 2: Add State transition from BOOT to INIT<br>
 112:../SSC/Src/ecatslv.c **** V4.20 ESM 1: Non LEGACY_MODE State change handling<br>
 113:../SSC/Src/ecatslv.c **** V4.11 Renamed the function parameter "code" of Function "SendSmFailedEmergency() to avoid<br>
 114:../SSC/Src/ecatslv.c **** problems with some compilers"<br>
 115:../SSC/Src/ecatslv.c **** V4.11 ECAT 1: Fixed a possible problem with state change Init -> SafeOP. The output syncmanager<br>
 116:../SSC/Src/ecatslv.c **** was enabled by the state change-flag and not by the actual state<br>
 117:../SSC/Src/ecatslv.c **** V4.11 LED 1: Clear the error LED during error acknowledgement<br>
 118:../SSC/Src/ecatslv.c **** V4.11 ESC 1: fixed size of MBXHEADER in the TFOEMBX struct <br>
 119:../SSC/Src/ecatslv.c **** <br>Changes to version V4.08:<br>
 120:../SSC/Src/ecatslv.c **** V4.10 ECAT 1: clear bEcatOutputsReceived in startMailboxhandler()<br>
 121:../SSC/Src/ecatslv.c **** V4.10 ECAT 2: clear bEcatOutputsReceived in stopMailboxhandler()<br>
 122:../SSC/Src/ecatslv.c **** V4.10 ECAT 3: when switching from INIT to BOOT the SM settings shall be checked<br>
 123:../SSC/Src/ecatslv.c **** V4.10 ECAT 4: APPL_StartInputHandler shall always be called and bEcatInputUpdateRunning shall alway
 124:../SSC/Src/ecatslv.c ****               in StartInputHandler independent of the input size<br>
 125:../SSC/Src/ecatslv.c **** V4.10 ECAT 5: AL_ControlInd: the error acknowledge behaviour was changed<br>
 126:../SSC/Src/ecatslv.c ****               according to the protocol enhancements and the conformance test<br>
 127:../SSC/Src/ecatslv.c **** V4.10 ECAT 6: AL_ControlInd: if a state transitions failed the corresponding stop function is<br>
 128:../SSC/Src/ecatslv.c ****               called to get a consistent set of variables<br>
 129:../SSC/Src/ecatslv.c **** V4.10 ECAT 7: the local application requested to leave the state OP so we have to disable the SM2<b
 130:../SSC/Src/ecatslv.c ****                    and make the state change from OP to SAFEOP by calling StopOutputHandler<br>
 131:../SSC/Src/ecatslv.c **** V4.10 ECAT 8: the AL Status Code has to be reset if the error was acknowledged by the master<br>
 132:../SSC/Src/ecatslv.c **** V4.10 ECAT 9: ECAT_StateChange: when waiting for a State Change response from the application the<b
 133:../SSC/Src/ecatslv.c ****               AL Status shall only be written if the final state was reached<br>
 134:../SSC/Src/ecatslv.c **** <br>Changes to version V4.07:<br>
 135:../SSC/Src/ecatslv.c **** V4.08 ECAT 1: The watchdog value was not rounded up<br>
 136:../SSC/Src/ecatslv.c **** V4.08 ECAT 2: The value of u16WdValue was not set 0 if the register 0x420 is 0<br>
 137:../SSC/Src/ecatslv.c **** V4.08 ECAT 3: The AlStatusCode is changed as parameter of the function AL_ControlInd<br>
 138:../SSC/Src/ecatslv.c **** V4.08 ECAT 4: In a state transition OP2PREOP, SAFEOP2INIT or OP2INIT is requested,<br>
 139:../SSC/Src/ecatslv.c ****               this was not working correctly if one of the application functions<br>
 140:../SSC/Src/ecatslv.c ****               APPL_StopInputHandler or APPL_StopOutputHandler were returning NOERROR_INWORK<br>
 141:../SSC/Src/ecatslv.c ****               (because only the first state transition was made in that case)<br>
 142:../SSC/Src/ecatslv.c **** V4.08 AOE 1:    AoE was added<br>
 143:../SSC/Src/ecatslv.c **** <br>Changes to version V4.06:<br>
 144:../SSC/Src/ecatslv.c **** V4.07 ECAT 1: The sources for SPI and MCI were merged (in ecat_def.h<br>
 145:../SSC/Src/ecatslv.c ****                    set the switch MCI_HW to 1 when using the MCI,<br>
 146:../SSC/Src/ecatslv.c ****                    set the switch SPI_HW to 1 when using the SPI<br>
 147:../SSC/Src/ecatslv.c **** <br>Changes to version V4.00:<br>
 148:../SSC/Src/ecatslv.c **** V4.01 ECAT 1: The Output sync Manager was not disabled when the state OP was left<br>
 149:../SSC/Src/ecatslv.c ****               by a local request (watchdog or io error)<br>
 150:../SSC/Src/ecatslv.c **** V4.01 ECAT 2: APPL_StopOutputHandler returns an UINT16<br>
 151:../SSC/Src/ecatslv.c **** V4.01 ECAT 3: TwinCAT compatibility mode: The state transition to OP is allowed when the<br>
 152:../SSC/Src/ecatslv.c ****                     WD-Trigger-Bit of the SM2-Control-Byte (0x814.6) is FALSE, in that case the<br>
 153:../SSC/Src/ecatslv.c ****                     watchdog will not be started before the outputs were received the first time<br
 154:../SSC/Src/ecatslv.c **** V4.01 ECAT 4: "else" was too much<br>
 155:../SSC/Src/ecatslv.c **** <br>Changes to version V3.20:<br>
 156:../SSC/Src/ecatslv.c **** V4.00 ECAT 1: The handling of the Sync Manager Parameter was included according to<br>
 157:../SSC/Src/ecatslv.c ****               the EtherCAT Guidelines and Protocol Enhancements Specification<br>
 158:../SSC/Src/ecatslv.c **** V4.00 ECAT 2: The output sync manager is initialized during the state transition<br>
 159:../SSC/Src/ecatslv.c ****               from PREOP to SAFEOP that the master can check if the slave could update<br>
 160:../SSC/Src/ecatslv.c ****               inputs and outputs before switching the slave to OP<br>
 161:../SSC/Src/ecatslv.c ****               behaviour according to the EtherCAT Guidelines and Protocol Enhancements Specificatio
 162:../SSC/Src/ecatslv.c **** V4.00 ECAT 3: The watchdog will be enabled in SAFE-OP that it can be checked if the last SM event<b
 163:../SSC/Src/ecatslv.c ****               was received during the watchdog time before switching to OP<br>
 164:../SSC/Src/ecatslv.c **** V4.00 ECAT 4: The function CheckSmChannelParameters is included in the function<br>
 165:../SSC/Src/ecatslv.c ****               CheckSmSettings to get a better overview<br>
 166:../SSC/Src/ecatslv.c **** V4.00 ECAT 5: In synchronous mode the slave should support 1- and 3-buffer mode, 3-buffer mode<br>
 167:../SSC/Src/ecatslv.c ****               should be the standard setting, because the controlling if the process data was updat
 168:../SSC/Src/ecatslv.c ****               should be done with the TxPDO Toggle, but the 1-buffer mode should be setable too,<br
 169:../SSC/Src/ecatslv.c ****               that the master could easily check if all slaves are synchronous by checking the<br>
 170:../SSC/Src/ecatslv.c ****               the working counter (if the outputs were not read or the inputs were not written<br>
 171:../SSC/Src/ecatslv.c ****               the ESC of the slave would not increment the working counter with expected value<br>
 172:../SSC/Src/ecatslv.c ****               if the 1-buffer mode is running)<br>
 173:../SSC/Src/ecatslv.c **** V4.00 ECAT 6: The function ECAT_StateChange was added, which the application should call if a local
 174:../SSC/Src/ecatslv.c ****                    is detected (with the parameters alStatus = STATE_SAFEOP, alStatusCode = error c
 175:../SSC/Src/ecatslv.c ****                    or gone (with the parameters alStatus = STATE_OP, alStatusCode = 0)<br>
 176:../SSC/Src/ecatslv.c ****                    or if one of the functions APPL_StartMailboxHandler, APPL_StopMailboxHandler, AP
 177:../SSC/Src/ecatslv.c ****                    APPL_StopInputHandler, APPL_StartOutputHandler, APPL_StopOutputHandler has retur
 178:../SSC/Src/ecatslv.c ****                    to acknowledge the last state transition (with the parameters alStatus = new AL-
 179:../SSC/Src/ecatslv.c ****                    new AL-Status-Code)<br>
 180:../SSC/Src/ecatslv.c **** V4.00 ECAT 7: The return values for the AL-StatusCode were changed to UINT16
 181:../SSC/Src/ecatslv.c **** */
 182:../SSC/Src/ecatslv.c **** 
 183:../SSC/Src/ecatslv.c **** /*-----------------------------------------------------------------------------------------
 184:../SSC/Src/ecatslv.c **** ------
 185:../SSC/Src/ecatslv.c **** ------    Includes
 186:../SSC/Src/ecatslv.c **** ------
 187:../SSC/Src/ecatslv.c **** -----------------------------------------------------------------------------------------*/
 188:../SSC/Src/ecatslv.c **** 
 189:../SSC/Src/ecatslv.c **** #define    _ECATSLV_    1
 190:../SSC/Src/ecatslv.c **** #include "ecatslv.h"
 191:../SSC/Src/ecatslv.c **** #undef    _ECATSLV_
 192:../SSC/Src/ecatslv.c **** /*remove definition of _ECATSLV_ (#ifdef is used in ecatslv.h)*/
 193:../SSC/Src/ecatslv.c **** 
 194:../SSC/Src/ecatslv.c **** #include "ecatappl.h"
 195:../SSC/Src/ecatslv.c **** 
 196:../SSC/Src/ecatslv.c **** 
 197:../SSC/Src/ecatslv.c **** #include    "bootmode.h"
 198:../SSC/Src/ecatslv.c **** 
 199:../SSC/Src/ecatslv.c **** 
 200:../SSC/Src/ecatslv.c **** 
 201:../SSC/Src/ecatslv.c **** #include "mailbox.h"
 202:../SSC/Src/ecatslv.c **** 
 203:../SSC/Src/ecatslv.c **** #include "ecatcoe.h"
 204:../SSC/Src/ecatslv.c **** #include "objdef.h"
 205:../SSC/Src/ecatslv.c **** 
 206:../SSC/Src/ecatslv.c **** 
 207:../SSC/Src/ecatslv.c **** 
 208:../SSC/Src/ecatslv.c **** #include "XMC_ESC.h"
 209:../SSC/Src/ecatslv.c **** 
 210:../SSC/Src/ecatslv.c **** /*--------------------------------------------------------------------------------------
 211:../SSC/Src/ecatslv.c **** ------
 212:../SSC/Src/ecatslv.c **** ------    local Types and Defines
 213:../SSC/Src/ecatslv.c **** ------
 214:../SSC/Src/ecatslv.c **** --------------------------------------------------------------------------------------*/
 215:../SSC/Src/ecatslv.c **** 
 216:../SSC/Src/ecatslv.c **** 
 217:../SSC/Src/ecatslv.c **** /*-----------------------------------------------------------------------------------------
 218:../SSC/Src/ecatslv.c **** ------
 219:../SSC/Src/ecatslv.c **** ------    local variables and constants
 220:../SSC/Src/ecatslv.c **** ------
 221:../SSC/Src/ecatslv.c **** -----------------------------------------------------------------------------------------*/
 222:../SSC/Src/ecatslv.c **** UINT16    u16ALEventMask;                      // Value which will be written to the 0x204 register
 223:../SSC/Src/ecatslv.c **** 
 224:../SSC/Src/ecatslv.c **** /*Dummy variable to trigger read or writes events in the ESC*/
 225:../SSC/Src/ecatslv.c ****     VARVOLATILE UINT8 u8dummy;
 226:../SSC/Src/ecatslv.c **** 
 227:../SSC/Src/ecatslv.c **** 
 228:../SSC/Src/ecatslv.c ****         VARVOLATILE UINT8 SMActivate = 0;
 229:../SSC/Src/ecatslv.c **** 
 230:../SSC/Src/ecatslv.c **** TSYNCMAN		SyncManInfo;
 231:../SSC/Src/ecatslv.c **** 
 232:../SSC/Src/ecatslv.c **** //indicates if the EEPORM was loaded correct
 233:../SSC/Src/ecatslv.c **** BOOL EepromLoaded = FALSE;
 234:../SSC/Src/ecatslv.c **** /*-----------------------------------------------------------------------------------------
 235:../SSC/Src/ecatslv.c **** ------
 236:../SSC/Src/ecatslv.c **** ------    local functions
 237:../SSC/Src/ecatslv.c **** ------
 238:../SSC/Src/ecatslv.c **** -----------------------------------------------------------------------------------------*/
 239:../SSC/Src/ecatslv.c **** 
 240:../SSC/Src/ecatslv.c **** void ResetALEventMask(UINT16 intMask);
 241:../SSC/Src/ecatslv.c **** 
 242:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 243:../SSC/Src/ecatslv.c **** /**
 244:../SSC/Src/ecatslv.c ****  \param    intMask        interrupt mask (disabled interrupt shall be zero)
 245:../SSC/Src/ecatslv.c **** 
 246:../SSC/Src/ecatslv.c ****  \brief    This function makes an logical and with the AL Event Mask register (0x204)
 247:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 248:../SSC/Src/ecatslv.c **** void ResetALEventMask(UINT16 intMask)
 249:../SSC/Src/ecatslv.c **** {
 198              	 .loc 3 249 0
 199              	 .cfi_startproc
 200              	 
 201              	 
 202 0000 80B5     	 push {r7,lr}
 203              	.LCFI11:
 204              	 .cfi_def_cfa_offset 8
 205              	 .cfi_offset 7,-8
 206              	 .cfi_offset 14,-4
 207 0002 84B0     	 sub sp,sp,#16
 208              	.LCFI12:
 209              	 .cfi_def_cfa_offset 24
 210 0004 00AF     	 add r7,sp,#0
 211              	.LCFI13:
 212              	 .cfi_def_cfa_register 7
 213 0006 0346     	 mov r3,r0
 214 0008 FB80     	 strh r3,[r7,#6]
 250:../SSC/Src/ecatslv.c ****     UINT16 mask;
 251:../SSC/Src/ecatslv.c ****     HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
 215              	 .loc 3 251 0
 216 000a 084B     	 ldr r3,.L9
 217 000c 1B88     	 ldrh r3,[r3]
 218 000e FB81     	 strh r3,[r7,#14]
 252:../SSC/Src/ecatslv.c ****     
 253:../SSC/Src/ecatslv.c ****     mask &= intMask;
 219              	 .loc 3 253 0
 220 0010 FA89     	 ldrh r2,[r7,#14]
 221 0012 FB88     	 ldrh r3,[r7,#6]
 222 0014 1340     	 ands r3,r3,r2
 223 0016 FB81     	 strh r3,[r7,#14]
 254:../SSC/Src/ecatslv.c **** 
 255:../SSC/Src/ecatslv.c **** 
 256:../SSC/Src/ecatslv.c ****     DISABLE_ESC_INT();
 224              	 .loc 3 256 0
 225 0018 FFF7FEFF 	 bl DISABLE_ESC_INT
 257:../SSC/Src/ecatslv.c **** 
 258:../SSC/Src/ecatslv.c **** 
 259:../SSC/Src/ecatslv.c ****     HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
 226              	 .loc 3 259 0
 227 001c 034A     	 ldr r2,.L9
 228 001e FB89     	 ldrh r3,[r7,#14]
 229 0020 1380     	 strh r3,[r2]
 260:../SSC/Src/ecatslv.c ****     ENABLE_ESC_INT();
 230              	 .loc 3 260 0
 231 0022 FFF7FEFF 	 bl ENABLE_ESC_INT
 261:../SSC/Src/ecatslv.c **** }
 232              	 .loc 3 261 0
 233 0026 1037     	 adds r7,r7,#16
 234              	.LCFI14:
 235              	 .cfi_def_cfa_offset 8
 236 0028 BD46     	 mov sp,r7
 237              	.LCFI15:
 238              	 .cfi_def_cfa_register 13
 239              	 
 240 002a 80BD     	 pop {r7,pc}
 241              	.L10:
 242              	 .align 2
 243              	.L9:
 244 002c 04020154 	 .word 1409352196
 245              	 .cfi_endproc
 246              	.LFE177:
 248              	 .section .text.SetALEventMask,"ax",%progbits
 249              	 .align 2
 250              	 .global SetALEventMask
 251              	 .thumb
 252              	 .thumb_func
 254              	SetALEventMask:
 255              	.LFB178:
 262:../SSC/Src/ecatslv.c **** 
 263:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 264:../SSC/Src/ecatslv.c **** /**
 265:../SSC/Src/ecatslv.c ****  \param    intMask        interrupt mask (enabled interrupt shall be one)
 266:../SSC/Src/ecatslv.c **** 
 267:../SSC/Src/ecatslv.c ****   \brief    This function makes an logical or with the AL Event Mask register (0x204)
 268:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 269:../SSC/Src/ecatslv.c **** void SetALEventMask(UINT16 intMask)
 270:../SSC/Src/ecatslv.c **** {
 256              	 .loc 3 270 0
 257              	 .cfi_startproc
 258              	 
 259              	 
 260 0000 80B5     	 push {r7,lr}
 261              	.LCFI16:
 262              	 .cfi_def_cfa_offset 8
 263              	 .cfi_offset 7,-8
 264              	 .cfi_offset 14,-4
 265 0002 84B0     	 sub sp,sp,#16
 266              	.LCFI17:
 267              	 .cfi_def_cfa_offset 24
 268 0004 00AF     	 add r7,sp,#0
 269              	.LCFI18:
 270              	 .cfi_def_cfa_register 7
 271 0006 0346     	 mov r3,r0
 272 0008 FB80     	 strh r3,[r7,#6]
 271:../SSC/Src/ecatslv.c ****     UINT16 mask;
 272:../SSC/Src/ecatslv.c ****     HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
 273              	 .loc 3 272 0
 274 000a 084B     	 ldr r3,.L12
 275 000c 1B88     	 ldrh r3,[r3]
 276 000e FB81     	 strh r3,[r7,#14]
 273:../SSC/Src/ecatslv.c ****     
 274:../SSC/Src/ecatslv.c **** 
 275:../SSC/Src/ecatslv.c ****     mask |= intMask;
 277              	 .loc 3 275 0
 278 0010 FA89     	 ldrh r2,[r7,#14]
 279 0012 FB88     	 ldrh r3,[r7,#6]
 280 0014 1343     	 orrs r3,r3,r2
 281 0016 FB81     	 strh r3,[r7,#14]
 276:../SSC/Src/ecatslv.c **** 
 277:../SSC/Src/ecatslv.c ****     DISABLE_ESC_INT();
 282              	 .loc 3 277 0
 283 0018 FFF7FEFF 	 bl DISABLE_ESC_INT
 278:../SSC/Src/ecatslv.c **** 
 279:../SSC/Src/ecatslv.c **** 
 280:../SSC/Src/ecatslv.c ****     HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
 284              	 .loc 3 280 0
 285 001c 034A     	 ldr r2,.L12
 286 001e FB89     	 ldrh r3,[r7,#14]
 287 0020 1380     	 strh r3,[r2]
 281:../SSC/Src/ecatslv.c ****     ENABLE_ESC_INT();
 288              	 .loc 3 281 0
 289 0022 FFF7FEFF 	 bl ENABLE_ESC_INT
 282:../SSC/Src/ecatslv.c **** }
 290              	 .loc 3 282 0
 291 0026 1037     	 adds r7,r7,#16
 292              	.LCFI19:
 293              	 .cfi_def_cfa_offset 8
 294 0028 BD46     	 mov sp,r7
 295              	.LCFI20:
 296              	 .cfi_def_cfa_register 13
 297              	 
 298 002a 80BD     	 pop {r7,pc}
 299              	.L13:
 300              	 .align 2
 301              	.L12:
 302 002c 04020154 	 .word 1409352196
 303              	 .cfi_endproc
 304              	.LFE178:
 306              	 .section .text.UpdateEEPROMLoadedState,"ax",%progbits
 307              	 .align 2
 308              	 .global UpdateEEPROMLoadedState
 309              	 .thumb
 310              	 .thumb_func
 312              	UpdateEEPROMLoadedState:
 313              	.LFB179:
 283:../SSC/Src/ecatslv.c **** 
 284:../SSC/Src/ecatslv.c **** 
 285:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 286:../SSC/Src/ecatslv.c **** /**
 287:../SSC/Src/ecatslv.c **** 
 288:../SSC/Src/ecatslv.c **** \brief    This function reads the EEPROM loaded state
 289:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 290:../SSC/Src/ecatslv.c **** void UpdateEEPROMLoadedState(void)
 291:../SSC/Src/ecatslv.c **** {
 314              	 .loc 3 291 0
 315              	 .cfi_startproc
 316              	 
 317              	 
 318              	 
 319 0000 80B4     	 push {r7}
 320              	.LCFI21:
 321              	 .cfi_def_cfa_offset 4
 322              	 .cfi_offset 7,-4
 323 0002 83B0     	 sub sp,sp,#12
 324              	.LCFI22:
 325              	 .cfi_def_cfa_offset 16
 326 0004 00AF     	 add r7,sp,#0
 327              	.LCFI23:
 328              	 .cfi_def_cfa_register 7
 292:../SSC/Src/ecatslv.c ****     UINT16 TmpVar = 0;
 329              	 .loc 3 292 0
 330 0006 0023     	 movs r3,#0
 331 0008 FB80     	 strh r3,[r7,#6]
 293:../SSC/Src/ecatslv.c ****     //read EEPROM loaded information
 294:../SSC/Src/ecatslv.c ****     HW_EscReadWord(TmpVar, ESC_EEPROM_CONTROL_OFFSET);
 332              	 .loc 3 294 0
 333 000a 0C4B     	 ldr r3,.L18
 334 000c 1B88     	 ldrh r3,[r3]
 335 000e FB80     	 strh r3,[r7,#6]
 295:../SSC/Src/ecatslv.c ****     TmpVar = SWAPWORD(TmpVar);
 296:../SSC/Src/ecatslv.c **** 
 297:../SSC/Src/ecatslv.c **** 
 298:../SSC/Src/ecatslv.c ****     if (((TmpVar & ESC_EEPROM_ERROR_CRC) > 0)
 336              	 .loc 3 298 0
 337 0010 FB88     	 ldrh r3,[r7,#6]
 338 0012 03F40063 	 and r3,r3,#2048
 339 0016 002B     	 cmp r3,#0
 340 0018 04DC     	 bgt .L15
 299:../SSC/Src/ecatslv.c ****         || ((TmpVar & ESC_EEPROM_ERROR_LOAD) > 0))
 341              	 .loc 3 299 0
 342 001a FB88     	 ldrh r3,[r7,#6]
 343 001c 03F48053 	 and r3,r3,#4096
 344 0020 002B     	 cmp r3,#0
 345 0022 03DD     	 ble .L16
 346              	.L15:
 300:../SSC/Src/ecatslv.c ****     {
 301:../SSC/Src/ecatslv.c ****         EepromLoaded = FALSE;
 347              	 .loc 3 301 0
 348 0024 064B     	 ldr r3,.L18+4
 349 0026 0022     	 movs r2,#0
 350 0028 1A70     	 strb r2,[r3]
 351 002a 02E0     	 b .L14
 352              	.L16:
 302:../SSC/Src/ecatslv.c ****     }
 303:../SSC/Src/ecatslv.c ****     else
 304:../SSC/Src/ecatslv.c ****     {
 305:../SSC/Src/ecatslv.c ****         EepromLoaded = TRUE;
 353              	 .loc 3 305 0
 354 002c 044B     	 ldr r3,.L18+4
 355 002e 0122     	 movs r2,#1
 356 0030 1A70     	 strb r2,[r3]
 357              	.L14:
 306:../SSC/Src/ecatslv.c ****     }
 307:../SSC/Src/ecatslv.c **** }
 358              	 .loc 3 307 0
 359 0032 0C37     	 adds r7,r7,#12
 360              	.LCFI24:
 361              	 .cfi_def_cfa_offset 4
 362 0034 BD46     	 mov sp,r7
 363              	.LCFI25:
 364              	 .cfi_def_cfa_register 13
 365              	 
 366 0036 5DF8047B 	 ldr r7,[sp],#4
 367              	.LCFI26:
 368              	 .cfi_restore 7
 369              	 .cfi_def_cfa_offset 0
 370 003a 7047     	 bx lr
 371              	.L19:
 372              	 .align 2
 373              	.L18:
 374 003c 02050154 	 .word 1409352962
 375 0040 00000000 	 .word EepromLoaded
 376              	 .cfi_endproc
 377              	.LFE179:
 379              	 .section .text.GetSyncMan,"ax",%progbits
 380              	 .align 2
 381              	 .global GetSyncMan
 382              	 .thumb
 383              	 .thumb_func
 385              	GetSyncMan:
 386              	.LFB180:
 308:../SSC/Src/ecatslv.c **** 
 309:../SSC/Src/ecatslv.c **** 
 310:../SSC/Src/ecatslv.c **** /*-----------------------------------------------------------------------------------------
 311:../SSC/Src/ecatslv.c **** ------
 312:../SSC/Src/ecatslv.c **** ------    functions
 313:../SSC/Src/ecatslv.c **** ------
 314:../SSC/Src/ecatslv.c **** -----------------------------------------------------------------------------------------*/
 315:../SSC/Src/ecatslv.c **** 
 316:../SSC/Src/ecatslv.c **** 
 317:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 318:../SSC/Src/ecatslv.c **** /**
 319:../SSC/Src/ecatslv.c ****  \param     channel        Sync Manager channel
 320:../SSC/Src/ecatslv.c **** 
 321:../SSC/Src/ecatslv.c ****  \return     pPdSyncMan        Pointer to the settings of requested SYNC Manager channel
 322:../SSC/Src/ecatslv.c **** 
 323:../SSC/Src/ecatslv.c ****  \brief    This function is called to read the SYNC Manager channel descriptions of the
 324:../SSC/Src/ecatslv.c ****              process data SYNC Managers.
 325:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 326:../SSC/Src/ecatslv.c **** 
 327:../SSC/Src/ecatslv.c **** TSYNCMAN ESCMEM * GetSyncMan( UINT8 channel )
 328:../SSC/Src/ecatslv.c **** {
 387              	 .loc 3 328 0
 388              	 .cfi_startproc
 389              	 
 390              	 
 391 0000 80B5     	 push {r7,lr}
 392              	.LCFI27:
 393              	 .cfi_def_cfa_offset 8
 394              	 .cfi_offset 7,-8
 395              	 .cfi_offset 14,-4
 396 0002 82B0     	 sub sp,sp,#8
 397              	.LCFI28:
 398              	 .cfi_def_cfa_offset 16
 399 0004 00AF     	 add r7,sp,#0
 400              	.LCFI29:
 401              	 .cfi_def_cfa_register 7
 402 0006 0346     	 mov r3,r0
 403 0008 FB71     	 strb r3,[r7,#7]
 329:../SSC/Src/ecatslv.c ****     HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), S
 404              	 .loc 3 329 0
 405 000a FB79     	 ldrb r3,[r7,#7]
 406 000c 03F58073 	 add r3,r3,#256
 407 0010 9BB2     	 uxth r3,r3
 408 0012 DB00     	 lsls r3,r3,#3
 409 0014 9BB2     	 uxth r3,r3
 410 0016 0548     	 ldr r0,.L22
 411 0018 1946     	 mov r1,r3
 412 001a 0822     	 movs r2,#8
 413 001c FFF7FEFF 	 bl HW_EscRead
 330:../SSC/Src/ecatslv.c **** 
 331:../SSC/Src/ecatslv.c **** 
 332:../SSC/Src/ecatslv.c **** 
 333:../SSC/Src/ecatslv.c ****     return &SyncManInfo;
 414              	 .loc 3 333 0
 415 0020 024B     	 ldr r3,.L22
 334:../SSC/Src/ecatslv.c **** }
 416              	 .loc 3 334 0
 417 0022 1846     	 mov r0,r3
 418 0024 0837     	 adds r7,r7,#8
 419              	.LCFI30:
 420              	 .cfi_def_cfa_offset 8
 421 0026 BD46     	 mov sp,r7
 422              	.LCFI31:
 423              	 .cfi_def_cfa_register 13
 424              	 
 425 0028 80BD     	 pop {r7,pc}
 426              	.L23:
 427 002a 00BF     	 .align 2
 428              	.L22:
 429 002c 00000000 	 .word SyncManInfo
 430              	 .cfi_endproc
 431              	.LFE180:
 433              	 .section .text.DisableSyncManChannel,"ax",%progbits
 434              	 .align 2
 435              	 .global DisableSyncManChannel
 436              	 .thumb
 437              	 .thumb_func
 439              	DisableSyncManChannel:
 440              	.LFB181:
 335:../SSC/Src/ecatslv.c **** 
 336:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 337:../SSC/Src/ecatslv.c **** /**
 338:../SSC/Src/ecatslv.c ****  \param     channel        Sync Manager channel
 339:../SSC/Src/ecatslv.c **** 
 340:../SSC/Src/ecatslv.c ****  \brief    This function disables a Sync Manager channel
 341:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 342:../SSC/Src/ecatslv.c **** void DisableSyncManChannel(UINT8 channel)
 343:../SSC/Src/ecatslv.c **** {
 441              	 .loc 3 343 0
 442              	 .cfi_startproc
 443              	 
 444              	 
 445              	 
 446 0000 80B4     	 push {r7}
 447              	.LCFI32:
 448              	 .cfi_def_cfa_offset 4
 449              	 .cfi_offset 7,-4
 450 0002 85B0     	 sub sp,sp,#20
 451              	.LCFI33:
 452              	 .cfi_def_cfa_offset 24
 453 0004 00AF     	 add r7,sp,#0
 454              	.LCFI34:
 455              	 .cfi_def_cfa_register 7
 456 0006 0346     	 mov r3,r0
 457 0008 FB71     	 strb r3,[r7,#7]
 344:../SSC/Src/ecatslv.c ****     UINT16 Offset;
 345:../SSC/Src/ecatslv.c ****     VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
 458              	 .loc 3 345 0
 459 000a 0123     	 movs r3,#1
 460 000c 7B73     	 strb r3,[r7,#13]
 346:../SSC/Src/ecatslv.c ****     Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
 461              	 .loc 3 346 0
 462 000e FB79     	 ldrb r3,[r7,#7]
 463 0010 9BB2     	 uxth r3,r3
 464 0012 DB00     	 lsls r3,r3,#3
 465 0014 9BB2     	 uxth r3,r3
 466 0016 03F60703 	 addw r3,r3,#2055
 467 001a FB81     	 strh r3,[r7,#14]
 347:../SSC/Src/ecatslv.c **** 
 348:../SSC/Src/ecatslv.c ****     HW_EscWriteByte(smStatus,Offset);
 468              	 .loc 3 348 0
 469 001c FB89     	 ldrh r3,[r7,#14]
 470 001e 03F1A843 	 add r3,r3,#1409286144
 471 0022 03F58033 	 add r3,r3,#65536
 472 0026 7A7B     	 ldrb r2,[r7,#13]
 473 0028 D2B2     	 uxtb r2,r2
 474 002a 1A70     	 strb r2,[r3]
 475              	.L25:
 349:../SSC/Src/ecatslv.c ****     
 350:../SSC/Src/ecatslv.c ****     /*wait until SyncManager is disabled*/
 351:../SSC/Src/ecatslv.c ****     do
 352:../SSC/Src/ecatslv.c ****     {
 353:../SSC/Src/ecatslv.c ****         HW_EscReadByte(smStatus, Offset);
 476              	 .loc 3 353 0 discriminator 1
 477 002c FB89     	 ldrh r3,[r7,#14]
 478 002e 03F1A843 	 add r3,r3,#1409286144
 479 0032 03F58033 	 add r3,r3,#65536
 480 0036 1B78     	 ldrb r3,[r3]
 481 0038 DBB2     	 uxtb r3,r3
 482 003a 7B73     	 strb r3,[r7,#13]
 354:../SSC/Src/ecatslv.c ****     }while(!(smStatus & SM_SETTING_PDI_DISABLE));
 483              	 .loc 3 354 0 discriminator 1
 484 003c 7B7B     	 ldrb r3,[r7,#13]
 485 003e DBB2     	 uxtb r3,r3
 486 0040 03F00103 	 and r3,r3,#1
 487 0044 002B     	 cmp r3,#0
 488 0046 F1D0     	 beq .L25
 355:../SSC/Src/ecatslv.c **** }
 489              	 .loc 3 355 0
 490 0048 1437     	 adds r7,r7,#20
 491              	.LCFI35:
 492              	 .cfi_def_cfa_offset 4
 493 004a BD46     	 mov sp,r7
 494              	.LCFI36:
 495              	 .cfi_def_cfa_register 13
 496              	 
 497 004c 5DF8047B 	 ldr r7,[sp],#4
 498              	.LCFI37:
 499              	 .cfi_restore 7
 500              	 .cfi_def_cfa_offset 0
 501 0050 7047     	 bx lr
 502              	 .cfi_endproc
 503              	.LFE181:
 505 0052 00BF     	 .section .text.EnableSyncManChannel,"ax",%progbits
 506              	 .align 2
 507              	 .global EnableSyncManChannel
 508              	 .thumb
 509              	 .thumb_func
 511              	EnableSyncManChannel:
 512              	.LFB182:
 356:../SSC/Src/ecatslv.c **** 
 357:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 358:../SSC/Src/ecatslv.c **** /**
 359:../SSC/Src/ecatslv.c ****  \param     channel        Sync Manager channel
 360:../SSC/Src/ecatslv.c **** 
 361:../SSC/Src/ecatslv.c ****  \brief    This function enables a Sync Manager channel
 362:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 363:../SSC/Src/ecatslv.c **** void EnableSyncManChannel(UINT8 channel)
 364:../SSC/Src/ecatslv.c **** {
 513              	 .loc 3 364 0
 514              	 .cfi_startproc
 515              	 
 516              	 
 517              	 
 518 0000 80B4     	 push {r7}
 519              	.LCFI38:
 520              	 .cfi_def_cfa_offset 4
 521              	 .cfi_offset 7,-4
 522 0002 85B0     	 sub sp,sp,#20
 523              	.LCFI39:
 524              	 .cfi_def_cfa_offset 24
 525 0004 00AF     	 add r7,sp,#0
 526              	.LCFI40:
 527              	 .cfi_def_cfa_register 7
 528 0006 0346     	 mov r3,r0
 529 0008 FB71     	 strb r3,[r7,#7]
 365:../SSC/Src/ecatslv.c ****     UINT16 Offset;
 366:../SSC/Src/ecatslv.c ****     VARVOLATILE UINT8 smStatus = 0x00;
 530              	 .loc 3 366 0
 531 000a 0023     	 movs r3,#0
 532 000c 7B73     	 strb r3,[r7,#13]
 367:../SSC/Src/ecatslv.c ****     Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
 533              	 .loc 3 367 0
 534 000e FB79     	 ldrb r3,[r7,#7]
 535 0010 9BB2     	 uxth r3,r3
 536 0012 DB00     	 lsls r3,r3,#3
 537 0014 9BB2     	 uxth r3,r3
 538 0016 03F60703 	 addw r3,r3,#2055
 539 001a FB81     	 strh r3,[r7,#14]
 368:../SSC/Src/ecatslv.c **** 
 369:../SSC/Src/ecatslv.c ****     HW_EscWriteByte(smStatus,Offset);
 540              	 .loc 3 369 0
 541 001c FB89     	 ldrh r3,[r7,#14]
 542 001e 03F1A843 	 add r3,r3,#1409286144
 543 0022 03F58033 	 add r3,r3,#65536
 544 0026 7A7B     	 ldrb r2,[r7,#13]
 545 0028 D2B2     	 uxtb r2,r2
 546 002a 1A70     	 strb r2,[r3]
 547              	.L27:
 370:../SSC/Src/ecatslv.c ****     
 371:../SSC/Src/ecatslv.c ****     /*wait until SyncManager is enabled*/
 372:../SSC/Src/ecatslv.c ****     do
 373:../SSC/Src/ecatslv.c ****     {
 374:../SSC/Src/ecatslv.c ****         HW_EscReadByte(smStatus,Offset);
 548              	 .loc 3 374 0 discriminator 1
 549 002c FB89     	 ldrh r3,[r7,#14]
 550 002e 03F1A843 	 add r3,r3,#1409286144
 551 0032 03F58033 	 add r3,r3,#65536
 552 0036 1B78     	 ldrb r3,[r3]
 553 0038 DBB2     	 uxtb r3,r3
 554 003a 7B73     	 strb r3,[r7,#13]
 375:../SSC/Src/ecatslv.c ****     }while((smStatus & SM_SETTING_PDI_DISABLE));
 555              	 .loc 3 375 0 discriminator 1
 556 003c 7B7B     	 ldrb r3,[r7,#13]
 557 003e DBB2     	 uxtb r3,r3
 558 0040 03F00103 	 and r3,r3,#1
 559 0044 002B     	 cmp r3,#0
 560 0046 F1D1     	 bne .L27
 376:../SSC/Src/ecatslv.c **** }
 561              	 .loc 3 376 0
 562 0048 1437     	 adds r7,r7,#20
 563              	.LCFI41:
 564              	 .cfi_def_cfa_offset 4
 565 004a BD46     	 mov sp,r7
 566              	.LCFI42:
 567              	 .cfi_def_cfa_register 13
 568              	 
 569 004c 5DF8047B 	 ldr r7,[sp],#4
 570              	.LCFI43:
 571              	 .cfi_restore 7
 572              	 .cfi_def_cfa_offset 0
 573 0050 7047     	 bx lr
 574              	 .cfi_endproc
 575              	.LFE182:
 577 0052 00BF     	 .section .text.CheckSmSettings,"ax",%progbits
 578              	 .align 2
 579              	 .global CheckSmSettings
 580              	 .thumb
 581              	 .thumb_func
 583              	CheckSmSettings:
 584              	.LFB183:
 377:../SSC/Src/ecatslv.c **** 
 378:../SSC/Src/ecatslv.c **** 
 379:../SSC/Src/ecatslv.c **** 
 380:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 381:../SSC/Src/ecatslv.c **** /**
 382:../SSC/Src/ecatslv.c ****  \param  maxChannel    last SM channel which should be checked
 383:../SSC/Src/ecatslv.c **** 
 384:../SSC/Src/ecatslv.c ****  \return                 0: okay else AL Status Code
 385:../SSC/Src/ecatslv.c **** 
 386:../SSC/Src/ecatslv.c ****  \brief    This function checks all SM channels
 387:../SSC/Src/ecatslv.c **** 
 388:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 389:../SSC/Src/ecatslv.c **** 
 390:../SSC/Src/ecatslv.c **** UINT8    CheckSmSettings(UINT8 maxChannel)
 391:../SSC/Src/ecatslv.c **** {
 585              	 .loc 3 391 0
 586              	 .cfi_startproc
 587              	 
 588              	 
 589 0000 80B5     	 push {r7,lr}
 590              	.LCFI44:
 591              	 .cfi_def_cfa_offset 8
 592              	 .cfi_offset 7,-8
 593              	 .cfi_offset 14,-4
 594 0002 86B0     	 sub sp,sp,#24
 595              	.LCFI45:
 596              	 .cfi_def_cfa_offset 32
 597 0004 00AF     	 add r7,sp,#0
 598              	.LCFI46:
 599              	 .cfi_def_cfa_register 7
 600 0006 0346     	 mov r3,r0
 601 0008 FB71     	 strb r3,[r7,#7]
 392:../SSC/Src/ecatslv.c ****     UINT8 i;
 393:../SSC/Src/ecatslv.c ****     UINT8 result = 0;
 602              	 .loc 3 393 0
 603 000a 0023     	 movs r3,#0
 604 000c BB75     	 strb r3,[r7,#22]
 394:../SSC/Src/ecatslv.c ****     TSYNCMAN ESCMEM *pSyncMan;
 395:../SSC/Src/ecatslv.c ****     UINT16 SMLength = 0;
 605              	 .loc 3 395 0
 606 000e 0023     	 movs r3,#0
 607 0010 BB82     	 strh r3,[r7,#20]
 396:../SSC/Src/ecatslv.c ****     UINT16 SMAddress = 0;
 608              	 .loc 3 396 0
 609 0012 0023     	 movs r3,#0
 610 0014 7B82     	 strh r3,[r7,#18]
 397:../SSC/Src/ecatslv.c **** 
 398:../SSC/Src/ecatslv.c **** 
 399:../SSC/Src/ecatslv.c ****         //Check if max address defines are within the available ESC address range
 400:../SSC/Src/ecatslv.c ****         if ((nMaxEscAddress < MAX_PD_WRITE_ADDRESS)
 611              	 .loc 3 400 0
 612 0016 9F4B     	 ldr r3,.L79
 613 0018 1B88     	 ldrh r3,[r3]
 614 001a 42F6FE72 	 movw r2,#12286
 615 001e 9342     	 cmp r3,r2
 616 0020 11D9     	 bls .L29
 401:../SSC/Src/ecatslv.c ****             || (nMaxEscAddress < MAX_PD_READ_ADDRESS)
 617              	 .loc 3 401 0
 618 0022 9C4B     	 ldr r3,.L79
 619 0024 1B88     	 ldrh r3,[r3]
 620 0026 42F6FE72 	 movw r2,#12286
 621 002a 9342     	 cmp r3,r2
 622 002c 0BD9     	 bls .L29
 402:../SSC/Src/ecatslv.c ****             || (nMaxEscAddress < MAX_MBX_WRITE_ADDRESS)
 623              	 .loc 3 402 0
 624 002e 994B     	 ldr r3,.L79
 625 0030 1B88     	 ldrh r3,[r3]
 626 0032 42F6FE72 	 movw r2,#12286
 627 0036 9342     	 cmp r3,r2
 628 0038 05D9     	 bls .L29
 403:../SSC/Src/ecatslv.c ****             || (nMaxEscAddress < MAX_MBX_READ_ADDRESS))
 629              	 .loc 3 403 0
 630 003a 964B     	 ldr r3,.L79
 631 003c 1B88     	 ldrh r3,[r3]
 632 003e 42F6FE72 	 movw r2,#12286
 633 0042 9342     	 cmp r3,r2
 634 0044 01D8     	 bhi .L30
 635              	.L29:
 404:../SSC/Src/ecatslv.c ****         {
 405:../SSC/Src/ecatslv.c ****             /*The defines for maximum SM addresses are invalid for the used ESC (change the defines
 406:../SSC/Src/ecatslv.c ****             It may be also required to adapt the SM settings in the ESI file*/
 407:../SSC/Src/ecatslv.c **** 
 408:../SSC/Src/ecatslv.c **** 
 409:../SSC/Src/ecatslv.c ****                 return ALSTATUSCODE_NOVALIDFIRMWARE;
 636              	 .loc 3 409 0
 637 0046 1423     	 movs r3,#20
 638 0048 A5E1     	 b .L31
 639              	.L30:
 410:../SSC/Src/ecatslv.c ****         }
 411:../SSC/Src/ecatslv.c **** 
 412:../SSC/Src/ecatslv.c ****     /* check the Sync Manager Parameter for the Receive Mailbox (Sync Manager Channel 0) */
 413:../SSC/Src/ecatslv.c ****     pSyncMan = GetSyncMan(MAILBOX_WRITE);
 640              	 .loc 3 413 0
 641 004a 0020     	 movs r0,#0
 642 004c FFF7FEFF 	 bl GetSyncMan
 643 0050 F860     	 str r0,[r7,#12]
 414:../SSC/Src/ecatslv.c **** 
 415:../SSC/Src/ecatslv.c ****     SMLength = pSyncMan->Length;
 644              	 .loc 3 415 0
 645 0052 FB68     	 ldr r3,[r7,#12]
 646 0054 9A78     	 ldrb r2,[r3,#2]
 647 0056 DB78     	 ldrb r3,[r3,#3]
 648 0058 1B02     	 lsls r3,r3,#8
 649 005a 1343     	 orrs r3,r3,r2
 650 005c BB82     	 strh r3,[r7,#20]
 416:../SSC/Src/ecatslv.c ****     SMAddress = pSyncMan->PhysicalStartAddress;
 651              	 .loc 3 416 0
 652 005e FB68     	 ldr r3,[r7,#12]
 653 0060 1A78     	 ldrb r2,[r3]
 654 0062 5B78     	 ldrb r3,[r3,#1]
 655 0064 1B02     	 lsls r3,r3,#8
 656 0066 1343     	 orrs r3,r3,r2
 657 0068 7B82     	 strh r3,[r7,#18]
 417:../SSC/Src/ecatslv.c **** 
 418:../SSC/Src/ecatslv.c **** 
 419:../SSC/Src/ecatslv.c **** 
 420:../SSC/Src/ecatslv.c ****     if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
 658              	 .loc 3 420 0
 659 006a FB68     	 ldr r3,[r7,#12]
 660 006c 9B79     	 ldrb r3,[r3,#6]
 661 006e 03F00103 	 and r3,r3,#1
 662 0072 002B     	 cmp r3,#0
 663 0074 02D1     	 bne .L32
 421:../SSC/Src/ecatslv.c ****     {
 422:../SSC/Src/ecatslv.c ****         /* receive mailbox is not enabled */
 423:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 664              	 .loc 3 423 0
 665 0076 1623     	 movs r3,#22
 666 0078 BB75     	 strb r3,[r7,#22]
 667 007a 2AE0     	 b .L33
 668              	.L32:
 424:../SSC/Src/ecatslv.c ****     }
 425:../SSC/Src/ecatslv.c ****     else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETT
 669              	 .loc 3 425 0
 670 007c FB68     	 ldr r3,[r7,#12]
 671 007e 1B79     	 ldrb r3,[r3,#4]
 672 0080 03F00C03 	 and r3,r3,#12
 673 0084 042B     	 cmp r3,#4
 674 0086 02D0     	 beq .L34
 426:../SSC/Src/ecatslv.c ****     {
 427:../SSC/Src/ecatslv.c ****         /* receive mailbox is not writable by the master*/
 428:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 675              	 .loc 3 428 0
 676 0088 1623     	 movs r3,#22
 677 008a BB75     	 strb r3,[r7,#22]
 678 008c 21E0     	 b .L33
 679              	.L34:
 429:../SSC/Src/ecatslv.c ****     }
 430:../SSC/Src/ecatslv.c ****     else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_M
 680              	 .loc 3 430 0
 681 008e FB68     	 ldr r3,[r7,#12]
 682 0090 1B79     	 ldrb r3,[r3,#4]
 683 0092 03F00203 	 and r3,r3,#2
 684 0096 002B     	 cmp r3,#0
 685 0098 02D1     	 bne .L35
 431:../SSC/Src/ecatslv.c ****     {
 432:../SSC/Src/ecatslv.c ****         /* receive mailbox is not in one buffer mode */
 433:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 686              	 .loc 3 433 0
 687 009a 1623     	 movs r3,#22
 688 009c BB75     	 strb r3,[r7,#22]
 689 009e 18E0     	 b .L33
 690              	.L35:
 434:../SSC/Src/ecatslv.c ****     }
 435:../SSC/Src/ecatslv.c ****     else if (SMLength < MIN_MBX_SIZE)
 691              	 .loc 3 435 0
 692 00a0 BB8A     	 ldrh r3,[r7,#20]
 693 00a2 232B     	 cmp r3,#35
 694 00a4 02D8     	 bhi .L36
 436:../SSC/Src/ecatslv.c ****     {
 437:../SSC/Src/ecatslv.c ****         /* receive mailbox size is too small */
 438:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 695              	 .loc 3 438 0
 696 00a6 1623     	 movs r3,#22
 697 00a8 BB75     	 strb r3,[r7,#22]
 698 00aa 12E0     	 b .L33
 699              	.L36:
 439:../SSC/Src/ecatslv.c ****     }
 440:../SSC/Src/ecatslv.c ****     else if (SMLength > MAX_MBX_SIZE)
 700              	 .loc 3 440 0
 701 00ac BB8A     	 ldrh r3,[r7,#20]
 702 00ae 802B     	 cmp r3,#128
 703 00b0 02D9     	 bls .L37
 441:../SSC/Src/ecatslv.c ****     {
 442:../SSC/Src/ecatslv.c ****         /* receive mailbox size is too great */
 443:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 704              	 .loc 3 443 0
 705 00b2 1623     	 movs r3,#22
 706 00b4 BB75     	 strb r3,[r7,#22]
 707 00b6 0CE0     	 b .L33
 708              	.L37:
 444:../SSC/Src/ecatslv.c ****     }
 445:../SSC/Src/ecatslv.c ****     else if (SMAddress < MIN_MBX_WRITE_ADDRESS)
 709              	 .loc 3 445 0
 710 00b8 7B8A     	 ldrh r3,[r7,#18]
 711 00ba B3F5805F 	 cmp r3,#4096
 712 00be 02D2     	 bcs .L38
 446:../SSC/Src/ecatslv.c ****     {
 447:../SSC/Src/ecatslv.c ****         /* receive mailbox address is too small */
 448:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 713              	 .loc 3 448 0
 714 00c0 1623     	 movs r3,#22
 715 00c2 BB75     	 strb r3,[r7,#22]
 716 00c4 05E0     	 b .L33
 717              	.L38:
 449:../SSC/Src/ecatslv.c ****     }
 450:../SSC/Src/ecatslv.c ****     else if (SMAddress > MAX_MBX_WRITE_ADDRESS)
 718              	 .loc 3 450 0
 719 00c6 7B8A     	 ldrh r3,[r7,#18]
 720 00c8 B3F5405F 	 cmp r3,#12288
 721 00cc 01D3     	 bcc .L33
 451:../SSC/Src/ecatslv.c ****     {
 452:../SSC/Src/ecatslv.c ****         /* receive mailbox address is too great */
 453:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 722              	 .loc 3 453 0
 723 00ce 1623     	 movs r3,#22
 724 00d0 BB75     	 strb r3,[r7,#22]
 725              	.L33:
 454:../SSC/Src/ecatslv.c ****     }
 455:../SSC/Src/ecatslv.c **** 
 456:../SSC/Src/ecatslv.c **** 
 457:../SSC/Src/ecatslv.c ****     if ( result == 0 )
 726              	 .loc 3 457 0
 727 00d2 BB7D     	 ldrb r3,[r7,#22]
 728 00d4 002B     	 cmp r3,#0
 729 00d6 43D1     	 bne .L39
 458:../SSC/Src/ecatslv.c ****     {
 459:../SSC/Src/ecatslv.c ****         /* check the Sync Manager Parameter for the Send Mailbox (Sync Manager Channel 1) */
 460:../SSC/Src/ecatslv.c ****         pSyncMan = GetSyncMan(MAILBOX_READ);
 730              	 .loc 3 460 0
 731 00d8 0120     	 movs r0,#1
 732 00da FFF7FEFF 	 bl GetSyncMan
 733 00de F860     	 str r0,[r7,#12]
 461:../SSC/Src/ecatslv.c **** 
 462:../SSC/Src/ecatslv.c ****     SMLength = pSyncMan->Length;
 734              	 .loc 3 462 0
 735 00e0 FB68     	 ldr r3,[r7,#12]
 736 00e2 9A78     	 ldrb r2,[r3,#2]
 737 00e4 DB78     	 ldrb r3,[r3,#3]
 738 00e6 1B02     	 lsls r3,r3,#8
 739 00e8 1343     	 orrs r3,r3,r2
 740 00ea BB82     	 strh r3,[r7,#20]
 463:../SSC/Src/ecatslv.c ****     SMAddress = pSyncMan->PhysicalStartAddress;
 741              	 .loc 3 463 0
 742 00ec FB68     	 ldr r3,[r7,#12]
 743 00ee 1A78     	 ldrb r2,[r3]
 744 00f0 5B78     	 ldrb r3,[r3,#1]
 745 00f2 1B02     	 lsls r3,r3,#8
 746 00f4 1343     	 orrs r3,r3,r2
 747 00f6 7B82     	 strh r3,[r7,#18]
 464:../SSC/Src/ecatslv.c **** 
 465:../SSC/Src/ecatslv.c **** 
 466:../SSC/Src/ecatslv.c ****     if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
 748              	 .loc 3 466 0
 749 00f8 FB68     	 ldr r3,[r7,#12]
 750 00fa 9B79     	 ldrb r3,[r3,#6]
 751 00fc 03F00103 	 and r3,r3,#1
 752 0100 002B     	 cmp r3,#0
 753 0102 02D1     	 bne .L40
 467:../SSC/Src/ecatslv.c ****     {
 468:../SSC/Src/ecatslv.c ****         /* send mailbox is not enabled */
 469:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 754              	 .loc 3 469 0
 755 0104 1623     	 movs r3,#22
 756 0106 BB75     	 strb r3,[r7,#22]
 757 0108 2AE0     	 b .L39
 758              	.L40:
 470:../SSC/Src/ecatslv.c ****     }
 471:../SSC/Src/ecatslv.c ****     else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETT
 759              	 .loc 3 471 0
 760 010a FB68     	 ldr r3,[r7,#12]
 761 010c 1B79     	 ldrb r3,[r3,#4]
 762 010e 03F00C03 	 and r3,r3,#12
 763 0112 002B     	 cmp r3,#0
 764 0114 02D0     	 beq .L41
 472:../SSC/Src/ecatslv.c ****     {
 473:../SSC/Src/ecatslv.c ****         /* receive mailbox is not readable by the master*/
 474:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 765              	 .loc 3 474 0
 766 0116 1623     	 movs r3,#22
 767 0118 BB75     	 strb r3,[r7,#22]
 768 011a 21E0     	 b .L39
 769              	.L41:
 475:../SSC/Src/ecatslv.c ****     }
 476:../SSC/Src/ecatslv.c ****     else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_M
 770              	 .loc 3 476 0
 771 011c FB68     	 ldr r3,[r7,#12]
 772 011e 1B79     	 ldrb r3,[r3,#4]
 773 0120 03F00203 	 and r3,r3,#2
 774 0124 002B     	 cmp r3,#0
 775 0126 02D1     	 bne .L42
 477:../SSC/Src/ecatslv.c ****     {
 478:../SSC/Src/ecatslv.c ****         /* receive mailbox is not in one buffer mode */
 479:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 776              	 .loc 3 479 0
 777 0128 1623     	 movs r3,#22
 778 012a BB75     	 strb r3,[r7,#22]
 779 012c 18E0     	 b .L39
 780              	.L42:
 480:../SSC/Src/ecatslv.c ****     }
 481:../SSC/Src/ecatslv.c ****     else if (SMLength < MIN_MBX_SIZE)
 781              	 .loc 3 481 0
 782 012e BB8A     	 ldrh r3,[r7,#20]
 783 0130 232B     	 cmp r3,#35
 784 0132 02D8     	 bhi .L43
 482:../SSC/Src/ecatslv.c ****     {
 483:../SSC/Src/ecatslv.c ****         /* send mailbox size is too small */
 484:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 785              	 .loc 3 484 0
 786 0134 1623     	 movs r3,#22
 787 0136 BB75     	 strb r3,[r7,#22]
 788 0138 12E0     	 b .L39
 789              	.L43:
 485:../SSC/Src/ecatslv.c ****     }
 486:../SSC/Src/ecatslv.c ****     else if (SMLength > MAX_MBX_SIZE)
 790              	 .loc 3 486 0
 791 013a BB8A     	 ldrh r3,[r7,#20]
 792 013c 802B     	 cmp r3,#128
 793 013e 02D9     	 bls .L44
 487:../SSC/Src/ecatslv.c ****     {
 488:../SSC/Src/ecatslv.c ****         /* send mailbox size is too great */
 489:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 794              	 .loc 3 489 0
 795 0140 1623     	 movs r3,#22
 796 0142 BB75     	 strb r3,[r7,#22]
 797 0144 0CE0     	 b .L39
 798              	.L44:
 490:../SSC/Src/ecatslv.c ****     }
 491:../SSC/Src/ecatslv.c ****     else if (SMAddress < MIN_MBX_READ_ADDRESS)
 799              	 .loc 3 491 0
 800 0146 7B8A     	 ldrh r3,[r7,#18]
 801 0148 B3F5805F 	 cmp r3,#4096
 802 014c 02D2     	 bcs .L45
 492:../SSC/Src/ecatslv.c ****     {
 493:../SSC/Src/ecatslv.c ****         /* send mailbox address is too small */
 494:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 803              	 .loc 3 494 0
 804 014e 1623     	 movs r3,#22
 805 0150 BB75     	 strb r3,[r7,#22]
 806 0152 05E0     	 b .L39
 807              	.L45:
 495:../SSC/Src/ecatslv.c ****     }
 496:../SSC/Src/ecatslv.c ****     else if (SMAddress > MAX_MBX_READ_ADDRESS)
 808              	 .loc 3 496 0
 809 0154 7B8A     	 ldrh r3,[r7,#18]
 810 0156 B3F5405F 	 cmp r3,#12288
 811 015a 01D3     	 bcc .L39
 497:../SSC/Src/ecatslv.c ****     {
 498:../SSC/Src/ecatslv.c ****         /* send mailbox address is too great */
 499:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 812              	 .loc 3 499 0
 813 015c 1623     	 movs r3,#22
 814 015e BB75     	 strb r3,[r7,#22]
 815              	.L39:
 500:../SSC/Src/ecatslv.c ****     }
 501:../SSC/Src/ecatslv.c ****     }
 502:../SSC/Src/ecatslv.c **** 
 503:../SSC/Src/ecatslv.c ****     if ( result == 0 && maxChannel > PROCESS_DATA_IN )
 816              	 .loc 3 503 0
 817 0160 BB7D     	 ldrb r3,[r7,#22]
 818 0162 002B     	 cmp r3,#0
 819 0164 71D1     	 bne .L46
 820              	 .loc 3 503 0 is_stmt 0 discriminator 1
 821 0166 FB79     	 ldrb r3,[r7,#7]
 822 0168 032B     	 cmp r3,#3
 823 016a 6ED9     	 bls .L46
 504:../SSC/Src/ecatslv.c ****     {
 505:../SSC/Src/ecatslv.c ****         /* b3BufferMode is only set, if inputs and outputs are running in 3-Buffer-Mode when leavin
 506:../SSC/Src/ecatslv.c ****         b3BufferMode = TRUE;
 824              	 .loc 3 506 0 is_stmt 1
 825 016c 4A4B     	 ldr r3,.L79+4
 826 016e 0122     	 movs r2,#1
 827 0170 1A70     	 strb r2,[r3]
 507:../SSC/Src/ecatslv.c ****         /* check the Sync Manager Parameter for the Inputs (Sync Manager Channel 2 (0 in case if no
 508:../SSC/Src/ecatslv.c ****         pSyncMan = GetSyncMan(PROCESS_DATA_IN);
 828              	 .loc 3 508 0
 829 0172 0320     	 movs r0,#3
 830 0174 FFF7FEFF 	 bl GetSyncMan
 831 0178 F860     	 str r0,[r7,#12]
 509:../SSC/Src/ecatslv.c **** 
 510:../SSC/Src/ecatslv.c ****     SMLength = pSyncMan->Length;
 832              	 .loc 3 510 0
 833 017a FB68     	 ldr r3,[r7,#12]
 834 017c 9A78     	 ldrb r2,[r3,#2]
 835 017e DB78     	 ldrb r3,[r3,#3]
 836 0180 1B02     	 lsls r3,r3,#8
 837 0182 1343     	 orrs r3,r3,r2
 838 0184 BB82     	 strh r3,[r7,#20]
 511:../SSC/Src/ecatslv.c ****     SMAddress = pSyncMan->PhysicalStartAddress;
 839              	 .loc 3 511 0
 840 0186 FB68     	 ldr r3,[r7,#12]
 841 0188 1A78     	 ldrb r2,[r3]
 842 018a 5B78     	 ldrb r3,[r3,#1]
 843 018c 1B02     	 lsls r3,r3,#8
 844 018e 1343     	 orrs r3,r3,r2
 845 0190 7B82     	 strh r3,[r7,#18]
 512:../SSC/Src/ecatslv.c **** 
 513:../SSC/Src/ecatslv.c **** 
 514:../SSC/Src/ecatslv.c **** 
 515:../SSC/Src/ecatslv.c ****     if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength
 846              	 .loc 3 515 0
 847 0192 FB68     	 ldr r3,[r7,#12]
 848 0194 9B79     	 ldrb r3,[r3,#6]
 849 0196 03F00103 	 and r3,r3,#1
 850 019a 002B     	 cmp r3,#0
 851 019c 05D0     	 beq .L47
 852              	 .loc 3 515 0 is_stmt 0 discriminator 1
 853 019e BB8A     	 ldrh r3,[r7,#20]
 854 01a0 002B     	 cmp r3,#0
 855 01a2 02D1     	 bne .L47
 516:../SSC/Src/ecatslv.c ****     {
 517:../SSC/Src/ecatslv.c ****         /* the SM3 size is 0 and the SM3 is active */
 518:../SSC/Src/ecatslv.c ****         result = SYNCMANCHSETTINGS + 1;
 856              	 .loc 3 518 0 is_stmt 1
 857 01a4 0423     	 movs r3,#4
 858 01a6 BB75     	 strb r3,[r7,#22]
 859 01a8 4AE0     	 b .L48
 860              	.L47:
 519:../SSC/Src/ecatslv.c ****     }
 520:../SSC/Src/ecatslv.c ****         else if (pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE)
 861              	 .loc 3 520 0
 862 01aa FB68     	 ldr r3,[r7,#12]
 863 01ac 9B79     	 ldrb r3,[r3,#6]
 864 01ae 03F00103 	 and r3,r3,#1
 865 01b2 002B     	 cmp r3,#0
 866 01b4 3BD0     	 beq .L49
 521:../SSC/Src/ecatslv.c ****         {
 522:../SSC/Src/ecatslv.c ****             /* Sync Manager Channel 3 is active, input size has to greater 0 */
 523:../SSC/Src/ecatslv.c ****                 if (SMLength != nPdInputSize || nPdInputSize == 0 || SMLength > MAX_PD_INPUT_SIZE)
 867              	 .loc 3 523 0
 868 01b6 394B     	 ldr r3,.L79+8
 869 01b8 1B88     	 ldrh r3,[r3]
 870 01ba BA8A     	 ldrh r2,[r7,#20]
 871 01bc 9A42     	 cmp r2,r3
 872 01be 06D1     	 bne .L50
 873              	 .loc 3 523 0 is_stmt 0 discriminator 1
 874 01c0 364B     	 ldr r3,.L79+8
 875 01c2 1B88     	 ldrh r3,[r3]
 876 01c4 002B     	 cmp r3,#0
 877 01c6 02D0     	 beq .L50
 878              	 .loc 3 523 0 discriminator 2
 879 01c8 BB8A     	 ldrh r3,[r7,#20]
 880 01ca 0C2B     	 cmp r3,#12
 881 01cc 02D9     	 bls .L51
 882              	.L50:
 524:../SSC/Src/ecatslv.c ****                 {
 525:../SSC/Src/ecatslv.c ****                     /* sizes don't match */
 526:../SSC/Src/ecatslv.c ****                     result = SYNCMANCHSIZE + 1;
 883              	 .loc 3 526 0 is_stmt 1
 884 01ce 0323     	 movs r3,#3
 885 01d0 BB75     	 strb r3,[r7,#22]
 886 01d2 35E0     	 b .L48
 887              	.L51:
 527:../SSC/Src/ecatslv.c ****                 }
 528:../SSC/Src/ecatslv.c ****                 else
 529:../SSC/Src/ecatslv.c ****                 {
 530:../SSC/Src/ecatslv.c ****                     /* sizes matches */
 531:../SSC/Src/ecatslv.c ****                     if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK)
 888              	 .loc 3 531 0
 889 01d4 FB68     	 ldr r3,[r7,#12]
 890 01d6 1B79     	 ldrb r3,[r3,#4]
 891 01d8 03F00C03 	 and r3,r3,#12
 892 01dc 002B     	 cmp r3,#0
 893 01de 23D1     	 bne .L53
 532:../SSC/Src/ecatslv.c ****                     {
 533:../SSC/Src/ecatslv.c ****                         /* settings match */
 534:../SSC/Src/ecatslv.c ****                         if (((nAlStatus == STATE_PREOP) && (SMAddress >= MIN_PD_READ_ADDRESS) && (S
 894              	 .loc 3 534 0
 895 01e0 2F4B     	 ldr r3,.L79+12
 896 01e2 1B78     	 ldrb r3,[r3]
 897 01e4 022B     	 cmp r3,#2
 898 01e6 07D1     	 bne .L54
 899              	 .loc 3 534 0 is_stmt 0 discriminator 1
 900 01e8 7B8A     	 ldrh r3,[r7,#18]
 901 01ea B3F5805F 	 cmp r3,#4096
 902 01ee 03D3     	 bcc .L54
 903              	 .loc 3 534 0 discriminator 2
 904 01f0 7B8A     	 ldrh r3,[r7,#18]
 905 01f2 B3F5405F 	 cmp r3,#12288
 906 01f6 08D3     	 bcc .L55
 907              	.L54:
 535:../SSC/Src/ecatslv.c ****                             || ((nAlStatus != STATE_PREOP) && (SMAddress == nEscAddrInputData))
 908              	 .loc 3 535 0 is_stmt 1
 909 01f8 294B     	 ldr r3,.L79+12
 910 01fa 1B78     	 ldrb r3,[r3]
 911 01fc 022B     	 cmp r3,#2
 912 01fe 0FD0     	 beq .L56
 913              	 .loc 3 535 0 is_stmt 0 discriminator 1
 914 0200 284B     	 ldr r3,.L79+16
 915 0202 1B88     	 ldrh r3,[r3]
 916 0204 7A8A     	 ldrh r2,[r7,#18]
 917 0206 9A42     	 cmp r2,r3
 918 0208 0AD1     	 bne .L56
 919              	.L55:
 536:../SSC/Src/ecatslv.c ****                             )
 537:../SSC/Src/ecatslv.c ****                         {
 538:../SSC/Src/ecatslv.c ****                             /* addresses match */
 539:../SSC/Src/ecatslv.c **** 
 540:../SSC/Src/ecatslv.c ****                                 if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MOD
 920              	 .loc 3 540 0 is_stmt 1
 921 020a FB68     	 ldr r3,[r7,#12]
 922 020c 1B79     	 ldrb r3,[r3,#4]
 923 020e 03F00203 	 and r3,r3,#2
 924 0212 002B     	 cmp r3,#0
 925 0214 03D0     	 beq .L57
 541:../SSC/Src/ecatslv.c ****                                 {
 542:../SSC/Src/ecatslv.c ****                                     /* inputs are running in 1-Buffer-Mode, reset flag b3BufferMode
 543:../SSC/Src/ecatslv.c ****                                     b3BufferMode = FALSE;
 926              	 .loc 3 543 0
 927 0216 204B     	 ldr r3,.L79+4
 928 0218 0022     	 movs r2,#0
 929 021a 1A70     	 strb r2,[r3]
 540:../SSC/Src/ecatslv.c ****                                 {
 930              	 .loc 3 540 0
 931 021c 03E0     	 b .L58
 932              	.L57:
 933 021e 02E0     	 b .L58
 934              	.L56:
 544:../SSC/Src/ecatslv.c ****                                 }
 545:../SSC/Src/ecatslv.c ****                         }
 546:../SSC/Src/ecatslv.c ****                         else
 547:../SSC/Src/ecatslv.c ****                         {
 548:../SSC/Src/ecatslv.c ****                             /* input address is out of the allowed area or has changed in SAFEOP or
 549:../SSC/Src/ecatslv.c ****                             result = SYNCMANCHADDRESS + 1;
 935              	 .loc 3 549 0
 936 0220 0223     	 movs r3,#2
 937 0222 BB75     	 strb r3,[r7,#22]
 938 0224 0CE0     	 b .L48
 939              	.L58:
 940 0226 0BE0     	 b .L48
 941              	.L53:
 550:../SSC/Src/ecatslv.c ****                         }
 551:../SSC/Src/ecatslv.c ****                     }
 552:../SSC/Src/ecatslv.c ****                     else
 553:../SSC/Src/ecatslv.c ****                     {
 554:../SSC/Src/ecatslv.c ****                         /* input settings do not match */
 555:../SSC/Src/ecatslv.c ****                         result = SYNCMANCHSETTINGS + 1;
 942              	 .loc 3 555 0
 943 0228 0423     	 movs r3,#4
 944 022a BB75     	 strb r3,[r7,#22]
 945 022c 08E0     	 b .L48
 946              	.L49:
 556:../SSC/Src/ecatslv.c ****                     }
 557:../SSC/Src/ecatslv.c ****                 }
 558:../SSC/Src/ecatslv.c ****         }
 559:../SSC/Src/ecatslv.c ****         else if (SMLength != 0 || nPdInputSize != 0)
 947              	 .loc 3 559 0
 948 022e BB8A     	 ldrh r3,[r7,#20]
 949 0230 002B     	 cmp r3,#0
 950 0232 03D1     	 bne .L59
 951              	 .loc 3 559 0 is_stmt 0 discriminator 1
 952 0234 194B     	 ldr r3,.L79+8
 953 0236 1B88     	 ldrh r3,[r3]
 954 0238 002B     	 cmp r3,#0
 955 023a 01D0     	 beq .L48
 956              	.L59:
 560:../SSC/Src/ecatslv.c ****         {
 561:../SSC/Src/ecatslv.c ****             /* input size is not zero although the SM3 channel is not enabled */
 562:../SSC/Src/ecatslv.c ****             result = SYNCMANCHSIZE + 1;
 957              	 .loc 3 562 0 is_stmt 1
 958 023c 0323     	 movs r3,#3
 959 023e BB75     	 strb r3,[r7,#22]
 960              	.L48:
 563:../SSC/Src/ecatslv.c ****         }
 564:../SSC/Src/ecatslv.c **** 
 565:../SSC/Src/ecatslv.c **** 
 566:../SSC/Src/ecatslv.c **** 
 567:../SSC/Src/ecatslv.c ****         if ( result != 0 )
 961              	 .loc 3 567 0
 962 0240 BB7D     	 ldrb r3,[r7,#22]
 963 0242 002B     	 cmp r3,#0
 964 0244 01D0     	 beq .L46
 568:../SSC/Src/ecatslv.c ****         {
 569:../SSC/Src/ecatslv.c ****             result = ALSTATUSCODE_INVALIDSMINCFG;
 965              	 .loc 3 569 0
 966 0246 1E23     	 movs r3,#30
 967 0248 BB75     	 strb r3,[r7,#22]
 968              	.L46:
 570:../SSC/Src/ecatslv.c ****         }
 571:../SSC/Src/ecatslv.c ****     }
 572:../SSC/Src/ecatslv.c **** 
 573:../SSC/Src/ecatslv.c **** 
 574:../SSC/Src/ecatslv.c **** //    else
 575:../SSC/Src/ecatslv.c ****     if (result == 0 && maxChannel > PROCESS_DATA_OUT)
 969              	 .loc 3 575 0
 970 024a BB7D     	 ldrb r3,[r7,#22]
 971 024c 002B     	 cmp r3,#0
 972 024e 40F08A80 	 bne .L60
 973              	 .loc 3 575 0 is_stmt 0 discriminator 1
 974 0252 FB79     	 ldrb r3,[r7,#7]
 975 0254 022B     	 cmp r3,#2
 976 0256 40F28680 	 bls .L60
 576:../SSC/Src/ecatslv.c ****     {
 577:../SSC/Src/ecatslv.c ****         /* check the Sync Manager Parameter for the Outputs (Sync Manager Channel 2) */
 578:../SSC/Src/ecatslv.c ****         pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
 977              	 .loc 3 578 0 is_stmt 1
 978 025a 0220     	 movs r0,#2
 979 025c FFF7FEFF 	 bl GetSyncMan
 980 0260 F860     	 str r0,[r7,#12]
 579:../SSC/Src/ecatslv.c **** 
 580:../SSC/Src/ecatslv.c ****     SMLength = pSyncMan->Length;
 981              	 .loc 3 580 0
 982 0262 FB68     	 ldr r3,[r7,#12]
 983 0264 9A78     	 ldrb r2,[r3,#2]
 984 0266 DB78     	 ldrb r3,[r3,#3]
 985 0268 1B02     	 lsls r3,r3,#8
 986 026a 1343     	 orrs r3,r3,r2
 987 026c BB82     	 strh r3,[r7,#20]
 581:../SSC/Src/ecatslv.c ****     SMAddress = pSyncMan->PhysicalStartAddress;
 988              	 .loc 3 581 0
 989 026e FB68     	 ldr r3,[r7,#12]
 990 0270 1A78     	 ldrb r2,[r3]
 991 0272 5B78     	 ldrb r3,[r3,#1]
 992 0274 1B02     	 lsls r3,r3,#8
 993 0276 1343     	 orrs r3,r3,r2
 994 0278 7B82     	 strh r3,[r7,#18]
 582:../SSC/Src/ecatslv.c **** 
 583:../SSC/Src/ecatslv.c **** 
 584:../SSC/Src/ecatslv.c **** 
 585:../SSC/Src/ecatslv.c ****     if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength
 995              	 .loc 3 585 0
 996 027a FB68     	 ldr r3,[r7,#12]
 997 027c 9B79     	 ldrb r3,[r3,#6]
 998 027e 03F00103 	 and r3,r3,#1
 999 0282 002B     	 cmp r3,#0
 1000 0284 10D0     	 beq .L61
 1001              	 .loc 3 585 0 is_stmt 0 discriminator 1
 1002 0286 BB8A     	 ldrh r3,[r7,#20]
 1003 0288 002B     	 cmp r3,#0
 1004 028a 0DD1     	 bne .L61
 586:../SSC/Src/ecatslv.c ****     {
 587:../SSC/Src/ecatslv.c ****         /* the SM2 size is 0 and the SM2 is active */
 588:../SSC/Src/ecatslv.c ****         result = SYNCMANCHSETTINGS + 1;
 1005              	 .loc 3 588 0 is_stmt 1
 1006 028c 0423     	 movs r3,#4
 1007 028e BB75     	 strb r3,[r7,#22]
 1008 0290 64E0     	 b .L62
 1009              	.L80:
 1010 0292 00BF     	 .align 2
 1011              	.L79:
 1012 0294 00000000 	 .word nMaxEscAddress
 1013 0298 00000000 	 .word b3BufferMode
 1014 029c 00000000 	 .word nPdInputSize
 1015 02a0 00000000 	 .word nAlStatus
 1016 02a4 00000000 	 .word nEscAddrInputData
 1017              	.L61:
 589:../SSC/Src/ecatslv.c ****     }
 590:../SSC/Src/ecatslv.c ****         else if (pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE)
 1018              	 .loc 3 590 0
 1019 02a8 FB68     	 ldr r3,[r7,#12]
 1020 02aa 9B79     	 ldrb r3,[r3,#6]
 1021 02ac 03F00103 	 and r3,r3,#1
 1022 02b0 002B     	 cmp r3,#0
 1023 02b2 4AD0     	 beq .L63
 591:../SSC/Src/ecatslv.c ****         {
 592:../SSC/Src/ecatslv.c ****             /* Sync Manager Channel 2 is active, output size has to greater 0 */
 593:../SSC/Src/ecatslv.c ****             if ( SMLength == nPdOutputSize && nPdOutputSize != 0 && SMLength <= ((UINT16)MAX_PD_OUT
 1024              	 .loc 3 593 0
 1025 02b4 3A4B     	 ldr r3,.L81
 1026 02b6 1B88     	 ldrh r3,[r3]
 1027 02b8 BA8A     	 ldrh r2,[r7,#20]
 1028 02ba 9A42     	 cmp r2,r3
 1029 02bc 41D1     	 bne .L64
 1030              	 .loc 3 593 0 is_stmt 0 discriminator 1
 1031 02be 384B     	 ldr r3,.L81
 1032 02c0 1B88     	 ldrh r3,[r3]
 1033 02c2 002B     	 cmp r3,#0
 1034 02c4 3DD0     	 beq .L64
 1035              	 .loc 3 593 0 discriminator 2
 1036 02c6 BB8A     	 ldrh r3,[r7,#20]
 1037 02c8 0C2B     	 cmp r3,#12
 1038 02ca 3AD8     	 bhi .L64
 594:../SSC/Src/ecatslv.c ****             {
 595:../SSC/Src/ecatslv.c ****                 /* sizes match */
 596:../SSC/Src/ecatslv.c ****                 if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) ==
 1039              	 .loc 3 596 0 is_stmt 1
 1040 02cc FB68     	 ldr r3,[r7,#12]
 1041 02ce 1B79     	 ldrb r3,[r3,#4]
 1042 02d0 03F00C03 	 and r3,r3,#12
 1043 02d4 042B     	 cmp r3,#4
 1044 02d6 30D1     	 bne .L65
 597:../SSC/Src/ecatslv.c ****                 {
 598:../SSC/Src/ecatslv.c ****                     /* settings match */
 599:../SSC/Src/ecatslv.c ****                     if ( ( ( nAlStatus == STATE_PREOP )&&( SMAddress >= MIN_PD_WRITE_ADDRESS )&&( S
 1045              	 .loc 3 599 0
 1046 02d8 324B     	 ldr r3,.L81+4
 1047 02da 1B78     	 ldrb r3,[r3]
 1048 02dc 022B     	 cmp r3,#2
 1049 02de 07D1     	 bne .L66
 1050              	 .loc 3 599 0 is_stmt 0 discriminator 1
 1051 02e0 7B8A     	 ldrh r3,[r7,#18]
 1052 02e2 B3F5805F 	 cmp r3,#4096
 1053 02e6 03D3     	 bcc .L66
 1054              	 .loc 3 599 0 discriminator 2
 1055 02e8 7B8A     	 ldrh r3,[r7,#18]
 1056 02ea B3F5405F 	 cmp r3,#12288
 1057 02ee 08D3     	 bcc .L67
 1058              	.L66:
 600:../SSC/Src/ecatslv.c ****                        ||( ( nAlStatus != STATE_PREOP )&&( SMAddress == nEscAddrOutputData ) )
 1059              	 .loc 3 600 0 is_stmt 1
 1060 02f0 2C4B     	 ldr r3,.L81+4
 1061 02f2 1B78     	 ldrb r3,[r3]
 1062 02f4 022B     	 cmp r3,#2
 1063 02f6 1CD0     	 beq .L68
 1064              	 .loc 3 600 0 is_stmt 0 discriminator 1
 1065 02f8 2B4B     	 ldr r3,.L81+8
 1066 02fa 1B88     	 ldrh r3,[r3]
 1067 02fc 7A8A     	 ldrh r2,[r7,#18]
 1068 02fe 9A42     	 cmp r2,r3
 1069 0300 17D1     	 bne .L68
 1070              	.L67:
 601:../SSC/Src/ecatslv.c ****                         )
 602:../SSC/Src/ecatslv.c ****                     {
 603:../SSC/Src/ecatslv.c ****                         /* addresses match */
 604:../SSC/Src/ecatslv.c ****                         {
 605:../SSC/Src/ecatslv.c ****                             /* check, if watchdog trigger is enabled */
 606:../SSC/Src/ecatslv.c ****                             if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_WATCHDOG
 1071              	 .loc 3 606 0 is_stmt 1
 1072 0302 FB68     	 ldr r3,[r7,#12]
 1073 0304 1B79     	 ldrb r3,[r3,#4]
 1074 0306 03F04003 	 and r3,r3,#64
 1075 030a 002B     	 cmp r3,#0
 1076 030c 03D0     	 beq .L69
 607:../SSC/Src/ecatslv.c ****                             {
 608:../SSC/Src/ecatslv.c ****                                 bWdTrigger = TRUE;
 1077              	 .loc 3 608 0
 1078 030e 274B     	 ldr r3,.L81+12
 1079 0310 0122     	 movs r2,#1
 1080 0312 1A70     	 strb r2,[r3]
 1081 0314 02E0     	 b .L70
 1082              	.L69:
 609:../SSC/Src/ecatslv.c ****                             }
 610:../SSC/Src/ecatslv.c ****                             else
 611:../SSC/Src/ecatslv.c ****                             {
 612:../SSC/Src/ecatslv.c ****                                 bWdTrigger = FALSE;
 1083              	 .loc 3 612 0
 1084 0316 254B     	 ldr r3,.L81+12
 1085 0318 0022     	 movs r2,#0
 1086 031a 1A70     	 strb r2,[r3]
 1087              	.L70:
 613:../SSC/Src/ecatslv.c ****                             }
 614:../SSC/Src/ecatslv.c **** 
 615:../SSC/Src/ecatslv.c ****                             if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MA
 1088              	 .loc 3 615 0
 1089 031c FB68     	 ldr r3,[r7,#12]
 1090 031e 1B79     	 ldrb r3,[r3,#4]
 1091 0320 03F00203 	 and r3,r3,#2
 1092 0324 002B     	 cmp r3,#0
 1093 0326 03D0     	 beq .L71
 616:../SSC/Src/ecatslv.c ****                             {
 617:../SSC/Src/ecatslv.c ****                                 /* outputs are running in 1-Buffer-Mode, reset flag b3BufferMode */
 618:../SSC/Src/ecatslv.c ****                                 b3BufferMode = FALSE;
 1094              	 .loc 3 618 0
 1095 0328 214B     	 ldr r3,.L81+16
 1096 032a 0022     	 movs r2,#0
 1097 032c 1A70     	 strb r2,[r3]
 615:../SSC/Src/ecatslv.c ****                             {
 1098              	 .loc 3 615 0
 1099 032e 03E0     	 b .L72
 1100              	.L71:
 1101 0330 02E0     	 b .L72
 1102              	.L68:
 619:../SSC/Src/ecatslv.c ****                                 }
 620:../SSC/Src/ecatslv.c ****                         }
 621:../SSC/Src/ecatslv.c ****                     }
 622:../SSC/Src/ecatslv.c ****                     else
 623:../SSC/Src/ecatslv.c ****                     {
 624:../SSC/Src/ecatslv.c ****                         /* output address is out of the allowed area or has changed in SAFEOP or OP
 625:../SSC/Src/ecatslv.c ****                         result = SYNCMANCHADDRESS + 1;
 1103              	 .loc 3 625 0
 1104 0332 0223     	 movs r3,#2
 1105 0334 BB75     	 strb r3,[r7,#22]
 1106 0336 03E0     	 b .L73
 1107              	.L72:
 1108 0338 02E0     	 b .L73
 1109              	.L65:
 626:../SSC/Src/ecatslv.c ****                     }
 627:../SSC/Src/ecatslv.c ****                 }
 628:../SSC/Src/ecatslv.c ****                 else
 629:../SSC/Src/ecatslv.c ****                 {
 630:../SSC/Src/ecatslv.c ****                     /* output settings do not match */
 631:../SSC/Src/ecatslv.c ****                     result = SYNCMANCHSETTINGS + 1;
 1110              	 .loc 3 631 0
 1111 033a 0423     	 movs r3,#4
 1112 033c BB75     	 strb r3,[r7,#22]
 596:../SSC/Src/ecatslv.c ****                 {
 1113              	 .loc 3 596 0
 1114 033e 03E0     	 b .L74
 1115              	.L73:
 596:../SSC/Src/ecatslv.c ****                 {
 1116              	 .loc 3 596 0 is_stmt 0 discriminator 4
 1117 0340 02E0     	 b .L74
 1118              	.L64:
 632:../SSC/Src/ecatslv.c ****                 }
 633:../SSC/Src/ecatslv.c ****             }
 634:../SSC/Src/ecatslv.c ****             else
 635:../SSC/Src/ecatslv.c ****             {
 636:../SSC/Src/ecatslv.c ****                 /* output sizes don't match */
 637:../SSC/Src/ecatslv.c ****                 result = SYNCMANCHSIZE + 1;
 1119              	 .loc 3 637 0 is_stmt 1
 1120 0342 0323     	 movs r3,#3
 1121 0344 BB75     	 strb r3,[r7,#22]
 1122 0346 09E0     	 b .L62
 1123              	.L74:
 1124 0348 08E0     	 b .L62
 1125              	.L63:
 638:../SSC/Src/ecatslv.c ****             }
 639:../SSC/Src/ecatslv.c ****         }
 640:../SSC/Src/ecatslv.c ****         else if (SMLength != 0 || nPdOutputSize != 0)
 1126              	 .loc 3 640 0
 1127 034a BB8A     	 ldrh r3,[r7,#20]
 1128 034c 002B     	 cmp r3,#0
 1129 034e 03D1     	 bne .L75
 1130              	 .loc 3 640 0 is_stmt 0 discriminator 1
 1131 0350 134B     	 ldr r3,.L81
 1132 0352 1B88     	 ldrh r3,[r3]
 1133 0354 002B     	 cmp r3,#0
 1134 0356 01D0     	 beq .L62
 1135              	.L75:
 641:../SSC/Src/ecatslv.c ****         {
 642:../SSC/Src/ecatslv.c ****             /* output size is not zero although the SM2 channel is not enabled */
 643:../SSC/Src/ecatslv.c ****             result = SYNCMANCHSIZE + 1;
 1136              	 .loc 3 643 0 is_stmt 1
 1137 0358 0323     	 movs r3,#3
 1138 035a BB75     	 strb r3,[r7,#22]
 1139              	.L62:
 644:../SSC/Src/ecatslv.c ****         }
 645:../SSC/Src/ecatslv.c **** 
 646:../SSC/Src/ecatslv.c ****         if ( result != 0 )
 1140              	 .loc 3 646 0
 1141 035c BB7D     	 ldrb r3,[r7,#22]
 1142 035e 002B     	 cmp r3,#0
 1143 0360 01D0     	 beq .L60
 647:../SSC/Src/ecatslv.c ****         {
 648:../SSC/Src/ecatslv.c ****             result = ALSTATUSCODE_INVALIDSMOUTCFG;
 1144              	 .loc 3 648 0
 1145 0362 1D23     	 movs r3,#29
 1146 0364 BB75     	 strb r3,[r7,#22]
 1147              	.L60:
 649:../SSC/Src/ecatslv.c ****         }
 650:../SSC/Src/ecatslv.c ****     }
 651:../SSC/Src/ecatslv.c **** 
 652:../SSC/Src/ecatslv.c **** 
 653:../SSC/Src/ecatslv.c ****     if ( result == 0 )
 1148              	 .loc 3 653 0
 1149 0366 BB7D     	 ldrb r3,[r7,#22]
 1150 0368 002B     	 cmp r3,#0
 1151 036a 13D1     	 bne .L76
 654:../SSC/Src/ecatslv.c ****     {
 655:../SSC/Src/ecatslv.c ****         /* the Enable-Byte of the rest of the SM channels has to be read to acknowledge the SM-Chan
 656:../SSC/Src/ecatslv.c ****         for (i = maxChannel; i < nMaxSyncMan; i++)
 1152              	 .loc 3 656 0
 1153 036c FB79     	 ldrb r3,[r7,#7]
 1154 036e FB75     	 strb r3,[r7,#23]
 1155 0370 0BE0     	 b .L77
 1156              	.L78:
 657:../SSC/Src/ecatslv.c ****         {
 658:../SSC/Src/ecatslv.c ****             pSyncMan = GetSyncMan(i);
 1157              	 .loc 3 658 0 discriminator 3
 1158 0372 FB7D     	 ldrb r3,[r7,#23]
 1159 0374 1846     	 mov r0,r3
 1160 0376 FFF7FEFF 	 bl GetSyncMan
 1161 037a F860     	 str r0,[r7,#12]
 659:../SSC/Src/ecatslv.c ****             SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
 1162              	 .loc 3 659 0 discriminator 3
 1163 037c FB68     	 ldr r3,[r7,#12]
 1164 037e 9A79     	 ldrb r2,[r3,#6]
 1165 0380 0C4B     	 ldr r3,.L81+20
 1166 0382 1A70     	 strb r2,[r3]
 656:../SSC/Src/ecatslv.c ****         {
 1167              	 .loc 3 656 0 discriminator 3
 1168 0384 FB7D     	 ldrb r3,[r7,#23]
 1169 0386 0133     	 adds r3,r3,#1
 1170 0388 FB75     	 strb r3,[r7,#23]
 1171              	.L77:
 656:../SSC/Src/ecatslv.c ****         {
 1172              	 .loc 3 656 0 is_stmt 0 discriminator 1
 1173 038a 0B4B     	 ldr r3,.L81+24
 1174 038c 1B78     	 ldrb r3,[r3]
 1175 038e FA7D     	 ldrb r2,[r7,#23]
 1176 0390 9A42     	 cmp r2,r3
 1177 0392 EED3     	 bcc .L78
 1178              	.L76:
 660:../SSC/Src/ecatslv.c ****         }
 661:../SSC/Src/ecatslv.c ****     }
 662:../SSC/Src/ecatslv.c ****     return result;
 1179              	 .loc 3 662 0 is_stmt 1
 1180 0394 BB7D     	 ldrb r3,[r7,#22]
 1181              	.L31:
 663:../SSC/Src/ecatslv.c **** }
 1182              	 .loc 3 663 0
 1183 0396 1846     	 mov r0,r3
 1184 0398 1837     	 adds r7,r7,#24
 1185              	.LCFI47:
 1186              	 .cfi_def_cfa_offset 8
 1187 039a BD46     	 mov sp,r7
 1188              	.LCFI48:
 1189              	 .cfi_def_cfa_register 13
 1190              	 
 1191 039c 80BD     	 pop {r7,pc}
 1192              	.L82:
 1193 039e 00BF     	 .align 2
 1194              	.L81:
 1195 03a0 00000000 	 .word nPdOutputSize
 1196 03a4 00000000 	 .word nAlStatus
 1197 03a8 00000000 	 .word nEscAddrOutputData
 1198 03ac 00000000 	 .word bWdTrigger
 1199 03b0 00000000 	 .word b3BufferMode
 1200 03b4 00000000 	 .word SMActivate
 1201 03b8 00000000 	 .word nMaxSyncMan
 1202              	 .cfi_endproc
 1203              	.LFE183:
 1205              	 .section .text.StartInputHandler,"ax",%progbits
 1206              	 .align 2
 1207              	 .global StartInputHandler
 1208              	 .thumb
 1209              	 .thumb_func
 1211              	StartInputHandler:
 1212              	.LFB184:
 664:../SSC/Src/ecatslv.c **** 
 665:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 666:../SSC/Src/ecatslv.c **** /**
 667:../SSC/Src/ecatslv.c ****  \return    AL Status Code (see ecatslv.h ALSTATUSCODE_....)
 668:../SSC/Src/ecatslv.c **** 
 669:../SSC/Src/ecatslv.c ****  \brief    This function is called in case of the state transition from PREOP to SAFEOP.
 670:../SSC/Src/ecatslv.c ****  |brief  the areas of the Sync Managers will be checked for overlapping,
 671:../SSC/Src/ecatslv.c ****  \brief  the synchronization mode (Free Run, Synchron, Distributed Clocks) is selected,
 672:../SSC/Src/ecatslv.c ****  \brief  the requested cycle time will be checked, the watchdog is started
 673:../SSC/Src/ecatslv.c ****  \brief  and the AL Event Mask register will be set
 674:../SSC/Src/ecatslv.c **** 
 675:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 676:../SSC/Src/ecatslv.c **** 
 677:../SSC/Src/ecatslv.c **** UINT16 StartInputHandler(void)
 678:../SSC/Src/ecatslv.c **** {
 1213              	 .loc 3 678 0
 1214              	 .cfi_startproc
 1215              	 
 1216              	 
 1217 0000 80B5     	 push {r7,lr}
 1218              	.LCFI49:
 1219              	 .cfi_def_cfa_offset 8
 1220              	 .cfi_offset 7,-8
 1221              	 .cfi_offset 14,-4
 1222 0002 8EB0     	 sub sp,sp,#56
 1223              	.LCFI50:
 1224              	 .cfi_def_cfa_offset 64
 1225 0004 00AF     	 add r7,sp,#0
 1226              	.LCFI51:
 1227              	 .cfi_def_cfa_register 7
 679:../SSC/Src/ecatslv.c ****     TSYNCMAN ESCMEM * pSyncMan;
 680:../SSC/Src/ecatslv.c ****     UINT8        dcControl;
 681:../SSC/Src/ecatslv.c **** 
 682:../SSC/Src/ecatslv.c ****     UINT16     wdiv = 0;
 1228              	 .loc 3 682 0
 1229 0006 0023     	 movs r3,#0
 1230 0008 BB85     	 strh r3,[r7,#44]
 683:../SSC/Src/ecatslv.c ****     UINT16     wd = 0;
 1231              	 .loc 3 683 0
 1232 000a 0023     	 movs r3,#0
 1233 000c 7B85     	 strh r3,[r7,#42]
 684:../SSC/Src/ecatslv.c ****     UINT32     cycleTimeSync0 = 0; /* Sync0 cycle time */
 1234              	 .loc 3 684 0
 1235 000e 0023     	 movs r3,#0
 1236 0010 7B62     	 str r3,[r7,#36]
 685:../SSC/Src/ecatslv.c ****     UINT32     shiftTimeSync1 = 0; /* Delay between the Sync0 and Sycn1 signal. A new Sync1 cycle s
 1237              	 .loc 3 685 0
 1238 0012 0023     	 movs r3,#0
 1239 0014 3B62     	 str r3,[r7,#32]
 686:../SSC/Src/ecatslv.c ****     BOOL bSubordinatedCycles = FALSE;
 1240              	 .loc 3 686 0
 1241 0016 0023     	 movs r3,#0
 1242 0018 87F83730 	 strb r3,[r7,#55]
 687:../SSC/Src/ecatslv.c **** 
 688:../SSC/Src/ecatslv.c ****     UINT16    nPdInputBuffer = 3;
 1243              	 .loc 3 688 0
 1244 001c 0323     	 movs r3,#3
 1245 001e BB86     	 strh r3,[r7,#52]
 689:../SSC/Src/ecatslv.c **** 
 690:../SSC/Src/ecatslv.c ****     UINT16    nPdOutputBuffer = 3;
 1246              	 .loc 3 690 0
 1247 0020 0323     	 movs r3,#3
 1248 0022 7B86     	 strh r3,[r7,#50]
 691:../SSC/Src/ecatslv.c **** 
 692:../SSC/Src/ecatslv.c ****     UINT16 SyncType0x1C32 = 0; /* Helper variable for sync type for SM2 (required if no CoE is supp
 1249              	 .loc 3 692 0
 1250 0024 0023     	 movs r3,#0
 1251 0026 3B86     	 strh r3,[r7,#48]
 693:../SSC/Src/ecatslv.c ****     UINT16 SyncType0x1C33 = 0; /* Helper variable for sync type for SM3 (required if no CoE is supp
 1252              	 .loc 3 693 0
 1253 0028 0023     	 movs r3,#0
 1254 002a FB85     	 strh r3,[r7,#46]
 694:../SSC/Src/ecatslv.c **** 
 695:../SSC/Src/ecatslv.c ****     UINT16 u16MinSuppSyncType = 0xFFFF;  /* Minimum supported Sync Types */
 1255              	 .loc 3 695 0
 1256 002c 4FF6FF73 	 movw r3,#65535
 1257 0030 FB83     	 strh r3,[r7,#30]
 696:../SSC/Src/ecatslv.c **** 
 697:../SSC/Src/ecatslv.c ****     u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
 1258              	 .loc 3 697 0
 1259 0032 9E4B     	 ldr r3,.L157
 1260 0034 9A89     	 ldrh r2,[r3,#12]
 1261 0036 FB8B     	 ldrh r3,[r7,#30]
 1262 0038 1340     	 ands r3,r3,r2
 1263 003a FB83     	 strh r3,[r7,#30]
 698:../SSC/Src/ecatslv.c ****     u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
 1264              	 .loc 3 698 0
 1265 003c 9C4B     	 ldr r3,.L157+4
 1266 003e 9A89     	 ldrh r2,[r3,#12]
 1267 0040 FB8B     	 ldrh r3,[r7,#30]
 1268 0042 1340     	 ands r3,r3,r2
 1269 0044 FB83     	 strh r3,[r7,#30]
 699:../SSC/Src/ecatslv.c **** 
 700:../SSC/Src/ecatslv.c ****     u16ALEventMask = 0;
 1270              	 .loc 3 700 0
 1271 0046 9B4B     	 ldr r3,.L157+8
 1272 0048 0022     	 movs r2,#0
 1273 004a 1A80     	 strh r2,[r3]
 701:../SSC/Src/ecatslv.c **** 
 702:../SSC/Src/ecatslv.c **** 
 703:../SSC/Src/ecatslv.c ****     /* 
 704:../SSC/Src/ecatslv.c ****         --- Check if SyncManager areas overlapping --- 
 705:../SSC/Src/ecatslv.c ****     */
 706:../SSC/Src/ecatslv.c ****     bEcatFirstOutputsReceived = FALSE;
 1274              	 .loc 3 706 0
 1275 004c 9A4B     	 ldr r3,.L157+12
 1276 004e 0022     	 movs r2,#0
 1277 0050 1A70     	 strb r2,[r3]
 707:../SSC/Src/ecatslv.c **** 
 708:../SSC/Src/ecatslv.c ****     /* get a pointer to the Sync Manager Channel 2 (Outputs) */
 709:../SSC/Src/ecatslv.c ****     pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
 1278              	 .loc 3 709 0
 1279 0052 0220     	 movs r0,#2
 1280 0054 FFF7FEFF 	 bl GetSyncMan
 1281 0058 B861     	 str r0,[r7,#24]
 710:../SSC/Src/ecatslv.c ****     /* store the address of the Sync Manager Channel 2 (Outputs) */
 711:../SSC/Src/ecatslv.c ****     nEscAddrOutputData = pSyncMan->PhysicalStartAddress;
 1282              	 .loc 3 711 0
 1283 005a BB69     	 ldr r3,[r7,#24]
 1284 005c 1B88     	 ldrh r3,[r3]
 1285 005e 9AB2     	 uxth r2,r3
 1286 0060 964B     	 ldr r3,.L157+16
 1287 0062 1A80     	 strh r2,[r3]
 712:../SSC/Src/ecatslv.c ****     /* get the number of output buffer used for calculating the address areas */
 713:../SSC/Src/ecatslv.c ****     if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
 1288              	 .loc 3 713 0
 1289 0064 BB69     	 ldr r3,[r7,#24]
 1290 0066 1B79     	 ldrb r3,[r3,#4]
 1291 0068 03F00203 	 and r3,r3,#2
 1292 006c 002B     	 cmp r3,#0
 1293 006e 01D0     	 beq .L84
 714:../SSC/Src/ecatslv.c ****     {
 715:../SSC/Src/ecatslv.c ****        nPdOutputBuffer = 1;
 1294              	 .loc 3 715 0
 1295 0070 0123     	 movs r3,#1
 1296 0072 7B86     	 strh r3,[r7,#50]
 1297              	.L84:
 716:../SSC/Src/ecatslv.c ****     }
 717:../SSC/Src/ecatslv.c **** 
 718:../SSC/Src/ecatslv.c **** 
 719:../SSC/Src/ecatslv.c ****     /* get a pointer to the Sync Manager Channel 3 (Inputs) */
 720:../SSC/Src/ecatslv.c ****     pSyncMan = GetSyncMan(PROCESS_DATA_IN);
 1298              	 .loc 3 720 0
 1299 0074 0320     	 movs r0,#3
 1300 0076 FFF7FEFF 	 bl GetSyncMan
 1301 007a B861     	 str r0,[r7,#24]
 721:../SSC/Src/ecatslv.c ****     /* store the address of the Sync Manager Channel 3 (Inputs)*/
 722:../SSC/Src/ecatslv.c ****     nEscAddrInputData = pSyncMan->PhysicalStartAddress;
 1302              	 .loc 3 722 0
 1303 007c BB69     	 ldr r3,[r7,#24]
 1304 007e 1B88     	 ldrh r3,[r3]
 1305 0080 9AB2     	 uxth r2,r3
 1306 0082 8F4B     	 ldr r3,.L157+20
 1307 0084 1A80     	 strh r2,[r3]
 723:../SSC/Src/ecatslv.c **** 
 724:../SSC/Src/ecatslv.c **** 
 725:../SSC/Src/ecatslv.c ****     /* get the number of input buffer used for calculating the address areas */
 726:../SSC/Src/ecatslv.c ****     if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
 1308              	 .loc 3 726 0
 1309 0086 BB69     	 ldr r3,[r7,#24]
 1310 0088 1B79     	 ldrb r3,[r3,#4]
 1311 008a 03F00203 	 and r3,r3,#2
 1312 008e 002B     	 cmp r3,#0
 1313 0090 01D0     	 beq .L85
 727:../SSC/Src/ecatslv.c ****     {
 728:../SSC/Src/ecatslv.c ****         nPdInputBuffer = 1;
 1314              	 .loc 3 728 0
 1315 0092 0123     	 movs r3,#1
 1316 0094 BB86     	 strh r3,[r7,#52]
 1317              	.L85:
 729:../SSC/Src/ecatslv.c ****     }
 730:../SSC/Src/ecatslv.c ****     /* it has be checked if the Sync Manager memory areas for Inputs and Outputs will not overlap
 731:../SSC/Src/ecatslv.c ****        the Sync Manager memory areas for the Mailbox */
 732:../SSC/Src/ecatslv.c **** 
 733:../SSC/Src/ecatslv.c ****     if (((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrSendMbx && (nEscAddrInputD
 1318              	 .loc 3 733 0
 1319 0096 8A4B     	 ldr r3,.L157+20
 1320 0098 1B88     	 ldrh r3,[r3]
 1321 009a 1A46     	 mov r2,r3
 1322 009c 894B     	 ldr r3,.L157+24
 1323 009e 1B88     	 ldrh r3,[r3]
 1324 00a0 1946     	 mov r1,r3
 1325 00a2 BB8E     	 ldrh r3,[r7,#52]
 1326 00a4 03FB01F3 	 mul r3,r3,r1
 1327 00a8 1344     	 add r3,r3,r2
 1328 00aa 874A     	 ldr r2,.L157+28
 1329 00ac 1288     	 ldrh r2,[r2]
 1330 00ae 9342     	 cmp r3,r2
 1331 00b0 0ADD     	 ble .L86
 1332              	 .loc 3 733 0 is_stmt 0 discriminator 1
 1333 00b2 834B     	 ldr r3,.L157+20
 1334 00b4 1B88     	 ldrh r3,[r3]
 1335 00b6 1A46     	 mov r2,r3
 1336 00b8 834B     	 ldr r3,.L157+28
 1337 00ba 1B88     	 ldrh r3,[r3]
 1338 00bc 1946     	 mov r1,r3
 1339 00be 834B     	 ldr r3,.L157+32
 1340 00c0 1B88     	 ldrh r3,[r3]
 1341 00c2 0B44     	 add r3,r3,r1
 1342 00c4 9A42     	 cmp r2,r3
 1343 00c6 18DB     	 blt .L87
 1344              	.L86:
 734:../SSC/Src/ecatslv.c ****        || ((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrReceiveMbx && (nEscAddrI
 1345              	 .loc 3 734 0 is_stmt 1
 1346 00c8 7D4B     	 ldr r3,.L157+20
 1347 00ca 1B88     	 ldrh r3,[r3]
 1348 00cc 1A46     	 mov r2,r3
 1349 00ce 7D4B     	 ldr r3,.L157+24
 1350 00d0 1B88     	 ldrh r3,[r3]
 1351 00d2 1946     	 mov r1,r3
 1352 00d4 BB8E     	 ldrh r3,[r7,#52]
 1353 00d6 03FB01F3 	 mul r3,r3,r1
 1354 00da 1344     	 add r3,r3,r2
 1355 00dc 7C4A     	 ldr r2,.L157+36
 1356 00de 1288     	 ldrh r2,[r2]
 1357 00e0 9342     	 cmp r3,r2
 1358 00e2 0CDD     	 ble .L88
 1359              	 .loc 3 734 0 is_stmt 0 discriminator 1
 1360 00e4 764B     	 ldr r3,.L157+20
 1361 00e6 1B88     	 ldrh r3,[r3]
 1362 00e8 1A46     	 mov r2,r3
 1363 00ea 794B     	 ldr r3,.L157+36
 1364 00ec 1B88     	 ldrh r3,[r3]
 1365 00ee 1946     	 mov r1,r3
 1366 00f0 784B     	 ldr r3,.L157+40
 1367 00f2 1B88     	 ldrh r3,[r3]
 1368 00f4 0B44     	 add r3,r3,r1
 1369 00f6 9A42     	 cmp r2,r3
 1370 00f8 01DA     	 bge .L88
 1371              	.L87:
 735:../SSC/Src/ecatslv.c ****         )
 736:../SSC/Src/ecatslv.c ****     {
 737:../SSC/Src/ecatslv.c ****         return ALSTATUSCODE_INVALIDSMINCFG;
 1372              	 .loc 3 737 0 is_stmt 1
 1373 00fa 1E23     	 movs r3,#30
 1374 00fc 25E3     	 b .L89
 1375              	.L88:
 738:../SSC/Src/ecatslv.c ****     }
 739:../SSC/Src/ecatslv.c **** 
 740:../SSC/Src/ecatslv.c ****     if (
 741:../SSC/Src/ecatslv.c ****         ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOut
 1376              	 .loc 3 741 0
 1377 00fe 6F4B     	 ldr r3,.L157+16
 1378 0100 1B88     	 ldrh r3,[r3]
 1379 0102 1A46     	 mov r2,r3
 1380 0104 744B     	 ldr r3,.L157+44
 1381 0106 1B88     	 ldrh r3,[r3]
 1382 0108 1946     	 mov r1,r3
 1383 010a 7B8E     	 ldrh r3,[r7,#50]
 1384 010c 03FB01F3 	 mul r3,r3,r1
 1385 0110 1344     	 add r3,r3,r2
 1386 0112 6D4A     	 ldr r2,.L157+28
 1387 0114 1288     	 ldrh r2,[r2]
 740:../SSC/Src/ecatslv.c ****         ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOut
 1388              	 .loc 3 740 0
 1389 0116 9342     	 cmp r3,r2
 1390 0118 0ADD     	 ble .L90
 1391              	 .loc 3 741 0
 1392 011a 684B     	 ldr r3,.L157+16
 1393 011c 1B88     	 ldrh r3,[r3]
 1394 011e 1A46     	 mov r2,r3
 1395 0120 694B     	 ldr r3,.L157+28
 1396 0122 1B88     	 ldrh r3,[r3]
 1397 0124 1946     	 mov r1,r3
 1398 0126 694B     	 ldr r3,.L157+32
 1399 0128 1B88     	 ldrh r3,[r3]
 1400 012a 0B44     	 add r3,r3,r1
 1401 012c 9A42     	 cmp r2,r3
 1402 012e 31DB     	 blt .L91
 1403              	.L90:
 742:../SSC/Src/ecatslv.c ****         ||((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrReceiveMbx && (nEscAd
 1404              	 .loc 3 742 0
 1405 0130 624B     	 ldr r3,.L157+16
 1406 0132 1B88     	 ldrh r3,[r3]
 1407 0134 1A46     	 mov r2,r3
 1408 0136 684B     	 ldr r3,.L157+44
 1409 0138 1B88     	 ldrh r3,[r3]
 1410 013a 1946     	 mov r1,r3
 1411 013c 7B8E     	 ldrh r3,[r7,#50]
 1412 013e 03FB01F3 	 mul r3,r3,r1
 1413 0142 1344     	 add r3,r3,r2
 1414 0144 624A     	 ldr r2,.L157+36
 1415 0146 1288     	 ldrh r2,[r2]
 1416 0148 9342     	 cmp r3,r2
 1417 014a 0ADD     	 ble .L92
 1418              	 .loc 3 742 0 is_stmt 0 discriminator 1
 1419 014c 5B4B     	 ldr r3,.L157+16
 1420 014e 1B88     	 ldrh r3,[r3]
 1421 0150 1A46     	 mov r2,r3
 1422 0152 5F4B     	 ldr r3,.L157+36
 1423 0154 1B88     	 ldrh r3,[r3]
 1424 0156 1946     	 mov r1,r3
 1425 0158 5E4B     	 ldr r3,.L157+40
 1426 015a 1B88     	 ldrh r3,[r3]
 1427 015c 0B44     	 add r3,r3,r1
 1428 015e 9A42     	 cmp r2,r3
 1429 0160 18DB     	 blt .L91
 1430              	.L92:
 743:../SSC/Src/ecatslv.c ****         ||
 744:../SSC/Src/ecatslv.c ****         ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > nEscAddrInputData && (nEscAddrOut
 1431              	 .loc 3 744 0 is_stmt 1
 1432 0162 564B     	 ldr r3,.L157+16
 1433 0164 1B88     	 ldrh r3,[r3]
 1434 0166 1A46     	 mov r2,r3
 1435 0168 5B4B     	 ldr r3,.L157+44
 1436 016a 1B88     	 ldrh r3,[r3]
 1437 016c 1946     	 mov r1,r3
 1438 016e 7B8E     	 ldrh r3,[r7,#50]
 1439 0170 03FB01F3 	 mul r3,r3,r1
 1440 0174 1344     	 add r3,r3,r2
 1441 0176 524A     	 ldr r2,.L157+20
 1442 0178 1288     	 ldrh r2,[r2]
 743:../SSC/Src/ecatslv.c ****         ||
 1443              	 .loc 3 743 0
 1444 017a 9342     	 cmp r3,r2
 1445 017c 0CDD     	 ble .L93
 1446              	 .loc 3 744 0
 1447 017e 4F4B     	 ldr r3,.L157+16
 1448 0180 1B88     	 ldrh r3,[r3]
 1449 0182 1A46     	 mov r2,r3
 1450 0184 4E4B     	 ldr r3,.L157+20
 1451 0186 1B88     	 ldrh r3,[r3]
 1452 0188 1946     	 mov r1,r3
 1453 018a 4E4B     	 ldr r3,.L157+24
 1454 018c 1B88     	 ldrh r3,[r3]
 1455 018e 0B44     	 add r3,r3,r1
 1456 0190 9A42     	 cmp r2,r3
 1457 0192 01DA     	 bge .L93
 1458              	.L91:
 745:../SSC/Src/ecatslv.c ****         )
 746:../SSC/Src/ecatslv.c ****     {
 747:../SSC/Src/ecatslv.c **** 
 748:../SSC/Src/ecatslv.c ****         /* Sync Manager Channel 2 memory area (Outputs) overlaps the Sync Manager memory areas for 
 749:../SSC/Src/ecatslv.c ****            or the Sync Manager Channel 3 memory area (Inputs) */
 750:../SSC/Src/ecatslv.c ****         return ALSTATUSCODE_INVALIDSMOUTCFG;
 1459              	 .loc 3 750 0
 1460 0194 1D23     	 movs r3,#29
 1461 0196 D8E2     	 b .L89
 1462              	.L93:
 751:../SSC/Src/ecatslv.c ****     }
 752:../SSC/Src/ecatslv.c **** 
 753:../SSC/Src/ecatslv.c ****     /* 
 754:../SSC/Src/ecatslv.c ****         --- Check configured synchronisation ---
 755:../SSC/Src/ecatslv.c ****     */
 756:../SSC/Src/ecatslv.c **** 
 757:../SSC/Src/ecatslv.c ****     /* Get the DC Control/Activation register value*/
 758:../SSC/Src/ecatslv.c ****     /*Read register 0x981 (corresponding masks are adapted)*/
 759:../SSC/Src/ecatslv.c ****     HW_EscReadByte(dcControl, ESC_DC_SYNC_ACTIVATION_OFFSET);
 1463              	 .loc 3 759 0
 1464 0198 504B     	 ldr r3,.L157+48
 1465 019a 1B78     	 ldrb r3,[r3]
 1466 019c FB75     	 strb r3,[r7,#23]
 760:../SSC/Src/ecatslv.c **** 
 761:../SSC/Src/ecatslv.c ****     // Cycle time for Sync0
 762:../SSC/Src/ecatslv.c ****         HW_EscReadDWord(cycleTimeSync0, ESC_DC_SYNC0_CYCLETIME_OFFSET);
 1467              	 .loc 3 762 0
 1468 019e 504B     	 ldr r3,.L157+52
 1469 01a0 1B68     	 ldr r3,[r3]
 1470 01a2 7B62     	 str r3,[r7,#36]
 763:../SSC/Src/ecatslv.c ****         cycleTimeSync0 = SWAPDWORD(cycleTimeSync0);
 764:../SSC/Src/ecatslv.c **** 
 765:../SSC/Src/ecatslv.c ****     // Cycle time for Sync1
 766:../SSC/Src/ecatslv.c ****         HW_EscReadDWord(shiftTimeSync1, ESC_DC_SYNC1_CYCLETIME_OFFSET);
 1471              	 .loc 3 766 0
 1472 01a4 4F4B     	 ldr r3,.L157+56
 1473 01a6 1B68     	 ldr r3,[r3]
 1474 01a8 3B62     	 str r3,[r7,#32]
 767:../SSC/Src/ecatslv.c ****         shiftTimeSync1 = SWAPDWORD(shiftTimeSync1);
 768:../SSC/Src/ecatslv.c **** 
 769:../SSC/Src/ecatslv.c **** 
 770:../SSC/Src/ecatslv.c ****     SyncType0x1C32 = sSyncManOutPar.u16SyncType;
 1475              	 .loc 3 770 0
 1476 01aa 404B     	 ldr r3,.L157
 1477 01ac 5B88     	 ldrh r3,[r3,#2]
 1478 01ae 3B86     	 strh r3,[r7,#48]
 771:../SSC/Src/ecatslv.c ****     SyncType0x1C33 = sSyncManInPar.u16SyncType;
 1479              	 .loc 3 771 0
 1480 01b0 3F4B     	 ldr r3,.L157+4
 1481 01b2 5B88     	 ldrh r3,[r3,#2]
 1482 01b4 FB85     	 strh r3,[r7,#46]
 772:../SSC/Src/ecatslv.c **** 
 773:../SSC/Src/ecatslv.c **** 
 774:../SSC/Src/ecatslv.c **** 
 775:../SSC/Src/ecatslv.c ****     /* check general DC register plausibility and if configuration is supported
 776:../SSC/Src/ecatslv.c ****        - 0x981 DC Active
 777:../SSC/Src/ecatslv.c ****        - 0x9A0:0x9A3 Sync0 Cycle
 778:../SSC/Src/ecatslv.c ****        - 0x9A4:0x9A7 Sync1 Cycle
 779:../SSC/Src/ecatslv.c ****     */
 780:../SSC/Src/ecatslv.c ****     if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) != 0)
 1483              	 .loc 3 780 0
 1484 01b6 FB7D     	 ldrb r3,[r7,#23]
 1485 01b8 03F00903 	 and r3,r3,#9
 1486 01bc 002B     	 cmp r3,#0
 1487 01be 5CD0     	 beq .L94
 781:../SSC/Src/ecatslv.c ****     {
 782:../SSC/Src/ecatslv.c ****         /* DC unit is active at least one Sync signal shall be generated */
 783:../SSC/Src/ecatslv.c ****         if((dcControl & (ESC_DC_SYNC0_ACTIVE_MASK | ESC_DC_SYNC1_ACTIVE_MASK)) == 0)
 1488              	 .loc 3 783 0
 1489 01c0 FB7D     	 ldrb r3,[r7,#23]
 1490 01c2 03F00603 	 and r3,r3,#6
 1491 01c6 002B     	 cmp r3,#0
 1492 01c8 01D1     	 bne .L95
 784:../SSC/Src/ecatslv.c ****         {
 785:../SSC/Src/ecatslv.c ****             return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1493              	 .loc 3 785 0
 1494 01ca 3023     	 movs r3,#48
 1495 01cc BDE2     	 b .L89
 1496              	.L95:
 786:../SSC/Src/ecatslv.c ****         }
 787:../SSC/Src/ecatslv.c **** 
 788:../SSC/Src/ecatslv.c ****         /* If Sync1 shall only be active if also Sync0 will be generated*/
 789:../SSC/Src/ecatslv.c ****         if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) == 0)
 1497              	 .loc 3 789 0
 1498 01ce FB7D     	 ldrb r3,[r7,#23]
 1499 01d0 03F00203 	 and r3,r3,#2
 1500 01d4 002B     	 cmp r3,#0
 1501 01d6 06D1     	 bne .L96
 790:../SSC/Src/ecatslv.c ****             && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
 1502              	 .loc 3 790 0
 1503 01d8 FB7D     	 ldrb r3,[r7,#23]
 1504 01da 03F00403 	 and r3,r3,#4
 1505 01de 002B     	 cmp r3,#0
 1506 01e0 01D0     	 beq .L96
 791:../SSC/Src/ecatslv.c ****         {
 792:../SSC/Src/ecatslv.c ****             return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1507              	 .loc 3 792 0
 1508 01e2 3023     	 movs r3,#48
 1509 01e4 B1E2     	 b .L89
 1510              	.L96:
 793:../SSC/Src/ecatslv.c ****         }
 794:../SSC/Src/ecatslv.c **** 
 795:../SSC/Src/ecatslv.c ****         if(u16MinSuppSyncType != 0)
 1511              	 .loc 3 795 0
 1512 01e6 FB8B     	 ldrh r3,[r7,#30]
 1513 01e8 002B     	 cmp r3,#0
 1514 01ea 15D0     	 beq .L97
 796:../SSC/Src/ecatslv.c ****         {
 797:../SSC/Src/ecatslv.c ****             if((((u16MinSuppSyncType & SYNCTYPE_DCSYNC0SUPP) == 0) && ((dcControl & ESC_DC_SYNC0_AC
 1515              	 .loc 3 797 0
 1516 01ec FB8B     	 ldrh r3,[r7,#30]
 1517 01ee 03F00403 	 and r3,r3,#4
 1518 01f2 002B     	 cmp r3,#0
 1519 01f4 04D1     	 bne .L98
 1520              	 .loc 3 797 0 is_stmt 0 discriminator 1
 1521 01f6 FB7D     	 ldrb r3,[r7,#23]
 1522 01f8 03F00203 	 and r3,r3,#2
 1523 01fc 002B     	 cmp r3,#0
 1524 01fe 09D1     	 bne .L99
 1525              	.L98:
 798:../SSC/Src/ecatslv.c ****                 ||(((u16MinSuppSyncType & SYNCTYPE_DCSYNC1SUPP) == 0) && ((dcControl & ESC_DC_SYNC1
 1526              	 .loc 3 798 0 is_stmt 1
 1527 0200 FB8B     	 ldrh r3,[r7,#30]
 1528 0202 03F00803 	 and r3,r3,#8
 1529 0206 002B     	 cmp r3,#0
 1530 0208 06D1     	 bne .L97
 1531              	 .loc 3 798 0 is_stmt 0 discriminator 1
 1532 020a FB7D     	 ldrb r3,[r7,#23]
 1533 020c 03F00403 	 and r3,r3,#4
 1534 0210 002B     	 cmp r3,#0
 1535 0212 01D0     	 beq .L97
 1536              	.L99:
 799:../SSC/Src/ecatslv.c ****             {
 800:../SSC/Src/ecatslv.c ****                 /* Sync0 is not supported but will be generated*/
 801:../SSC/Src/ecatslv.c ****                 return ALSTATUSCODE_DCINVALIDSYNCCFG;                   
 1537              	 .loc 3 801 0 is_stmt 1
 1538 0214 3023     	 movs r3,#48
 1539 0216 98E2     	 b .L89
 1540              	.L97:
 1541              	.LBB2:
 802:../SSC/Src/ecatslv.c ****     }
 803:../SSC/Src/ecatslv.c ****         }
 804:../SSC/Src/ecatslv.c **** 
 805:../SSC/Src/ecatslv.c ****         {
 806:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ECAT1*/
 807:../SSC/Src/ecatslv.c ****             UINT32 curMinCycleTime = MIN_PD_CYCLE_TIME;
 1542              	 .loc 3 807 0
 1543 0218 334B     	 ldr r3,.L157+60
 1544 021a 3B61     	 str r3,[r7,#16]
 808:../SSC/Src/ecatslv.c ****             curMinCycleTime = sSyncManOutPar.u32MinCycleTime;
 1545              	 .loc 3 808 0
 1546 021c 234B     	 ldr r3,.L157
 1547 021e 1B69     	 ldr r3,[r3,#16]
 1548 0220 3B61     	 str r3,[r7,#16]
 809:../SSC/Src/ecatslv.c **** 
 810:../SSC/Src/ecatslv.c ****             /*Check if Sync0 cycle time is supported*/
 811:../SSC/Src/ecatslv.c ****             if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD
 1549              	 .loc 3 811 0
 1550 0222 7B6A     	 ldr r3,[r7,#36]
 1551 0224 002B     	 cmp r3,#0
 1552 0226 09D0     	 beq .L100
 1553              	 .loc 3 811 0 is_stmt 0 discriminator 1
 1554 0228 7A6A     	 ldr r2,[r7,#36]
 1555 022a 3B69     	 ldr r3,[r7,#16]
 1556 022c 9A42     	 cmp r2,r3
 1557 022e 03D3     	 bcc .L101
 1558              	 .loc 3 811 0 discriminator 2
 1559 0230 7B6A     	 ldr r3,[r7,#36]
 1560 0232 2E4A     	 ldr r2,.L157+64
 1561 0234 9342     	 cmp r3,r2
 1562 0236 01D9     	 bls .L100
 1563              	.L101:
 812:../SSC/Src/ecatslv.c ****             {
 813:../SSC/Src/ecatslv.c ****                     return ALSTATUSCODE_DCSYNC0CYCLETIME;
 1564              	 .loc 3 813 0 is_stmt 1
 1565 0238 3623     	 movs r3,#54
 1566 023a 86E2     	 b .L89
 1567              	.L100:
 1568              	.LBE2:
 814:../SSC/Src/ecatslv.c ****             }
 815:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT1*/
 816:../SSC/Src/ecatslv.c ****         }
 817:../SSC/Src/ecatslv.c **** 
 818:../SSC/Src/ecatslv.c **** 
 819:../SSC/Src/ecatslv.c ****         /* Check if Subordinated cycles are configured */
 820:../SSC/Src/ecatslv.c ****         if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK)
 1569              	 .loc 3 820 0
 1570 023c FB7D     	 ldrb r3,[r7,#23]
 1571 023e 03F00203 	 and r3,r3,#2
 1572 0242 002B     	 cmp r3,#0
 1573 0244 0ED0     	 beq .L102
 1574              	 .loc 3 820 0 is_stmt 0 discriminator 1
 1575 0246 FB7D     	 ldrb r3,[r7,#23]
 1576 0248 03F00403 	 and r3,r3,#4
 1577 024c 002B     	 cmp r3,#0
 1578 024e 09D0     	 beq .L102
 821:../SSC/Src/ecatslv.c ****         {
 822:../SSC/Src/ecatslv.c ****             /* For Subordinated cycles both Sync signals shall be active and Sync0 is not configure
 823:../SSC/Src/ecatslv.c ****             if((shiftTimeSync1 > 0) && (shiftTimeSync1 >= cycleTimeSync0))
 1579              	 .loc 3 823 0 is_stmt 1
 1580 0250 3B6A     	 ldr r3,[r7,#32]
 1581 0252 002B     	 cmp r3,#0
 1582 0254 06D0     	 beq .L102
 1583              	 .loc 3 823 0 is_stmt 0 discriminator 1
 1584 0256 3A6A     	 ldr r2,[r7,#32]
 1585 0258 7B6A     	 ldr r3,[r7,#36]
 1586 025a 9A42     	 cmp r2,r3
 1587 025c 02D3     	 bcc .L102
 824:../SSC/Src/ecatslv.c ****             {
 825:../SSC/Src/ecatslv.c ****                 bSubordinatedCycles = TRUE;
 1588              	 .loc 3 825 0 is_stmt 1
 1589 025e 0123     	 movs r3,#1
 1590 0260 87F83730 	 strb r3,[r7,#55]
 1591              	.L102:
 826:../SSC/Src/ecatslv.c ****             }
 827:../SSC/Src/ecatslv.c ****         }
 828:../SSC/Src/ecatslv.c **** 
 829:../SSC/Src/ecatslv.c ****         /* Dump an error if subordinated cycles are configured but not supported */
 830:../SSC/Src/ecatslv.c ****         if(bSubordinatedCycles && ((u16MinSuppSyncType & SYNCTYPE_SUBCYCLESUPP) == 0))
 1592              	 .loc 3 830 0
 1593 0264 97F83730 	 ldrb r3,[r7,#55]
 1594 0268 002B     	 cmp r3,#0
 1595 026a 06D0     	 beq .L94
 1596              	 .loc 3 830 0 is_stmt 0 discriminator 1
 1597 026c FB8B     	 ldrh r3,[r7,#30]
 1598 026e 03F01003 	 and r3,r3,#16
 1599 0272 002B     	 cmp r3,#0
 1600 0274 01D1     	 bne .L94
 831:../SSC/Src/ecatslv.c ****         {
 832:../SSC/Src/ecatslv.c ****              return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1601              	 .loc 3 832 0 is_stmt 1
 1602 0276 3023     	 movs r3,#48
 1603 0278 67E2     	 b .L89
 1604              	.L94:
 833:../SSC/Src/ecatslv.c ****         }
 834:../SSC/Src/ecatslv.c ****     }
 835:../SSC/Src/ecatslv.c **** 
 836:../SSC/Src/ecatslv.c **** 
 837:../SSC/Src/ecatslv.c ****     /*
 838:../SSC/Src/ecatslv.c ****         Check if the user configured Sync Type matches the DC register values (if the Sync Type is 
 839:../SSC/Src/ecatslv.c ****     */
 840:../SSC/Src/ecatslv.c ****     if(bSyncSetByUser)
 1605              	 .loc 3 840 0
 1606 027a 1D4B     	 ldr r3,.L157+68
 1607 027c 1B78     	 ldrb r3,[r3]
 1608 027e 002B     	 cmp r3,#0
 1609 0280 52D0     	 beq .L103
 841:../SSC/Src/ecatslv.c ****     {
 842:../SSC/Src/ecatslv.c ****         if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 0)
 1610              	 .loc 3 842 0
 1611 0282 FB7D     	 ldrb r3,[r7,#23]
 1612 0284 03F00903 	 and r3,r3,#9
 1613 0288 002B     	 cmp r3,#0
 1614 028a 33D1     	 bne .L104
 843:../SSC/Src/ecatslv.c ****         {
 844:../SSC/Src/ecatslv.c ****             /* DC out unit not enabled => no DC mode shall be set */
 845:../SSC/Src/ecatslv.c ****             if((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
 1615              	 .loc 3 845 0
 1616 028c 3B8E     	 ldrh r3,[r7,#48]
 1617 028e 022B     	 cmp r3,#2
 1618 0290 09D0     	 beq .L105
 1619              	 .loc 3 845 0 is_stmt 0 discriminator 1
 1620 0292 3B8E     	 ldrh r3,[r7,#48]
 1621 0294 032B     	 cmp r3,#3
 1622 0296 06D0     	 beq .L105
 846:../SSC/Src/ecatslv.c ****                 ||(SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))
 1623              	 .loc 3 846 0 is_stmt 1
 1624 0298 FB8D     	 ldrh r3,[r7,#46]
 1625 029a 022B     	 cmp r3,#2
 1626 029c 03D0     	 beq .L105
 1627              	 .loc 3 846 0 is_stmt 0 discriminator 1
 1628 029e FB8D     	 ldrh r3,[r7,#46]
 1629 02a0 032B     	 cmp r3,#3
 1630 02a2 40F08580 	 bne .L106
 1631              	.L105:
 847:../SSC/Src/ecatslv.c ****             {
 848:../SSC/Src/ecatslv.c ****                 return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1632              	 .loc 3 848 0 is_stmt 1
 1633 02a6 3023     	 movs r3,#48
 1634 02a8 4FE2     	 b .L89
 1635              	.L158:
 1636 02aa 00BF     	 .align 2
 1637              	.L157:
 1638 02ac 00000000 	 .word sSyncManOutPar
 1639 02b0 00000000 	 .word sSyncManInPar
 1640 02b4 00000000 	 .word u16ALEventMask
 1641 02b8 00000000 	 .word bEcatFirstOutputsReceived
 1642 02bc 00000000 	 .word nEscAddrOutputData
 1643 02c0 00000000 	 .word nEscAddrInputData
 1644 02c4 00000000 	 .word nPdInputSize
 1645 02c8 00000000 	 .word u16EscAddrSendMbx
 1646 02cc 00000000 	 .word u16SendMbxSize
 1647 02d0 00000000 	 .word u16EscAddrReceiveMbx
 1648 02d4 00000000 	 .word u16ReceiveMbxSize
 1649 02d8 00000000 	 .word nPdOutputSize
 1650 02dc 81090154 	 .word 1409354113
 1651 02e0 A0090154 	 .word 1409354144
 1652 02e4 A4090154 	 .word 1409354148
 1653 02e8 48E80100 	 .word 125000
 1654 02ec 000050C3 	 .word -1018167296
 1655 02f0 00000000 	 .word bSyncSetByUser
 1656              	.L104:
 849:../SSC/Src/ecatslv.c ****             }
 850:../SSC/Src/ecatslv.c ****         } //if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 
 851:../SSC/Src/ecatslv.c ****     else
 852:../SSC/Src/ecatslv.c ****     {
 853:../SSC/Src/ecatslv.c ****             if((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) == 0)
 1657              	 .loc 3 853 0
 1658 02f4 FB7D     	 ldrb r3,[r7,#23]
 1659 02f6 03F00403 	 and r3,r3,#4
 1660 02fa 002B     	 cmp r3,#0
 1661 02fc 07D1     	 bne .L107
 854:../SSC/Src/ecatslv.c ****             {
 855:../SSC/Src/ecatslv.c ****                 /* No Sync 1 is generated => No Sync1 Sync Type shall configured*/
 856:../SSC/Src/ecatslv.c ****                 if((SyncType0x1C32 == (UINT16)SYNCTYPE_DCSYNC1)
 1662              	 .loc 3 856 0
 1663 02fe 3B8E     	 ldrh r3,[r7,#48]
 1664 0300 032B     	 cmp r3,#3
 1665 0302 02D0     	 beq .L108
 857:../SSC/Src/ecatslv.c ****                     ||(SyncType0x1C33 == (UINT16)SYNCTYPE_DCSYNC1))
 1666              	 .loc 3 857 0
 1667 0304 FB8D     	 ldrh r3,[r7,#46]
 1668 0306 032B     	 cmp r3,#3
 1669 0308 01D1     	 bne .L107
 1670              	.L108:
 858:../SSC/Src/ecatslv.c ****                 {
 859:../SSC/Src/ecatslv.c ****                     return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1671              	 .loc 3 859 0
 1672 030a 3023     	 movs r3,#48
 1673 030c 1DE2     	 b .L89
 1674              	.L107:
 860:../SSC/Src/ecatslv.c ****                 }
 861:../SSC/Src/ecatslv.c ****             } //if((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) == 0)
 862:../SSC/Src/ecatslv.c **** 
 863:../SSC/Src/ecatslv.c ****             if((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) == 0)
 1675              	 .loc 3 863 0
 1676 030e FB7D     	 ldrb r3,[r7,#23]
 1677 0310 03F00203 	 and r3,r3,#2
 1678 0314 002B     	 cmp r3,#0
 1679 0316 4BD1     	 bne .L106
 864:../SSC/Src/ecatslv.c ****             {
 865:../SSC/Src/ecatslv.c ****                 /* No Sync 0 is generated => No Sync0 Sync Type shall configured*/
 866:../SSC/Src/ecatslv.c ****                 if((SyncType0x1C32 == (UINT16)SYNCTYPE_DCSYNC0)
 1680              	 .loc 3 866 0
 1681 0318 3B8E     	 ldrh r3,[r7,#48]
 1682 031a 022B     	 cmp r3,#2
 1683 031c 02D0     	 beq .L109
 867:../SSC/Src/ecatslv.c ****                     ||(SyncType0x1C33 == (UINT16)SYNCTYPE_DCSYNC0))
 1684              	 .loc 3 867 0
 1685 031e FB8D     	 ldrh r3,[r7,#46]
 1686 0320 022B     	 cmp r3,#2
 1687 0322 45D1     	 bne .L106
 1688              	.L109:
 868:../SSC/Src/ecatslv.c ****                 {
 869:../SSC/Src/ecatslv.c ****                     return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1689              	 .loc 3 869 0
 1690 0324 3023     	 movs r3,#48
 1691 0326 10E2     	 b .L89
 1692              	.L103:
 870:../SSC/Src/ecatslv.c ****                 }
 871:../SSC/Src/ecatslv.c ****             } //if((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) == 0)
 872:../SSC/Src/ecatslv.c **** 
 873:../SSC/Src/ecatslv.c ****         }
 874:../SSC/Src/ecatslv.c ****     } //if(bSyncSetByUser)
 875:../SSC/Src/ecatslv.c ****     else
 876:../SSC/Src/ecatslv.c ****     {
 877:../SSC/Src/ecatslv.c ****         /* No Sync Type selected by user => Configure Sync Type based on DC register values*/
 878:../SSC/Src/ecatslv.c ****         if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 0)
 1693              	 .loc 3 878 0
 1694 0328 FB7D     	 ldrb r3,[r7,#23]
 1695 032a 03F00903 	 and r3,r3,#9
 1696 032e 002B     	 cmp r3,#0
 1697 0330 1DD1     	 bne .L110
 879:../SSC/Src/ecatslv.c ****         {
 880:../SSC/Src/ecatslv.c ****             /* Activation or auto activation of the Sync Out Unit is disabled => Free Run or SM Syn
 881:../SSC/Src/ecatslv.c **** 
 882:../SSC/Src/ecatslv.c ****             /* AL Event enabled => Configure SM Sync*/
 883:../SSC/Src/ecatslv.c ****             if (nPdOutputSize > 0)
 1698              	 .loc 3 883 0
 1699 0332 954B     	 ldr r3,.L159
 1700 0334 1B88     	 ldrh r3,[r3]
 1701 0336 002B     	 cmp r3,#0
 1702 0338 0BD0     	 beq .L111
 884:../SSC/Src/ecatslv.c ****             {
 885:../SSC/Src/ecatslv.c ****                 SyncType0x1C32 = SYNCTYPE_SM_SYNCHRON;
 1703              	 .loc 3 885 0
 1704 033a 0123     	 movs r3,#1
 1705 033c 3B86     	 strh r3,[r7,#48]
 886:../SSC/Src/ecatslv.c ****                 
 887:../SSC/Src/ecatslv.c ****                 if (nPdInputSize > 0)
 1706              	 .loc 3 887 0
 1707 033e 934B     	 ldr r3,.L159+4
 1708 0340 1B88     	 ldrh r3,[r3]
 1709 0342 002B     	 cmp r3,#0
 1710 0344 02D0     	 beq .L112
 888:../SSC/Src/ecatslv.c ****                 {
 889:../SSC/Src/ecatslv.c ****                     SyncType0x1C33 = SYNCTYPE_SM2_SYNCHRON;
 1711              	 .loc 3 889 0
 1712 0346 2223     	 movs r3,#34
 1713 0348 FB85     	 strh r3,[r7,#46]
 1714 034a 31E0     	 b .L106
 1715              	.L112:
 890:../SSC/Src/ecatslv.c ****                 }
 891:../SSC/Src/ecatslv.c ****                 else
 892:../SSC/Src/ecatslv.c ****                 {
 893:../SSC/Src/ecatslv.c ****                     SyncType0x1C33 = SYNCTYPE_FREERUN;
 1716              	 .loc 3 893 0
 1717 034c 0023     	 movs r3,#0
 1718 034e FB85     	 strh r3,[r7,#46]
 1719 0350 2EE0     	 b .L106
 1720              	.L111:
 894:../SSC/Src/ecatslv.c ****                 }
 895:../SSC/Src/ecatslv.c ****             }
 896:../SSC/Src/ecatslv.c ****             else if (nPdInputSize > 0)
 1721              	 .loc 3 896 0
 1722 0352 8E4B     	 ldr r3,.L159+4
 1723 0354 1B88     	 ldrh r3,[r3]
 1724 0356 002B     	 cmp r3,#0
 1725 0358 04D0     	 beq .L115
 897:../SSC/Src/ecatslv.c ****             {
 898:../SSC/Src/ecatslv.c ****                 SyncType0x1C32 = SYNCTYPE_FREERUN;
 1726              	 .loc 3 898 0
 1727 035a 0023     	 movs r3,#0
 1728 035c 3B86     	 strh r3,[r7,#48]
 899:../SSC/Src/ecatslv.c ****                 SyncType0x1C33 = SYNCTYPE_SM_SYNCHRON;
 1729              	 .loc 3 899 0
 1730 035e 0123     	 movs r3,#1
 1731 0360 FB85     	 strh r3,[r7,#46]
 1732 0362 25E0     	 b .L106
 1733              	.L115:
 900:../SSC/Src/ecatslv.c ****             }
 901:../SSC/Src/ecatslv.c ****             else
 902:../SSC/Src/ecatslv.c ****             {
 903:../SSC/Src/ecatslv.c ****                 SyncType0x1C32 = SYNCTYPE_FREERUN;
 1734              	 .loc 3 903 0
 1735 0364 0023     	 movs r3,#0
 1736 0366 3B86     	 strh r3,[r7,#48]
 904:../SSC/Src/ecatslv.c ****                 SyncType0x1C33 = SYNCTYPE_FREERUN;
 1737              	 .loc 3 904 0
 1738 0368 0023     	 movs r3,#0
 1739 036a FB85     	 strh r3,[r7,#46]
 1740 036c 20E0     	 b .L106
 1741              	.L110:
 905:../SSC/Src/ecatslv.c ****             }
 906:../SSC/Src/ecatslv.c **** 
 907:../SSC/Src/ecatslv.c ****         }
 908:../SSC/Src/ecatslv.c ****         else
 909:../SSC/Src/ecatslv.c ****         {
 910:../SSC/Src/ecatslv.c ****             if (nPdOutputSize > 0)
 1742              	 .loc 3 910 0
 1743 036e 864B     	 ldr r3,.L159
 1744 0370 1B88     	 ldrh r3,[r3]
 1745 0372 002B     	 cmp r3,#0
 1746 0374 09D0     	 beq .L116
 911:../SSC/Src/ecatslv.c ****             {
 912:../SSC/Src/ecatslv.c ****                 /* Sync Signal generation is active*/
 913:../SSC/Src/ecatslv.c ****                 if (bSubordinatedCycles)
 1747              	 .loc 3 913 0
 1748 0376 97F83730 	 ldrb r3,[r7,#55]
 1749 037a 002B     	 cmp r3,#0
 1750 037c 02D0     	 beq .L117
 914:../SSC/Src/ecatslv.c ****                 {
 915:../SSC/Src/ecatslv.c ****                     SyncType0x1C32 = SYNCTYPE_DCSYNC1;
 1751              	 .loc 3 915 0
 1752 037e 0323     	 movs r3,#3
 1753 0380 3B86     	 strh r3,[r7,#48]
 1754 0382 04E0     	 b .L119
 1755              	.L117:
 916:../SSC/Src/ecatslv.c ****                 }
 917:../SSC/Src/ecatslv.c ****                 else
 918:../SSC/Src/ecatslv.c ****                 {
 919:../SSC/Src/ecatslv.c ****                     SyncType0x1C32 = SYNCTYPE_DCSYNC0;
 1756              	 .loc 3 919 0
 1757 0384 0223     	 movs r3,#2
 1758 0386 3B86     	 strh r3,[r7,#48]
 1759 0388 01E0     	 b .L119
 1760              	.L116:
 920:../SSC/Src/ecatslv.c ****                 }
 921:../SSC/Src/ecatslv.c ****             }
 922:../SSC/Src/ecatslv.c ****             else
 923:../SSC/Src/ecatslv.c ****             {
 924:../SSC/Src/ecatslv.c ****                 SyncType0x1C32 = SYNCTYPE_FREERUN;
 1761              	 .loc 3 924 0
 1762 038a 0023     	 movs r3,#0
 1763 038c 3B86     	 strh r3,[r7,#48]
 1764              	.L119:
 925:../SSC/Src/ecatslv.c ****             }
 926:../SSC/Src/ecatslv.c **** 
 927:../SSC/Src/ecatslv.c **** 
 928:../SSC/Src/ecatslv.c ****             if (nPdInputSize > 0)
 1765              	 .loc 3 928 0
 1766 038e 7F4B     	 ldr r3,.L159+4
 1767 0390 1B88     	 ldrh r3,[r3]
 1768 0392 002B     	 cmp r3,#0
 1769 0394 0AD0     	 beq .L120
 929:../SSC/Src/ecatslv.c ****             {
 930:../SSC/Src/ecatslv.c ****                 if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
 1770              	 .loc 3 930 0
 1771 0396 FB7D     	 ldrb r3,[r7,#23]
 1772 0398 03F00403 	 and r3,r3,#4
 1773 039c 002B     	 cmp r3,#0
 1774 039e 02D0     	 beq .L121
 931:../SSC/Src/ecatslv.c ****                 {
 932:../SSC/Src/ecatslv.c ****                     /* If Sync1 is available the inputs will always be mapped with Sync1 */
 933:../SSC/Src/ecatslv.c ****                     SyncType0x1C33 = SYNCTYPE_DCSYNC1;
 1775              	 .loc 3 933 0
 1776 03a0 0323     	 movs r3,#3
 1777 03a2 FB85     	 strh r3,[r7,#46]
 1778 03a4 04E0     	 b .L106
 1779              	.L121:
 934:../SSC/Src/ecatslv.c ****                 }
 935:../SSC/Src/ecatslv.c ****                 else
 936:../SSC/Src/ecatslv.c ****                 {
 937:../SSC/Src/ecatslv.c ****                     /* Map Inputs based on Sync0*/
 938:../SSC/Src/ecatslv.c ****                     SyncType0x1C33 = SYNCTYPE_DCSYNC0;
 1780              	 .loc 3 938 0
 1781 03a6 0223     	 movs r3,#2
 1782 03a8 FB85     	 strh r3,[r7,#46]
 1783 03aa 01E0     	 b .L106
 1784              	.L120:
 939:../SSC/Src/ecatslv.c ****                 }
 940:../SSC/Src/ecatslv.c ****             }
 941:../SSC/Src/ecatslv.c ****             else
 942:../SSC/Src/ecatslv.c ****             {
 943:../SSC/Src/ecatslv.c ****                 SyncType0x1C33 = SYNCTYPE_FREERUN;
 1785              	 .loc 3 943 0
 1786 03ac 0023     	 movs r3,#0
 1787 03ae FB85     	 strh r3,[r7,#46]
 1788              	.L106:
 944:../SSC/Src/ecatslv.c ****             }
 945:../SSC/Src/ecatslv.c ****         }
 946:../SSC/Src/ecatslv.c ****     }
 947:../SSC/Src/ecatslv.c **** 
 948:../SSC/Src/ecatslv.c ****     /* Update Cycle time entries if DC Sync Mode enabled */
 949:../SSC/Src/ecatslv.c ****     if(SyncType0x1C32 == SYNCTYPE_DCSYNC1)
 1789              	 .loc 3 949 0
 1790 03b0 3B8E     	 ldrh r3,[r7,#48]
 1791 03b2 032B     	 cmp r3,#3
 1792 03b4 0CD1     	 bne .L123
 950:../SSC/Src/ecatslv.c ****     {
 951:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ECAT1*/
 952:../SSC/Src/ecatslv.c ****         sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
 1793              	 .loc 3 952 0
 1794 03b6 764A     	 ldr r2,.L159+8
 1795 03b8 7B6A     	 ldr r3,[r7,#36]
 1796 03ba 5362     	 str r3,[r2,#36]
 953:../SSC/Src/ecatslv.c ****         sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
 1797              	 .loc 3 953 0
 1798 03bc 744A     	 ldr r2,.L159+8
 1799 03be 7B6A     	 ldr r3,[r7,#36]
 1800 03c0 5360     	 str r3,[r2,#4]
 954:../SSC/Src/ecatslv.c **** 
 955:../SSC/Src/ecatslv.c ****         sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
 1801              	 .loc 3 955 0
 1802 03c2 744A     	 ldr r2,.L159+12
 1803 03c4 7B6A     	 ldr r3,[r7,#36]
 1804 03c6 5362     	 str r3,[r2,#36]
 956:../SSC/Src/ecatslv.c ****         sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
 1805              	 .loc 3 956 0
 1806 03c8 724A     	 ldr r2,.L159+12
 1807 03ca 7B6A     	 ldr r3,[r7,#36]
 1808 03cc 5360     	 str r3,[r2,#4]
 1809 03ce 0EE0     	 b .L124
 1810              	.L123:
 957:../SSC/Src/ecatslv.c ****     }
 958:../SSC/Src/ecatslv.c ****     else if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
 1811              	 .loc 3 958 0
 1812 03d0 3B8E     	 ldrh r3,[r7,#48]
 1813 03d2 022B     	 cmp r3,#2
 1814 03d4 0BD1     	 bne .L124
 959:../SSC/Src/ecatslv.c ****     {
 960:../SSC/Src/ecatslv.c ****         sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
 1815              	 .loc 3 960 0
 1816 03d6 6E4A     	 ldr r2,.L159+8
 1817 03d8 7B6A     	 ldr r3,[r7,#36]
 1818 03da 5362     	 str r3,[r2,#36]
 961:../SSC/Src/ecatslv.c ****         sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
 1819              	 .loc 3 961 0
 1820 03dc 6C4A     	 ldr r2,.L159+8
 1821 03de 7B6A     	 ldr r3,[r7,#36]
 1822 03e0 5360     	 str r3,[r2,#4]
 962:../SSC/Src/ecatslv.c **** 
 963:../SSC/Src/ecatslv.c ****         sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
 1823              	 .loc 3 963 0
 1824 03e2 6C4A     	 ldr r2,.L159+12
 1825 03e4 7B6A     	 ldr r3,[r7,#36]
 1826 03e6 5362     	 str r3,[r2,#36]
 964:../SSC/Src/ecatslv.c ****         sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
 1827              	 .loc 3 964 0
 1828 03e8 6A4A     	 ldr r2,.L159+12
 1829 03ea 7B6A     	 ldr r3,[r7,#36]
 1830 03ec 5360     	 str r3,[r2,#4]
 1831              	.L124:
 965:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT1*/
 966:../SSC/Src/ecatslv.c ****     }
 967:../SSC/Src/ecatslv.c **** 
 968:../SSC/Src/ecatslv.c ****     /* Set global flags based on Sync Type */
 969:../SSC/Src/ecatslv.c ****     if ( !b3BufferMode )
 1832              	 .loc 3 969 0
 1833 03ee 6A4B     	 ldr r3,.L159+16
 1834 03f0 1B78     	 ldrb r3,[r3]
 1835 03f2 83F00103 	 eor r3,r3,#1
 1836 03f6 DBB2     	 uxtb r3,r3
 1837 03f8 002B     	 cmp r3,#0
 1838 03fa 07D0     	 beq .L125
 970:../SSC/Src/ecatslv.c ****     {
 971:../SSC/Src/ecatslv.c ****         /* 1-Buffer-Mode configured => For free run it shall be 3Buffer mode*/
 972:../SSC/Src/ecatslv.c ****         if (( SyncType0x1C32 == SYNCTYPE_FREERUN ) || ( SyncType0x1C33 == SYNCTYPE_FREERUN ))
 1839              	 .loc 3 972 0
 1840 03fc 3B8E     	 ldrh r3,[r7,#48]
 1841 03fe 002B     	 cmp r3,#0
 1842 0400 02D0     	 beq .L126
 1843              	 .loc 3 972 0 is_stmt 0 discriminator 1
 1844 0402 FB8D     	 ldrh r3,[r7,#46]
 1845 0404 002B     	 cmp r3,#0
 1846 0406 01D1     	 bne .L125
 1847              	.L126:
 973:../SSC/Src/ecatslv.c ****         {
 974:../SSC/Src/ecatslv.c ****                 return ALSTATUSCODE_FREERUNNEEDS3BUFFERMODE;
 1848              	 .loc 3 974 0 is_stmt 1
 1849 0408 2923     	 movs r3,#41
 1850 040a 9EE1     	 b .L89
 1851              	.L125:
 975:../SSC/Src/ecatslv.c ****         }
 976:../SSC/Src/ecatslv.c ****     }
 977:../SSC/Src/ecatslv.c **** 
 978:../SSC/Src/ecatslv.c ****     /* If no free run is supported the EscInt is always enabled*/
 979:../SSC/Src/ecatslv.c ****         if (( SyncType0x1C32 != SYNCTYPE_FREERUN ) || ( SyncType0x1C33 != SYNCTYPE_FREERUN ))
 1852              	 .loc 3 979 0
 1853 040c 3B8E     	 ldrh r3,[r7,#48]
 1854 040e 002B     	 cmp r3,#0
 1855 0410 02D1     	 bne .L127
 1856              	 .loc 3 979 0 is_stmt 0 discriminator 1
 1857 0412 FB8D     	 ldrh r3,[r7,#46]
 1858 0414 002B     	 cmp r3,#0
 1859 0416 02D0     	 beq .L128
 1860              	.L127:
 980:../SSC/Src/ecatslv.c ****         {
 981:../SSC/Src/ecatslv.c ****         /* ECAT Synchron Mode, the ESC interrupt is enabled */
 982:../SSC/Src/ecatslv.c ****         bEscIntEnabled = TRUE;
 1861              	 .loc 3 982 0 is_stmt 1
 1862 0418 604B     	 ldr r3,.L159+20
 1863 041a 0122     	 movs r2,#1
 1864 041c 1A70     	 strb r2,[r3]
 1865              	.L128:
 983:../SSC/Src/ecatslv.c ****     }
 984:../SSC/Src/ecatslv.c **** 
 985:../SSC/Src/ecatslv.c ****         /* Update value for AL Event Mask register (0x204) */
 986:../SSC/Src/ecatslv.c ****         if(bEscIntEnabled)
 1866              	 .loc 3 986 0
 1867 041e 5F4B     	 ldr r3,.L159+20
 1868 0420 1B78     	 ldrb r3,[r3]
 1869 0422 002B     	 cmp r3,#0
 1870 0424 10D0     	 beq .L129
 987:../SSC/Src/ecatslv.c ****         {
 988:../SSC/Src/ecatslv.c ****             if(nPdOutputSize > 0)
 1871              	 .loc 3 988 0
 1872 0426 584B     	 ldr r3,.L159
 1873 0428 1B88     	 ldrh r3,[r3]
 1874 042a 002B     	 cmp r3,#0
 1875 042c 04D0     	 beq .L130
 989:../SSC/Src/ecatslv.c ****             {
 990:../SSC/Src/ecatslv.c ****                 u16ALEventMask = PROCESS_OUTPUT_EVENT;
 1876              	 .loc 3 990 0
 1877 042e 5C4B     	 ldr r3,.L159+24
 1878 0430 4FF48062 	 mov r2,#1024
 1879 0434 1A80     	 strh r2,[r3]
 1880 0436 07E0     	 b .L129
 1881              	.L130:
 991:../SSC/Src/ecatslv.c ****             }
 992:../SSC/Src/ecatslv.c ****             else if(nPdInputSize > 0)
 1882              	 .loc 3 992 0
 1883 0438 544B     	 ldr r3,.L159+4
 1884 043a 1B88     	 ldrh r3,[r3]
 1885 043c 002B     	 cmp r3,#0
 1886 043e 03D0     	 beq .L129
 993:../SSC/Src/ecatslv.c ****             {
 994:../SSC/Src/ecatslv.c ****                 u16ALEventMask = PROCESS_INPUT_EVENT;
 1887              	 .loc 3 994 0
 1888 0440 574B     	 ldr r3,.L159+24
 1889 0442 4FF40062 	 mov r2,#2048
 1890 0446 1A80     	 strh r2,[r3]
 1891              	.L129:
 995:../SSC/Src/ecatslv.c ****             }
 996:../SSC/Src/ecatslv.c **** 
 997:../SSC/Src/ecatslv.c ****         }
 998:../SSC/Src/ecatslv.c **** 
 999:../SSC/Src/ecatslv.c ****         if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
 1892              	 .loc 3 999 0
 1893 0448 3B8E     	 ldrh r3,[r7,#48]
 1894 044a 022B     	 cmp r3,#2
 1895 044c 08D0     	 beq .L131
 1896              	 .loc 3 999 0 is_stmt 0 discriminator 1
 1897 044e 3B8E     	 ldrh r3,[r7,#48]
 1898 0450 032B     	 cmp r3,#3
 1899 0452 05D0     	 beq .L131
1000:../SSC/Src/ecatslv.c ****             || (SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))/* Sync
 1900              	 .loc 3 1000 0 is_stmt 1
 1901 0454 FB8D     	 ldrh r3,[r7,#46]
 1902 0456 022B     	 cmp r3,#2
 1903 0458 02D0     	 beq .L131
 1904              	 .loc 3 1000 0 is_stmt 0 discriminator 1
 1905 045a FB8D     	 ldrh r3,[r7,#46]
 1906 045c 032B     	 cmp r3,#3
 1907 045e 09D1     	 bne .L132
 1908              	.L131:
1001:../SSC/Src/ecatslv.c ****         {
1002:../SSC/Src/ecatslv.c ****             /* slave is running in DC-mode */
1003:../SSC/Src/ecatslv.c ****             bDcSyncActive = TRUE;
 1909              	 .loc 3 1003 0 is_stmt 1
 1910 0460 504B     	 ldr r3,.L159+28
 1911 0462 0122     	 movs r2,#1
 1912 0464 1A70     	 strb r2,[r3]
1004:../SSC/Src/ecatslv.c **** 
1005:../SSC/Src/ecatslv.c ****             /*In case of an Input only application with DC no PDI Isr handling is required*/
1006:../SSC/Src/ecatslv.c ****             if (nPdOutputSize == 0)
 1913              	 .loc 3 1006 0
 1914 0466 484B     	 ldr r3,.L159
 1915 0468 1B88     	 ldrh r3,[r3]
 1916 046a 002B     	 cmp r3,#0
 1917 046c 02D1     	 bne .L132
1007:../SSC/Src/ecatslv.c ****             {
1008:../SSC/Src/ecatslv.c ****                u16ALEventMask = 0;
 1918              	 .loc 3 1008 0
 1919 046e 4C4B     	 ldr r3,.L159+24
 1920 0470 0022     	 movs r2,#0
 1921 0472 1A80     	 strh r2,[r3]
 1922              	.L132:
1009:../SSC/Src/ecatslv.c ****             }
1010:../SSC/Src/ecatslv.c ****         }
1011:../SSC/Src/ecatslv.c **** 
1012:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16SyncType = SyncType0x1C32;
 1923              	 .loc 3 1012 0
 1924 0474 464A     	 ldr r2,.L159+8
 1925 0476 3B8E     	 ldrh r3,[r7,#48]
 1926 0478 5380     	 strh r3,[r2,#2]
1013:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16SyncType = SyncType0x1C33;
 1927              	 .loc 3 1013 0
 1928 047a 464A     	 ldr r2,.L159+12
 1929 047c FB8D     	 ldrh r3,[r7,#46]
 1930 047e 5380     	 strh r3,[r2,#2]
1014:../SSC/Src/ecatslv.c **** 
1015:../SSC/Src/ecatslv.c ****     /* Calculate number of Sync0 events within one SM cycle and the Sync0 events on which the input
1016:../SSC/Src/ecatslv.c ****     LatchInputSync0Value = 0;
 1931              	 .loc 3 1016 0
 1932 0480 494B     	 ldr r3,.L159+32
 1933 0482 0022     	 movs r2,#0
 1934 0484 1A80     	 strh r2,[r3]
1017:../SSC/Src/ecatslv.c ****     LatchInputSync0Counter = 0;
 1935              	 .loc 3 1017 0
 1936 0486 494B     	 ldr r3,.L159+36
 1937 0488 0022     	 movs r2,#0
 1938 048a 1A80     	 strh r2,[r3]
1018:../SSC/Src/ecatslv.c ****     u16SmSync0Value = 0;
 1939              	 .loc 3 1018 0
 1940 048c 484B     	 ldr r3,.L159+40
 1941 048e 0022     	 movs r2,#0
 1942 0490 1A80     	 strh r2,[r3]
1019:../SSC/Src/ecatslv.c ****     u16SmSync0Counter = 0;
 1943              	 .loc 3 1019 0
 1944 0492 484B     	 ldr r3,.L159+44
 1945 0494 0022     	 movs r2,#0
 1946 0496 1A80     	 strh r2,[r3]
1020:../SSC/Src/ecatslv.c **** 
1021:../SSC/Src/ecatslv.c **** 
1022:../SSC/Src/ecatslv.c ****     if(bSubordinatedCycles == TRUE)
 1947              	 .loc 3 1022 0
 1948 0498 97F83730 	 ldrb r3,[r7,#55]
 1949 049c 002B     	 cmp r3,#0
 1950 049e 3BD0     	 beq .L133
 1951              	.LBB3:
1023:../SSC/Src/ecatslv.c ****     {
1024:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ECAT4*/
1025:../SSC/Src/ecatslv.c ****         UINT32 cycleTimeSync1 = (shiftTimeSync1 + cycleTimeSync0);
 1952              	 .loc 3 1025 0
 1953 04a0 3A6A     	 ldr r2,[r7,#32]
 1954 04a2 7B6A     	 ldr r3,[r7,#36]
 1955 04a4 1344     	 add r3,r3,r2
 1956 04a6 FB60     	 str r3,[r7,#12]
1026:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT4*/
1027:../SSC/Src/ecatslv.c **** 
1028:../SSC/Src/ecatslv.c ****         /* get the number of Sync0 event within on SM cycle */
1029:../SSC/Src/ecatslv.c ****         if(shiftTimeSync1 >= cycleTimeSync0)
 1957              	 .loc 3 1029 0
 1958 04a8 3A6A     	 ldr r2,[r7,#32]
 1959 04aa 7B6A     	 ldr r3,[r7,#36]
 1960 04ac 9A42     	 cmp r2,r3
 1961 04ae 17D3     	 bcc .L134
1030:../SSC/Src/ecatslv.c ****         {
1031:../SSC/Src/ecatslv.c **** 
1032:../SSC/Src/ecatslv.c ****             u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
 1962              	 .loc 3 1032 0
 1963 04b0 FA68     	 ldr r2,[r7,#12]
 1964 04b2 7B6A     	 ldr r3,[r7,#36]
 1965 04b4 B2FBF3F3 	 udiv r3,r2,r3
 1966 04b8 9AB2     	 uxth r2,r3
 1967 04ba 3D4B     	 ldr r3,.L159+40
 1968 04bc 1A80     	 strh r2,[r3]
1033:../SSC/Src/ecatslv.c ****             
1034:../SSC/Src/ecatslv.c ****             if((cycleTimeSync1 % cycleTimeSync0) == 0)
 1969              	 .loc 3 1034 0
 1970 04be FB68     	 ldr r3,[r7,#12]
 1971 04c0 7A6A     	 ldr r2,[r7,#36]
 1972 04c2 B3FBF2F2 	 udiv r2,r3,r2
 1973 04c6 796A     	 ldr r1,[r7,#36]
 1974 04c8 01FB02F2 	 mul r2,r1,r2
 1975 04cc 9B1A     	 subs r3,r3,r2
 1976 04ce 002B     	 cmp r3,#0
 1977 04d0 09D1     	 bne .L136
1035:../SSC/Src/ecatslv.c ****             {
1036:../SSC/Src/ecatslv.c ****                 /* if the Sync1cycletime/Sync0cycletime ratio is even one additional tick */
1037:../SSC/Src/ecatslv.c ****                 u16SmSync0Value ++;
 1978              	 .loc 3 1037 0
 1979 04d2 374B     	 ldr r3,.L159+40
 1980 04d4 1B88     	 ldrh r3,[r3]
 1981 04d6 0133     	 adds r3,r3,#1
 1982 04d8 9AB2     	 uxth r2,r3
 1983 04da 354B     	 ldr r3,.L159+40
 1984 04dc 1A80     	 strh r2,[r3]
 1985 04de 02E0     	 b .L136
 1986              	.L134:
1038:../SSC/Src/ecatslv.c ****             }
1039:../SSC/Src/ecatslv.c ****         }
1040:../SSC/Src/ecatslv.c ****         else
1041:../SSC/Src/ecatslv.c ****         {
1042:../SSC/Src/ecatslv.c ****             u16SmSync0Value = 1;
 1987              	 .loc 3 1042 0
 1988 04e0 334B     	 ldr r3,.L159+40
 1989 04e2 0122     	 movs r2,#1
 1990 04e4 1A80     	 strh r2,[r3]
 1991              	.L136:
1043:../SSC/Src/ecatslv.c ****         }
1044:../SSC/Src/ecatslv.c **** 
1045:../SSC/Src/ecatslv.c ****         /* Calculate the Sync0 tick on which the inputs shall be latched (last Sync0 before the nex
1046:../SSC/Src/ecatslv.c ****         LatchInputSync0Value = (UINT16) (cycleTimeSync1 / cycleTimeSync0);
 1992              	 .loc 3 1046 0
 1993 04e6 FA68     	 ldr r2,[r7,#12]
 1994 04e8 7B6A     	 ldr r3,[r7,#36]
 1995 04ea B2FBF3F3 	 udiv r3,r2,r3
 1996 04ee 9AB2     	 uxth r2,r3
 1997 04f0 2D4B     	 ldr r3,.L159+32
 1998 04f2 1A80     	 strh r2,[r3]
1047:../SSC/Src/ecatslv.c **** 
1048:../SSC/Src/ecatslv.c ****         if ((cycleTimeSync1 % cycleTimeSync0) > 0)
 1999              	 .loc 3 1048 0
 2000 04f4 FB68     	 ldr r3,[r7,#12]
 2001 04f6 7A6A     	 ldr r2,[r7,#36]
 2002 04f8 B3FBF2F2 	 udiv r2,r3,r2
 2003 04fc 796A     	 ldr r1,[r7,#36]
 2004 04fe 01FB02F2 	 mul r2,r1,r2
 2005 0502 9B1A     	 subs r3,r3,r2
 2006 0504 002B     	 cmp r3,#0
 2007 0506 06D0     	 beq .L137
1049:../SSC/Src/ecatslv.c ****         {
1050:../SSC/Src/ecatslv.c ****             LatchInputSync0Value++;
 2008              	 .loc 3 1050 0
 2009 0508 274B     	 ldr r3,.L159+32
 2010 050a 1B88     	 ldrh r3,[r3]
 2011 050c 0133     	 adds r3,r3,#1
 2012 050e 9AB2     	 uxth r2,r3
 2013 0510 254B     	 ldr r3,.L159+32
 2014 0512 1A80     	 strh r2,[r3]
 2015              	.LBE3:
 2016 0514 0CE0     	 b .L138
 2017              	.L137:
 2018 0516 0BE0     	 b .L138
 2019              	.L133:
1051:../SSC/Src/ecatslv.c ****         }
1052:../SSC/Src/ecatslv.c **** 
1053:../SSC/Src/ecatslv.c ****     }
1054:../SSC/Src/ecatslv.c ****     else 
1055:../SSC/Src/ecatslv.c ****     {
1056:../SSC/Src/ecatslv.c ****         if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
 2020              	 .loc 3 1056 0
 2021 0518 3B8E     	 ldrh r3,[r7,#48]
 2022 051a 022B     	 cmp r3,#2
 2023 051c 02D1     	 bne .L139
1057:../SSC/Src/ecatslv.c ****         {
1058:../SSC/Src/ecatslv.c ****             /* if SyncType of 0x1C32 is 2 the Sync0 event is trigger once during a SM cycle */
1059:../SSC/Src/ecatslv.c ****             u16SmSync0Value = 1;
 2024              	 .loc 3 1059 0
 2025 051e 244B     	 ldr r3,.L159+40
 2026 0520 0122     	 movs r2,#1
 2027 0522 1A80     	 strh r2,[r3]
 2028              	.L139:
1060:../SSC/Src/ecatslv.c ****         }   
1061:../SSC/Src/ecatslv.c **** 
1062:../SSC/Src/ecatslv.c ****         if(SyncType0x1C33 != SYNCTYPE_DCSYNC1)
 2029              	 .loc 3 1062 0
 2030 0524 FB8D     	 ldrh r3,[r7,#46]
 2031 0526 032B     	 cmp r3,#3
 2032 0528 02D0     	 beq .L138
1063:../SSC/Src/ecatslv.c ****         {
1064:../SSC/Src/ecatslv.c ****             LatchInputSync0Value = 1;
 2033              	 .loc 3 1064 0
 2034 052a 1F4B     	 ldr r3,.L159+32
 2035 052c 0122     	 movs r2,#1
 2036 052e 1A80     	 strh r2,[r3]
 2037              	.L138:
1065:../SSC/Src/ecatslv.c ****         }
1066:../SSC/Src/ecatslv.c ****     }
1067:../SSC/Src/ecatslv.c **** 
1068:../SSC/Src/ecatslv.c **** 
1069:../SSC/Src/ecatslv.c **** 
1070:../SSC/Src/ecatslv.c ****     /* reset the error counter indicating synchronization problems */
1071:../SSC/Src/ecatslv.c ****     sCycleDiag.syncFailedCounter = 0;
 2038              	 .loc 3 1071 0
 2039 0530 214B     	 ldr r3,.L159+48
 2040 0532 0022     	 movs r2,#0
 2041 0534 1A80     	 strh r2,[r3]
1072:../SSC/Src/ecatslv.c **** 
1073:../SSC/Src/ecatslv.c **** 
1074:../SSC/Src/ecatslv.c ****     /*
1075:../SSC/Src/ecatslv.c ****         --- Check watchdog settings ---
1076:../SSC/Src/ecatslv.c ****     */
1077:../SSC/Src/ecatslv.c **** 
1078:../SSC/Src/ecatslv.c ****     /*get the watchdog time (register 0x420). if value is > 0 watchdog is active*/
1079:../SSC/Src/ecatslv.c ****     HW_EscReadWord(wd, ESC_PD_WD_TIME);
 2042              	 .loc 3 1079 0
 2043 0536 214B     	 ldr r3,.L159+52
 2044 0538 1B88     	 ldrh r3,[r3]
 2045 053a 7B85     	 strh r3,[r7,#42]
1080:../SSC/Src/ecatslv.c ****     wd = SWAPWORD(wd);
1081:../SSC/Src/ecatslv.c **** 
1082:../SSC/Src/ecatslv.c ****     if (nPdOutputSize > 0 &&  wd != 0 )
 2046              	 .loc 3 1082 0
 2047 053c 124B     	 ldr r3,.L159
 2048 053e 1B88     	 ldrh r3,[r3]
 2049 0540 002B     	 cmp r3,#0
 2050 0542 49D0     	 beq .L140
 2051              	 .loc 3 1082 0 is_stmt 0 discriminator 1
 2052 0544 7B8D     	 ldrh r3,[r7,#42]
 2053 0546 002B     	 cmp r3,#0
 2054 0548 46D0     	 beq .L140
1083:../SSC/Src/ecatslv.c ****     {
1084:../SSC/Src/ecatslv.c ****     /*get watchdog divider (register 0x400)*/
1085:../SSC/Src/ecatslv.c ****     HW_EscReadWord(wdiv, ESC_WD_DIVIDER_OFFSET);
 2055              	 .loc 3 1085 0 is_stmt 1
 2056 054a 1D4B     	 ldr r3,.L159+56
 2057 054c 1B88     	 ldrh r3,[r3]
 2058 054e BB85     	 strh r3,[r7,#44]
1086:../SSC/Src/ecatslv.c ****     wdiv = SWAPWORD(wdiv);
1087:../SSC/Src/ecatslv.c ****         if ( wdiv != 0 )
 2059              	 .loc 3 1087 0
 2060 0550 BB8D     	 ldrh r3,[r7,#44]
 2061 0552 002B     	 cmp r3,#0
 2062 0554 3AD0     	 beq .L141
 2063              	.LBB4:
1088:../SSC/Src/ecatslv.c ****         {
1089:../SSC/Src/ecatslv.c ****             /* the ESC subtracts 2 in register 0x400 so it has to be added here */
1090:../SSC/Src/ecatslv.c ****             UINT32 d = wdiv+2;
 2064              	 .loc 3 1090 0
 2065 0556 BB8D     	 ldrh r3,[r7,#44]
 2066 0558 0233     	 adds r3,r3,#2
 2067 055a BB60     	 str r3,[r7,#8]
1091:../SSC/Src/ecatslv.c **** 
1092:../SSC/Src/ecatslv.c **** 
1093:../SSC/Src/ecatslv.c ****             d *= wd;
 2068              	 .loc 3 1093 0
 2069 055c 7A8D     	 ldrh r2,[r7,#42]
 2070 055e BB68     	 ldr r3,[r7,#8]
 2071 0560 02FB03F3 	 mul r3,r2,r3
 2072 0564 BB60     	 str r3,[r7,#8]
1094:../SSC/Src/ecatslv.c ****             /* store watchdog in ms in variable u16WdValue */
1095:../SSC/Src/ecatslv.c ****             /* watchdog value has to be rounded up */
1096:../SSC/Src/ecatslv.c ****             d += 24999;
 2073              	 .loc 3 1096 0
 2074 0566 BB68     	 ldr r3,[r7,#8]
 2075 0568 03F5C343 	 add r3,r3,#24960
 2076 056c 2733     	 adds r3,r3,#39
 2077 056e BB60     	 str r3,[r7,#8]
1097:../SSC/Src/ecatslv.c ****             d /= 25000;
 2078              	 .loc 3 1097 0
 2079 0570 BB68     	 ldr r3,[r7,#8]
 2080 0572 DB08     	 lsrs r3,r3,#3
 2081 0574 134A     	 ldr r2,.L159+60
 2082 0576 A2FB0323 	 umull r2,r3,r2,r3
 2083 057a 1B0A     	 lsrs r3,r3,#8
 2084 057c BB60     	 str r3,[r7,#8]
1098:../SSC/Src/ecatslv.c ****             EcatWdValue = (UINT16) d;
 2085              	 .loc 3 1098 0
 2086 057e BB68     	 ldr r3,[r7,#8]
 2087 0580 9AB2     	 uxth r2,r3
 2088 0582 114B     	 ldr r3,.L159+64
 2089 0584 1A80     	 strh r2,[r3]
 2090              	.LBE4:
1087:../SSC/Src/ecatslv.c ****         {
 2091              	 .loc 3 1087 0
 2092 0586 2CE0     	 b .L143
 2093              	.L160:
 2094              	 .align 2
 2095              	.L159:
 2096 0588 00000000 	 .word nPdOutputSize
 2097 058c 00000000 	 .word nPdInputSize
 2098 0590 00000000 	 .word sSyncManOutPar
 2099 0594 00000000 	 .word sSyncManInPar
 2100 0598 00000000 	 .word b3BufferMode
 2101 059c 00000000 	 .word bEscIntEnabled
 2102 05a0 00000000 	 .word u16ALEventMask
 2103 05a4 00000000 	 .word bDcSyncActive
 2104 05a8 00000000 	 .word LatchInputSync0Value
 2105 05ac 00000000 	 .word LatchInputSync0Counter
 2106 05b0 00000000 	 .word u16SmSync0Value
 2107 05b4 00000000 	 .word u16SmSync0Counter
 2108 05b8 00000000 	 .word sCycleDiag
 2109 05bc 20040154 	 .word 1409352736
 2110 05c0 00040154 	 .word 1409352704
 2111 05c4 89B5F814 	 .word 351843721
 2112 05c8 00000000 	 .word EcatWdValue
 2113              	.L141:
1099:../SSC/Src/ecatslv.c ****         }
1100:../SSC/Src/ecatslv.c ****         else
1101:../SSC/Src/ecatslv.c ****         {
1102:../SSC/Src/ecatslv.c ****             wd = 0;
 2114              	 .loc 3 1102 0
 2115 05cc 0023     	 movs r3,#0
 2116 05ce 7B85     	 strh r3,[r7,#42]
1103:../SSC/Src/ecatslv.c ****             /* wd value has to be set to zero, if the wd is 0 */
1104:../SSC/Src/ecatslv.c ****             EcatWdValue = 0;
 2117              	 .loc 3 1104 0
 2118 05d0 604B     	 ldr r3,.L161
 2119 05d2 0022     	 movs r2,#0
 2120 05d4 1A80     	 strh r2,[r3]
1087:../SSC/Src/ecatslv.c ****         {
 2121              	 .loc 3 1087 0
 2122 05d6 04E0     	 b .L143
 2123              	.L140:
1105:../SSC/Src/ecatslv.c ****         }
1106:../SSC/Src/ecatslv.c ****     }
1107:../SSC/Src/ecatslv.c ****     else
1108:../SSC/Src/ecatslv.c ****     {
1109:../SSC/Src/ecatslv.c ****         /* the watchdog is deactivated or slave has no output process data*/
1110:../SSC/Src/ecatslv.c ****         wdiv = 0;
 2124              	 .loc 3 1110 0
 2125 05d8 0023     	 movs r3,#0
 2126 05da BB85     	 strh r3,[r7,#44]
1111:../SSC/Src/ecatslv.c ****         EcatWdValue = 0;
 2127              	 .loc 3 1111 0
 2128 05dc 5D4B     	 ldr r3,.L161
 2129 05de 0022     	 movs r2,#0
 2130 05e0 1A80     	 strh r2,[r3]
 2131              	.L143:
1112:../SSC/Src/ecatslv.c ****     }
1113:../SSC/Src/ecatslv.c **** 
1114:../SSC/Src/ecatslv.c ****     if((EcatWdValue == 0 && bWdTrigger) || (EcatWdValue != 0 && !bWdTrigger))
 2132              	 .loc 3 1114 0
 2133 05e2 5C4B     	 ldr r3,.L161
 2134 05e4 1B88     	 ldrh r3,[r3]
 2135 05e6 002B     	 cmp r3,#0
 2136 05e8 03D1     	 bne .L144
 2137              	 .loc 3 1114 0 is_stmt 0 discriminator 1
 2138 05ea 5B4B     	 ldr r3,.L161+4
 2139 05ec 1B78     	 ldrb r3,[r3]
 2140 05ee 002B     	 cmp r3,#0
 2141 05f0 0AD1     	 bne .L145
 2142              	.L144:
 2143              	 .loc 3 1114 0 discriminator 3
 2144 05f2 584B     	 ldr r3,.L161
 2145 05f4 1B88     	 ldrh r3,[r3]
 2146 05f6 002B     	 cmp r3,#0
 2147 05f8 08D0     	 beq .L146
 2148              	 .loc 3 1114 0 discriminator 4
 2149 05fa 574B     	 ldr r3,.L161+4
 2150 05fc 1B78     	 ldrb r3,[r3]
 2151 05fe 83F00103 	 eor r3,r3,#1
 2152 0602 DBB2     	 uxtb r3,r3
 2153 0604 002B     	 cmp r3,#0
 2154 0606 01D0     	 beq .L146
 2155              	.L145:
1115:../SSC/Src/ecatslv.c ****     {
1116:../SSC/Src/ecatslv.c ****         /* if the WD-Trigger in the Sync Manager Channel 2 Control-Byte is set (Bit 6 of Register 0
1117:../SSC/Src/ecatslv.c ****             an error has to be returned */
1118:../SSC/Src/ecatslv.c ****         return ALSTATUSCODE_INVALIDWDCFG;
 2156              	 .loc 3 1118 0 is_stmt 1
 2157 0608 1F23     	 movs r3,#31
 2158 060a 9EE0     	 b .L89
 2159              	.L146:
1119:../SSC/Src/ecatslv.c ****     }
1120:../SSC/Src/ecatslv.c **** 
1121:../SSC/Src/ecatslv.c ****     if ( bEscIntEnabled && nPdOutputSize != 0 )
 2160              	 .loc 3 1121 0
 2161 060c 534B     	 ldr r3,.L161+8
 2162 060e 1B78     	 ldrb r3,[r3]
 2163 0610 002B     	 cmp r3,#0
 2164 0612 0AD0     	 beq .L147
 2165              	 .loc 3 1121 0 is_stmt 0 discriminator 1
 2166 0614 524B     	 ldr r3,.L161+12
 2167 0616 1B88     	 ldrh r3,[r3]
 2168 0618 002B     	 cmp r3,#0
 2169 061a 06D0     	 beq .L147
1122:../SSC/Src/ecatslv.c ****     {
1123:../SSC/Src/ecatslv.c ****         /* ECAT synchron Mode is active, the Sync Manager Channel 2 event
1124:../SSC/Src/ecatslv.c ****            has to activated in the AL-Event mask register */
1125:../SSC/Src/ecatslv.c ****         u16ALEventMask |= PROCESS_OUTPUT_EVENT;
 2170              	 .loc 3 1125 0 is_stmt 1
 2171 061c 514B     	 ldr r3,.L161+16
 2172 061e 1B88     	 ldrh r3,[r3]
 2173 0620 43F48063 	 orr r3,r3,#1024
 2174 0624 9AB2     	 uxth r2,r3
 2175 0626 4F4B     	 ldr r3,.L161+16
 2176 0628 1A80     	 strh r2,[r3]
 2177              	.L147:
1126:../SSC/Src/ecatslv.c ****     }
1127:../SSC/Src/ecatslv.c **** /*The application ESM function is separated from this function to handle pending transitions*/
1128:../SSC/Src/ecatslv.c **** 
1129:../SSC/Src/ecatslv.c ****     Sync0WdValue = 0;
 2178              	 .loc 3 1129 0
 2179 062a 4F4B     	 ldr r3,.L161+20
 2180 062c 0022     	 movs r2,#0
 2181 062e 1A80     	 strh r2,[r3]
1130:../SSC/Src/ecatslv.c ****     Sync0WdCounter = 0;
 2182              	 .loc 3 1130 0
 2183 0630 4E4B     	 ldr r3,.L161+24
 2184 0632 0022     	 movs r2,#0
 2185 0634 1A80     	 strh r2,[r3]
1131:../SSC/Src/ecatslv.c ****     Sync1WdCounter = 0;
 2186              	 .loc 3 1131 0
 2187 0636 4E4B     	 ldr r3,.L161+28
 2188 0638 0022     	 movs r2,#0
 2189 063a 1A80     	 strh r2,[r3]
1132:../SSC/Src/ecatslv.c ****     Sync1WdValue = 0;
 2190              	 .loc 3 1132 0
 2191 063c 4D4B     	 ldr r3,.L161+32
 2192 063e 0022     	 movs r2,#0
 2193 0640 1A80     	 strh r2,[r3]
1133:../SSC/Src/ecatslv.c ****     bDcRunning = FALSE;
 2194              	 .loc 3 1133 0
 2195 0642 4D4B     	 ldr r3,.L161+36
 2196 0644 0022     	 movs r2,#0
 2197 0646 1A70     	 strb r2,[r3]
1134:../SSC/Src/ecatslv.c ****     bSmSyncSequenceValid = FALSE;
 2198              	 .loc 3 1134 0
 2199 0648 4C4B     	 ldr r3,.L161+40
 2200 064a 0022     	 movs r2,#0
 2201 064c 1A70     	 strb r2,[r3]
1135:../SSC/Src/ecatslv.c ****     i16WaitForPllRunningTimeout = 0;
 2202              	 .loc 3 1135 0
 2203 064e 4C4B     	 ldr r3,.L161+44
 2204 0650 0022     	 movs r2,#0
 2205 0652 1A80     	 strh r2,[r3]
1136:../SSC/Src/ecatslv.c **** 
1137:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ECAT5*/
1138:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16SmEventMissedCounter = 0;
 2206              	 .loc 3 1138 0
 2207 0654 4B4B     	 ldr r3,.L161+48
 2208 0656 0022     	 movs r2,#0
 2209 0658 1A85     	 strh r2,[r3,#40]
1139:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16CycleExceededCounter = 0;
 2210              	 .loc 3 1139 0
 2211 065a 4A4B     	 ldr r3,.L161+48
 2212 065c 0022     	 movs r2,#0
 2213 065e 5A85     	 strh r2,[r3,#42]
1140:../SSC/Src/ecatslv.c ****     sSyncManInPar.u8SyncError = 0;
 2214              	 .loc 3 1140 0
 2215 0660 484B     	 ldr r3,.L161+48
 2216 0662 0022     	 movs r2,#0
 2217 0664 83F84020 	 strb r2,[r3,#64]
1141:../SSC/Src/ecatslv.c **** 
1142:../SSC/Src/ecatslv.c **** 
1143:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16SmEventMissedCounter = 0;
 2218              	 .loc 3 1143 0
 2219 0668 474B     	 ldr r3,.L161+52
 2220 066a 0022     	 movs r2,#0
 2221 066c 1A85     	 strh r2,[r3,#40]
1144:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16CycleExceededCounter = 0;
 2222              	 .loc 3 1144 0
 2223 066e 464B     	 ldr r3,.L161+52
 2224 0670 0022     	 movs r2,#0
 2225 0672 5A85     	 strh r2,[r3,#42]
1145:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u8SyncError = 0;
 2226              	 .loc 3 1145 0
 2227 0674 444B     	 ldr r3,.L161+52
 2228 0676 0022     	 movs r2,#0
 2229 0678 83F84020 	 strb r2,[r3,#64]
1146:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT5*/
1147:../SSC/Src/ecatslv.c **** 
1148:../SSC/Src/ecatslv.c ****     /* calculate the Sync0/Sync1 watchdog timeouts */
1149:../SSC/Src/ecatslv.c ****     if ( (dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0 )
 2230              	 .loc 3 1149 0
 2231 067c FB7D     	 ldrb r3,[r7,#23]
 2232 067e 03F00203 	 and r3,r3,#2
 2233 0682 002B     	 cmp r3,#0
 2234 0684 50D0     	 beq .L148
1150:../SSC/Src/ecatslv.c ****     {
1151:../SSC/Src/ecatslv.c ****         /*calculate the Sync0 Watchdog counter value the minimum value is 1 ms
1152:../SSC/Src/ecatslv.c ****             if the sync0 cycle is greater 500us the Sync0 Wd value is 2*Sycn0 cycle */
1153:../SSC/Src/ecatslv.c ****         if(cycleTimeSync0 == 0)
 2235              	 .loc 3 1153 0
 2236 0686 7B6A     	 ldr r3,[r7,#36]
 2237 0688 002B     	 cmp r3,#0
 2238 068a 03D1     	 bne .L149
1154:../SSC/Src/ecatslv.c ****         {
1155:../SSC/Src/ecatslv.c ****             Sync0WdValue = 0;
 2239              	 .loc 3 1155 0
 2240 068c 364B     	 ldr r3,.L161+20
 2241 068e 0022     	 movs r2,#0
 2242 0690 1A80     	 strh r2,[r3]
 2243 0692 18E0     	 b .L150
 2244              	.L149:
 2245              	.LBB5:
1156:../SSC/Src/ecatslv.c ****         }
1157:../SSC/Src/ecatslv.c ****         else
1158:../SSC/Src/ecatslv.c ****         {
1159:../SSC/Src/ecatslv.c ****             UINT32 Sync0Cycle = cycleTimeSync0/100000;
 2246              	 .loc 3 1159 0
 2247 0694 7B6A     	 ldr r3,[r7,#36]
 2248 0696 5B09     	 lsrs r3,r3,#5
 2249 0698 3C4A     	 ldr r2,.L161+56
 2250 069a A2FB0323 	 umull r2,r3,r2,r3
 2251 069e DB09     	 lsrs r3,r3,#7
 2252 06a0 7B60     	 str r3,[r7,#4]
1160:../SSC/Src/ecatslv.c **** 
1161:../SSC/Src/ecatslv.c ****             if(Sync0Cycle < 5)
 2253              	 .loc 3 1161 0
 2254 06a2 7B68     	 ldr r3,[r7,#4]
 2255 06a4 042B     	 cmp r3,#4
 2256 06a6 03D8     	 bhi .L151
1162:../SSC/Src/ecatslv.c ****             {
1163:../SSC/Src/ecatslv.c ****                 /*Sync0 cycle less than 500us*/
1164:../SSC/Src/ecatslv.c ****                 Sync0WdValue = 1;
 2257              	 .loc 3 1164 0
 2258 06a8 2F4B     	 ldr r3,.L161+20
 2259 06aa 0122     	 movs r2,#1
 2260 06ac 1A80     	 strh r2,[r3]
 2261 06ae 0AE0     	 b .L150
 2262              	.L151:
1165:../SSC/Src/ecatslv.c ****             }
1166:../SSC/Src/ecatslv.c ****             else
1167:../SSC/Src/ecatslv.c ****             {
1168:../SSC/Src/ecatslv.c ****                 Sync0WdValue = (UINT16)(Sync0Cycle*2)/10;
 2263              	 .loc 3 1168 0
 2264 06b0 7B68     	 ldr r3,[r7,#4]
 2265 06b2 9BB2     	 uxth r3,r3
 2266 06b4 5B00     	 lsls r3,r3,#1
 2267 06b6 9BB2     	 uxth r3,r3
 2268 06b8 354A     	 ldr r2,.L161+60
 2269 06ba A2FB0323 	 umull r2,r3,r2,r3
 2270 06be DB08     	 lsrs r3,r3,#3
 2271 06c0 9AB2     	 uxth r2,r3
 2272 06c2 294B     	 ldr r3,.L161+20
 2273 06c4 1A80     	 strh r2,[r3]
 2274              	.L150:
 2275              	.LBE5:
1169:../SSC/Src/ecatslv.c ****             }
1170:../SSC/Src/ecatslv.c ****         }
1171:../SSC/Src/ecatslv.c **** 
1172:../SSC/Src/ecatslv.c ****         /* Calculate also the watchdog time for Sync1*/
1173:../SSC/Src/ecatslv.c ****         if ( (dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0 )
 2276              	 .loc 3 1173 0
 2277 06c6 FB7D     	 ldrb r3,[r7,#23]
 2278 06c8 03F00403 	 and r3,r3,#4
 2279 06cc 002B     	 cmp r3,#0
 2280 06ce 2BD0     	 beq .L148
1174:../SSC/Src/ecatslv.c ****         {
1175:../SSC/Src/ecatslv.c ****             if(shiftTimeSync1 < cycleTimeSync0)
 2281              	 .loc 3 1175 0
 2282 06d0 3A6A     	 ldr r2,[r7,#32]
 2283 06d2 7B6A     	 ldr r3,[r7,#36]
 2284 06d4 9A42     	 cmp r2,r3
 2285 06d6 04D2     	 bcs .L152
1176:../SSC/Src/ecatslv.c ****         {
1177:../SSC/Src/ecatslv.c ****                 /* Sync 1 has the same cycle time than Sync0 (maybe with a shift (shiftTimeSync1 > 
1178:../SSC/Src/ecatslv.c ****                 Sync1WdValue = Sync0WdValue;
 2286              	 .loc 3 1178 0
 2287 06d8 234B     	 ldr r3,.L161+20
 2288 06da 1A88     	 ldrh r2,[r3]
 2289 06dc 254B     	 ldr r3,.L161+32
 2290 06de 1A80     	 strh r2,[r3]
 2291 06e0 22E0     	 b .L148
 2292              	.L152:
 2293              	.LBB6:
1179:../SSC/Src/ecatslv.c ****         }
1180:../SSC/Src/ecatslv.c ****         else
1181:../SSC/Src/ecatslv.c ****         {
1182:../SSC/Src/ecatslv.c ****                 /* Sync1 cycle is larger than Sync0 (e.g. subordinated Sync0 cycles) */
1183:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ECAT4*/
1184:../SSC/Src/ecatslv.c ****                 UINT32 Sync1Cycle = (shiftTimeSync1  + cycleTimeSync0 )/100000;
 2294              	 .loc 3 1184 0
 2295 06e2 3A6A     	 ldr r2,[r7,#32]
 2296 06e4 7B6A     	 ldr r3,[r7,#36]
 2297 06e6 1344     	 add r3,r3,r2
 2298 06e8 5B09     	 lsrs r3,r3,#5
 2299 06ea 284A     	 ldr r2,.L161+56
 2300 06ec A2FB0323 	 umull r2,r3,r2,r3
 2301 06f0 DB09     	 lsrs r3,r3,#7
 2302 06f2 3B60     	 str r3,[r7]
1185:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT4*/
1186:../SSC/Src/ecatslv.c ****                 if(Sync1Cycle < 5)
 2303              	 .loc 3 1186 0
 2304 06f4 3B68     	 ldr r3,[r7]
 2305 06f6 042B     	 cmp r3,#4
 2306 06f8 03D8     	 bhi .L153
1187:../SSC/Src/ecatslv.c ****                 {
1188:../SSC/Src/ecatslv.c ****                     /*Sync0 cycle less than 500us*/
1189:../SSC/Src/ecatslv.c ****                     Sync1WdValue = 1;
 2307              	 .loc 3 1189 0
 2308 06fa 1E4B     	 ldr r3,.L161+32
 2309 06fc 0122     	 movs r2,#1
 2310 06fe 1A80     	 strh r2,[r3]
 2311 0700 08E0     	 b .L154
 2312              	.L153:
1190:../SSC/Src/ecatslv.c ****                 }
1191:../SSC/Src/ecatslv.c ****                 else
1192:../SSC/Src/ecatslv.c ****                 {
1193:../SSC/Src/ecatslv.c ****                     /*ECATCHANGE_START(V5.12)*/
1194:../SSC/Src/ecatslv.c ****                     Sync1WdValue = (UINT16)((Sync1Cycle*2)/10);
 2313              	 .loc 3 1194 0
 2314 0702 3B68     	 ldr r3,[r7]
 2315 0704 5B00     	 lsls r3,r3,#1
 2316 0706 224A     	 ldr r2,.L161+60
 2317 0708 A2FB0323 	 umull r2,r3,r2,r3
 2318 070c DB08     	 lsrs r3,r3,#3
 2319 070e 9AB2     	 uxth r2,r3
 2320 0710 184B     	 ldr r3,.L161+32
 2321 0712 1A80     	 strh r2,[r3]
 2322              	.L154:
1195:../SSC/Src/ecatslv.c ****                     /*ECATCHANGE_END(V5.12)*/
1196:../SSC/Src/ecatslv.c ****                 }
1197:../SSC/Src/ecatslv.c **** 
1198:../SSC/Src/ecatslv.c ****                 /* add one Sync0 cycle because the Sync1 cycle starts on the next Sync0 after the S
1199:../SSC/Src/ecatslv.c ****                 Sync1WdValue += Sync0WdValue/2;
 2323              	 .loc 3 1199 0
 2324 0714 144B     	 ldr r3,.L161+20
 2325 0716 1B88     	 ldrh r3,[r3]
 2326 0718 5B08     	 lsrs r3,r3,#1
 2327 071a 9AB2     	 uxth r2,r3
 2328 071c 154B     	 ldr r3,.L161+32
 2329 071e 1B88     	 ldrh r3,[r3]
 2330 0720 1344     	 add r3,r3,r2
 2331 0722 9AB2     	 uxth r2,r3
 2332 0724 134B     	 ldr r3,.L161+32
 2333 0726 1A80     	 strh r2,[r3]
 2334              	.L148:
 2335              	.LBE6:
1200:../SSC/Src/ecatslv.c ****             }
1201:../SSC/Src/ecatslv.c ****     }
1202:../SSC/Src/ecatslv.c ****     }
1203:../SSC/Src/ecatslv.c **** 
1204:../SSC/Src/ecatslv.c ****     if(nPdOutputSize > 0)
 2336              	 .loc 3 1204 0
 2337 0728 0D4B     	 ldr r3,.L161+12
 2338 072a 1B88     	 ldrh r3,[r3]
 2339 072c 002B     	 cmp r3,#0
 2340 072e 02D0     	 beq .L155
1205:../SSC/Src/ecatslv.c ****     {
1206:../SSC/Src/ecatslv.c ****         EnableSyncManChannel(PROCESS_DATA_OUT);
 2341              	 .loc 3 1206 0
 2342 0730 0220     	 movs r0,#2
 2343 0732 FFF7FEFF 	 bl EnableSyncManChannel
 2344              	.L155:
1207:../SSC/Src/ecatslv.c ****     }
1208:../SSC/Src/ecatslv.c **** 
1209:../SSC/Src/ecatslv.c ****     if(nPdInputSize > 0)
 2345              	 .loc 3 1209 0
 2346 0736 174B     	 ldr r3,.L161+64
 2347 0738 1B88     	 ldrh r3,[r3]
 2348 073a 002B     	 cmp r3,#0
 2349 073c 02D0     	 beq .L156
1210:../SSC/Src/ecatslv.c ****     {
1211:../SSC/Src/ecatslv.c ****         EnableSyncManChannel(PROCESS_DATA_IN);
 2350              	 .loc 3 1211 0
 2351 073e 0320     	 movs r0,#3
 2352 0740 FFF7FEFF 	 bl EnableSyncManChannel
 2353              	.L156:
1212:../SSC/Src/ecatslv.c ****     }
1213:../SSC/Src/ecatslv.c **** 
1214:../SSC/Src/ecatslv.c ****     /*write initial input data*/
1215:../SSC/Src/ecatslv.c ****     PDO_InputMapping();
 2354              	 .loc 3 1215 0
 2355 0744 FFF7FEFF 	 bl PDO_InputMapping
1216:../SSC/Src/ecatslv.c **** 
1217:../SSC/Src/ecatslv.c ****     return ALSTATUSCODE_NOERROR;
 2356              	 .loc 3 1217 0
 2357 0748 0023     	 movs r3,#0
 2358              	.L89:
1218:../SSC/Src/ecatslv.c **** }
 2359              	 .loc 3 1218 0
 2360 074a 1846     	 mov r0,r3
 2361 074c 3837     	 adds r7,r7,#56
 2362              	.LCFI52:
 2363              	 .cfi_def_cfa_offset 8
 2364 074e BD46     	 mov sp,r7
 2365              	.LCFI53:
 2366              	 .cfi_def_cfa_register 13
 2367              	 
 2368 0750 80BD     	 pop {r7,pc}
 2369              	.L162:
 2370 0752 00BF     	 .align 2
 2371              	.L161:
 2372 0754 00000000 	 .word EcatWdValue
 2373 0758 00000000 	 .word bWdTrigger
 2374 075c 00000000 	 .word bEscIntEnabled
 2375 0760 00000000 	 .word nPdOutputSize
 2376 0764 00000000 	 .word u16ALEventMask
 2377 0768 00000000 	 .word Sync0WdValue
 2378 076c 00000000 	 .word Sync0WdCounter
 2379 0770 00000000 	 .word Sync1WdCounter
 2380 0774 00000000 	 .word Sync1WdValue
 2381 0778 00000000 	 .word bDcRunning
 2382 077c 00000000 	 .word bSmSyncSequenceValid
 2383 0780 00000000 	 .word i16WaitForPllRunningTimeout
 2384 0784 00000000 	 .word sSyncManInPar
 2385 0788 00000000 	 .word sSyncManOutPar
 2386 078c C55A7C0A 	 .word 175921861
 2387 0790 CDCCCCCC 	 .word -858993459
 2388 0794 00000000 	 .word nPdInputSize
 2389              	 .cfi_endproc
 2390              	.LFE184:
 2392              	 .section .text.StartOutputHandler,"ax",%progbits
 2393              	 .align 2
 2394              	 .global StartOutputHandler
 2395              	 .thumb
 2396              	 .thumb_func
 2398              	StartOutputHandler:
 2399              	.LFB185:
1219:../SSC/Src/ecatslv.c **** 
1220:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1221:../SSC/Src/ecatslv.c **** /**
1222:../SSC/Src/ecatslv.c ****  \return    AL Status Code (see ecatslv.h ALSTATUSCODE_....)
1223:../SSC/Src/ecatslv.c **** 
1224:../SSC/Src/ecatslv.c ****  \brief    This function is called in case of the state transition from SAFEOP to OP.
1225:../SSC/Src/ecatslv.c ****  \brief  It will be checked if outputs had to be received before switching to OP
1226:../SSC/Src/ecatslv.c ****  \brief  and the state transition would be refused if outputs are missing
1227:../SSC/Src/ecatslv.c **** 
1228:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1229:../SSC/Src/ecatslv.c **** 
1230:../SSC/Src/ecatslv.c **** UINT16 StartOutputHandler(void)
1231:../SSC/Src/ecatslv.c **** {
 2400              	 .loc 3 1231 0
 2401              	 .cfi_startproc
 2402              	 
 2403              	 
 2404              	 
 2405 0000 80B4     	 push {r7}
 2406              	.LCFI54:
 2407              	 .cfi_def_cfa_offset 4
 2408              	 .cfi_offset 7,-4
 2409 0002 83B0     	 sub sp,sp,#12
 2410              	.LCFI55:
 2411              	 .cfi_def_cfa_offset 16
 2412 0004 00AF     	 add r7,sp,#0
 2413              	.LCFI56:
 2414              	 .cfi_def_cfa_register 7
1232:../SSC/Src/ecatslv.c ****     /* by default the SO transition should be completed in AlControlRes().
1233:../SSC/Src/ecatslv.c ****        required to support also masters which starts to send process data after the SO transition w
1234:../SSC/Src/ecatslv.c ****        (if the master don't send process data within "SAFEOP2OPTIMEOUT" the transition is rejected)
1235:../SSC/Src/ecatslv.c ****     UINT16 result = NOERROR_INWORK;
 2415              	 .loc 3 1235 0
 2416 0006 FF23     	 movs r3,#255
 2417 0008 FB80     	 strh r3,[r7,#6]
1236:../SSC/Src/ecatslv.c ****     if(bLocalErrorFlag)
 2418              	 .loc 3 1236 0
 2419 000a 134B     	 ldr r3,.L167
 2420 000c 1B78     	 ldrb r3,[r3]
 2421 000e 002B     	 cmp r3,#0
 2422 0010 02D0     	 beq .L164
1237:../SSC/Src/ecatslv.c ****     {
1238:../SSC/Src/ecatslv.c ****         /*Local error still exists => skip state request to OP and response with "u16LocalErrorCode
1239:../SSC/Src/ecatslv.c ****         return u16LocalErrorCode;
 2423              	 .loc 3 1239 0
 2424 0012 124B     	 ldr r3,.L167+4
 2425 0014 1B88     	 ldrh r3,[r3]
 2426 0016 18E0     	 b .L165
 2427              	.L164:
1240:../SSC/Src/ecatslv.c ****     }
1241:../SSC/Src/ecatslv.c **** /*The application ESM function is separated from this function to handle pending transitions*/
1242:../SSC/Src/ecatslv.c **** 
1243:../SSC/Src/ecatslv.c **** 
1244:../SSC/Src/ecatslv.c ****     /*DC synchronisation is active wait until pll is valid*/
1245:../SSC/Src/ecatslv.c ****     if(bDcSyncActive)
 2428              	 .loc 3 1245 0
 2429 0018 114B     	 ldr r3,.L167+8
 2430 001a 1B78     	 ldrb r3,[r3]
 2431 001c 002B     	 cmp r3,#0
 2432 001e 05D0     	 beq .L166
1246:../SSC/Src/ecatslv.c ****     {
1247:../SSC/Src/ecatslv.c ****         i16WaitForPllRunningTimeout = 200;
 2433              	 .loc 3 1247 0
 2434 0020 104B     	 ldr r3,.L167+12
 2435 0022 C822     	 movs r2,#200
 2436 0024 1A80     	 strh r2,[r3]
1248:../SSC/Src/ecatslv.c **** 
1249:../SSC/Src/ecatslv.c ****         i16WaitForPllRunningCnt = 0;
 2437              	 .loc 3 1249 0
 2438 0026 104B     	 ldr r3,.L167+16
 2439 0028 0022     	 movs r2,#0
 2440 002a 1A80     	 strh r2,[r3]
 2441              	.L166:
1250:../SSC/Src/ecatslv.c ****     }
1251:../SSC/Src/ecatslv.c **** 
1252:../SSC/Src/ecatslv.c **** 
1253:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ECAT5*/
1254:../SSC/Src/ecatslv.c **** 
1255:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16SmEventMissedCounter = 0;
 2442              	 .loc 3 1255 0
 2443 002c 0F4B     	 ldr r3,.L167+20
 2444 002e 0022     	 movs r2,#0
 2445 0030 1A85     	 strh r2,[r3,#40]
1256:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u8SyncError = 0;
 2446              	 .loc 3 1256 0
 2447 0032 0E4B     	 ldr r3,.L167+20
 2448 0034 0022     	 movs r2,#0
 2449 0036 83F84020 	 strb r2,[r3,#64]
1257:../SSC/Src/ecatslv.c **** 
1258:../SSC/Src/ecatslv.c **** 
1259:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16SmEventMissedCounter = 0;
 2450              	 .loc 3 1259 0
 2451 003a 0D4B     	 ldr r3,.L167+24
 2452 003c 0022     	 movs r2,#0
 2453 003e 1A85     	 strh r2,[r3,#40]
1260:../SSC/Src/ecatslv.c ****     sSyncManInPar.u8SyncError = 0;
 2454              	 .loc 3 1260 0
 2455 0040 0B4B     	 ldr r3,.L167+24
 2456 0042 0022     	 movs r2,#0
 2457 0044 83F84020 	 strb r2,[r3,#64]
1261:../SSC/Src/ecatslv.c **** 
1262:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT5*/
1263:../SSC/Src/ecatslv.c **** 
1264:../SSC/Src/ecatslv.c ****     return result;
 2458              	 .loc 3 1264 0
 2459 0048 FB88     	 ldrh r3,[r7,#6]
 2460              	.L165:
1265:../SSC/Src/ecatslv.c **** }
 2461              	 .loc 3 1265 0
 2462 004a 1846     	 mov r0,r3
 2463 004c 0C37     	 adds r7,r7,#12
 2464              	.LCFI57:
 2465              	 .cfi_def_cfa_offset 4
 2466 004e BD46     	 mov sp,r7
 2467              	.LCFI58:
 2468              	 .cfi_def_cfa_register 13
 2469              	 
 2470 0050 5DF8047B 	 ldr r7,[sp],#4
 2471              	.LCFI59:
 2472              	 .cfi_restore 7
 2473              	 .cfi_def_cfa_offset 0
 2474 0054 7047     	 bx lr
 2475              	.L168:
 2476 0056 00BF     	 .align 2
 2477              	.L167:
 2478 0058 00000000 	 .word bLocalErrorFlag
 2479 005c 00000000 	 .word u16LocalErrorCode
 2480 0060 00000000 	 .word bDcSyncActive
 2481 0064 00000000 	 .word i16WaitForPllRunningTimeout
 2482 0068 00000000 	 .word i16WaitForPllRunningCnt
 2483 006c 00000000 	 .word sSyncManOutPar
 2484 0070 00000000 	 .word sSyncManInPar
 2485              	 .cfi_endproc
 2486              	.LFE185:
 2488              	 .section .text.StopOutputHandler,"ax",%progbits
 2489              	 .align 2
 2490              	 .global StopOutputHandler
 2491              	 .thumb
 2492              	 .thumb_func
 2494              	StopOutputHandler:
 2495              	.LFB186:
1266:../SSC/Src/ecatslv.c **** 
1267:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1268:../SSC/Src/ecatslv.c **** /**
1269:../SSC/Src/ecatslv.c ****  \brief    This function is called in case of the state transition from OP to SAFEOP
1270:../SSC/Src/ecatslv.c ****  \brief  the outputs can be set to an application specific safe state,
1271:../SSC/Src/ecatslv.c ****  \brief  the state transition can be delayed by returning NOERROR_INWORK
1272:../SSC/Src/ecatslv.c **** 
1273:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1274:../SSC/Src/ecatslv.c **** 
1275:../SSC/Src/ecatslv.c **** void StopOutputHandler(void)
1276:../SSC/Src/ecatslv.c **** {
 2496              	 .loc 3 1276 0
 2497              	 .cfi_startproc
 2498              	 
 2499              	 
 2500              	 
 2501 0000 80B4     	 push {r7}
 2502              	.LCFI60:
 2503              	 .cfi_def_cfa_offset 4
 2504              	 .cfi_offset 7,-4
 2505 0002 00AF     	 add r7,sp,#0
 2506              	.LCFI61:
 2507              	 .cfi_def_cfa_register 7
1277:../SSC/Src/ecatslv.c ****     /* reset the flags that outputs were received and that the slave is in OP */
1278:../SSC/Src/ecatslv.c ****     bEcatFirstOutputsReceived = FALSE;
 2508              	 .loc 3 1278 0
 2509 0004 044B     	 ldr r3,.L170
 2510 0006 0022     	 movs r2,#0
 2511 0008 1A70     	 strb r2,[r3]
1279:../SSC/Src/ecatslv.c ****     bEcatOutputUpdateRunning = FALSE;
 2512              	 .loc 3 1279 0
 2513 000a 044B     	 ldr r3,.L170+4
 2514 000c 0022     	 movs r2,#0
 2515 000e 1A70     	 strb r2,[r3]
1280:../SSC/Src/ecatslv.c **** }
 2516              	 .loc 3 1280 0
 2517 0010 BD46     	 mov sp,r7
 2518              	.LCFI62:
 2519              	 .cfi_def_cfa_register 13
 2520              	 
 2521 0012 5DF8047B 	 ldr r7,[sp],#4
 2522              	.LCFI63:
 2523              	 .cfi_restore 7
 2524              	 .cfi_def_cfa_offset 0
 2525 0016 7047     	 bx lr
 2526              	.L171:
 2527              	 .align 2
 2528              	.L170:
 2529 0018 00000000 	 .word bEcatFirstOutputsReceived
 2530 001c 00000000 	 .word bEcatOutputUpdateRunning
 2531              	 .cfi_endproc
 2532              	.LFE186:
 2534              	 .section .text.StopInputHandler,"ax",%progbits
 2535              	 .align 2
 2536              	 .global StopInputHandler
 2537              	 .thumb
 2538              	 .thumb_func
 2540              	StopInputHandler:
 2541              	.LFB187:
1281:../SSC/Src/ecatslv.c **** 
1282:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1283:../SSC/Src/ecatslv.c **** /**
1284:../SSC/Src/ecatslv.c ****   \brief    This function is called in case of the state transition from SAFEOP to PREOP
1285:../SSC/Src/ecatslv.c **** 
1286:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1287:../SSC/Src/ecatslv.c **** 
1288:../SSC/Src/ecatslv.c **** void StopInputHandler(void)
1289:../SSC/Src/ecatslv.c **** {
 2542              	 .loc 3 1289 0
 2543              	 .cfi_startproc
 2544              	 
 2545              	 
 2546 0000 80B5     	 push {r7,lr}
 2547              	.LCFI64:
 2548              	 .cfi_def_cfa_offset 8
 2549              	 .cfi_offset 7,-8
 2550              	 .cfi_offset 14,-4
 2551 0002 82B0     	 sub sp,sp,#8
 2552              	.LCFI65:
 2553              	 .cfi_def_cfa_offset 16
 2554 0004 00AF     	 add r7,sp,#0
 2555              	.LCFI66:
 2556              	 .cfi_def_cfa_register 7
1290:../SSC/Src/ecatslv.c ****     if(nPdOutputSize > 0)
 2557              	 .loc 3 1290 0
 2558 0006 344B     	 ldr r3,.L175
 2559 0008 1B88     	 ldrh r3,[r3]
 2560 000a 002B     	 cmp r3,#0
 2561 000c 02D0     	 beq .L173
1291:../SSC/Src/ecatslv.c ****     {
1292:../SSC/Src/ecatslv.c ****         /* disable the Sync Manager Channel 2 (outputs) */
1293:../SSC/Src/ecatslv.c ****         DisableSyncManChannel(PROCESS_DATA_OUT);
 2562              	 .loc 3 1293 0
 2563 000e 0220     	 movs r0,#2
 2564 0010 FFF7FEFF 	 bl DisableSyncManChannel
 2565              	.L173:
1294:../SSC/Src/ecatslv.c ****     }
1295:../SSC/Src/ecatslv.c **** 
1296:../SSC/Src/ecatslv.c ****     if(nPdInputSize > 0)
 2566              	 .loc 3 1296 0
 2567 0014 314B     	 ldr r3,.L175+4
 2568 0016 1B88     	 ldrh r3,[r3]
 2569 0018 002B     	 cmp r3,#0
 2570 001a 02D0     	 beq .L174
1297:../SSC/Src/ecatslv.c ****     {
1298:../SSC/Src/ecatslv.c ****         /*disable Sync Manager 3 (inputs) if no outputs available*/
1299:../SSC/Src/ecatslv.c ****         DisableSyncManChannel(PROCESS_DATA_IN);
 2571              	 .loc 3 1299 0
 2572 001c 0320     	 movs r0,#3
 2573 001e FFF7FEFF 	 bl DisableSyncManChannel
 2574              	.L174:
 2575              	.LBB7:
1300:../SSC/Src/ecatslv.c ****     }
1301:../SSC/Src/ecatslv.c **** 
1302:../SSC/Src/ecatslv.c ****     /* reset the events in the AL Event mask register (0x204) */
1303:../SSC/Src/ecatslv.c ****     {
1304:../SSC/Src/ecatslv.c ****         UINT16 ResetMask = SYNC0_EVENT | SYNC1_EVENT;
 2576              	 .loc 3 1304 0
 2577 0022 0C23     	 movs r3,#12
 2578 0024 FB80     	 strh r3,[r7,#6]
1305:../SSC/Src/ecatslv.c ****         ResetMask |= PROCESS_OUTPUT_EVENT;
 2579              	 .loc 3 1305 0
 2580 0026 FB88     	 ldrh r3,[r7,#6]
 2581 0028 43F48063 	 orr r3,r3,#1024
 2582 002c FB80     	 strh r3,[r7,#6]
1306:../SSC/Src/ecatslv.c ****         ResetMask |= PROCESS_INPUT_EVENT;
 2583              	 .loc 3 1306 0
 2584 002e FB88     	 ldrh r3,[r7,#6]
 2585 0030 43F40063 	 orr r3,r3,#2048
 2586 0034 FB80     	 strh r3,[r7,#6]
1307:../SSC/Src/ecatslv.c **** 
1308:../SSC/Src/ecatslv.c ****     ResetALEventMask( ~(ResetMask) );
 2587              	 .loc 3 1308 0
 2588 0036 FB88     	 ldrh r3,[r7,#6]
 2589 0038 DB43     	 mvns r3,r3
 2590 003a 9BB2     	 uxth r3,r3
 2591 003c 1846     	 mov r0,r3
 2592 003e FFF7FEFF 	 bl ResetALEventMask
 2593              	.LBE7:
1309:../SSC/Src/ecatslv.c ****     }
1310:../SSC/Src/ecatslv.c ****     /* reset the flags */
1311:../SSC/Src/ecatslv.c ****     bEcatFirstOutputsReceived = FALSE;
 2594              	 .loc 3 1311 0
 2595 0042 274B     	 ldr r3,.L175+8
 2596 0044 0022     	 movs r2,#0
 2597 0046 1A70     	 strb r2,[r3]
1312:../SSC/Src/ecatslv.c ****     bEscIntEnabled = FALSE;
 2598              	 .loc 3 1312 0
 2599 0048 264B     	 ldr r3,.L175+12
 2600 004a 0022     	 movs r2,#0
 2601 004c 1A70     	 strb r2,[r3]
1313:../SSC/Src/ecatslv.c **** /*The application ESM function is separated from this function to handle pending transitions*/
1314:../SSC/Src/ecatslv.c **** 
1315:../SSC/Src/ecatslv.c ****     bDcSyncActive = FALSE;
 2602              	 .loc 3 1315 0
 2603 004e 264B     	 ldr r3,.L175+16
 2604 0050 0022     	 movs r2,#0
 2605 0052 1A70     	 strb r2,[r3]
1316:../SSC/Src/ecatslv.c ****     bDcRunning = FALSE;
 2606              	 .loc 3 1316 0
 2607 0054 254B     	 ldr r3,.L175+20
 2608 0056 0022     	 movs r2,#0
 2609 0058 1A70     	 strb r2,[r3]
1317:../SSC/Src/ecatslv.c ****     bSmSyncSequenceValid = FALSE;
 2610              	 .loc 3 1317 0
 2611 005a 254B     	 ldr r3,.L175+24
 2612 005c 0022     	 movs r2,#0
 2613 005e 1A70     	 strb r2,[r3]
1318:../SSC/Src/ecatslv.c ****     u16SmSync0Value = 0;
 2614              	 .loc 3 1318 0
 2615 0060 244B     	 ldr r3,.L175+28
 2616 0062 0022     	 movs r2,#0
 2617 0064 1A80     	 strh r2,[r3]
1319:../SSC/Src/ecatslv.c ****     u16SmSync0Counter = 0;
 2618              	 .loc 3 1319 0
 2619 0066 244B     	 ldr r3,.L175+32
 2620 0068 0022     	 movs r2,#0
 2621 006a 1A80     	 strh r2,[r3]
1320:../SSC/Src/ecatslv.c **** 
1321:../SSC/Src/ecatslv.c ****     Sync0WdValue = 0;
 2622              	 .loc 3 1321 0
 2623 006c 234B     	 ldr r3,.L175+36
 2624 006e 0022     	 movs r2,#0
 2625 0070 1A80     	 strh r2,[r3]
1322:../SSC/Src/ecatslv.c ****     Sync0WdCounter = 0;
 2626              	 .loc 3 1322 0
 2627 0072 234B     	 ldr r3,.L175+40
 2628 0074 0022     	 movs r2,#0
 2629 0076 1A80     	 strh r2,[r3]
1323:../SSC/Src/ecatslv.c ****     Sync1WdCounter = 0;
 2630              	 .loc 3 1323 0
 2631 0078 224B     	 ldr r3,.L175+44
 2632 007a 0022     	 movs r2,#0
 2633 007c 1A80     	 strh r2,[r3]
1324:../SSC/Src/ecatslv.c ****     Sync1WdValue = 0;
 2634              	 .loc 3 1324 0
 2635 007e 224B     	 ldr r3,.L175+48
 2636 0080 0022     	 movs r2,#0
 2637 0082 1A80     	 strh r2,[r3]
1325:../SSC/Src/ecatslv.c ****     LatchInputSync0Value = 0;
 2638              	 .loc 3 1325 0
 2639 0084 214B     	 ldr r3,.L175+52
 2640 0086 0022     	 movs r2,#0
 2641 0088 1A80     	 strh r2,[r3]
1326:../SSC/Src/ecatslv.c ****     LatchInputSync0Counter = 0;
 2642              	 .loc 3 1326 0
 2643 008a 214B     	 ldr r3,.L175+56
 2644 008c 0022     	 movs r2,#0
 2645 008e 1A80     	 strh r2,[r3]
1327:../SSC/Src/ecatslv.c **** 
1328:../SSC/Src/ecatslv.c ****     /*ECATCHANGE_START(V5.12) ECAT5*/
1329:../SSC/Src/ecatslv.c **** 
1330:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16SmEventMissedCounter = 0;
 2646              	 .loc 3 1330 0
 2647 0090 204B     	 ldr r3,.L175+60
 2648 0092 0022     	 movs r2,#0
 2649 0094 1A85     	 strh r2,[r3,#40]
1331:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16CycleExceededCounter = 0;
 2650              	 .loc 3 1331 0
 2651 0096 1F4B     	 ldr r3,.L175+60
 2652 0098 0022     	 movs r2,#0
 2653 009a 5A85     	 strh r2,[r3,#42]
1332:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u8SyncError = 0;
 2654              	 .loc 3 1332 0
 2655 009c 1D4B     	 ldr r3,.L175+60
 2656 009e 0022     	 movs r2,#0
 2657 00a0 83F84020 	 strb r2,[r3,#64]
1333:../SSC/Src/ecatslv.c **** 
1334:../SSC/Src/ecatslv.c **** 
1335:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16SmEventMissedCounter = 0;
 2658              	 .loc 3 1335 0
 2659 00a4 1C4B     	 ldr r3,.L175+64
 2660 00a6 0022     	 movs r2,#0
 2661 00a8 1A85     	 strh r2,[r3,#40]
1336:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16CycleExceededCounter = 0;
 2662              	 .loc 3 1336 0
 2663 00aa 1B4B     	 ldr r3,.L175+64
 2664 00ac 0022     	 movs r2,#0
 2665 00ae 5A85     	 strh r2,[r3,#42]
1337:../SSC/Src/ecatslv.c ****     sSyncManInPar.u8SyncError = 0;
 2666              	 .loc 3 1337 0
 2667 00b0 194B     	 ldr r3,.L175+64
 2668 00b2 0022     	 movs r2,#0
 2669 00b4 83F84020 	 strb r2,[r3,#64]
1338:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT5*/
1339:../SSC/Src/ecatslv.c **** 
1340:../SSC/Src/ecatslv.c ****     i16WaitForPllRunningTimeout = 0;
 2670              	 .loc 3 1340 0
 2671 00b8 184B     	 ldr r3,.L175+68
 2672 00ba 0022     	 movs r2,#0
 2673 00bc 1A80     	 strh r2,[r3]
1341:../SSC/Src/ecatslv.c **** 
1342:../SSC/Src/ecatslv.c ****     bWdTrigger = FALSE;
 2674              	 .loc 3 1342 0
 2675 00be 184B     	 ldr r3,.L175+72
 2676 00c0 0022     	 movs r2,#0
 2677 00c2 1A70     	 strb r2,[r3]
1343:../SSC/Src/ecatslv.c ****     bEcatInputUpdateRunning = FALSE;
 2678              	 .loc 3 1343 0
 2679 00c4 174B     	 ldr r3,.L175+76
 2680 00c6 0022     	 movs r2,#0
 2681 00c8 1A70     	 strb r2,[r3]
1344:../SSC/Src/ecatslv.c **** 
1345:../SSC/Src/ecatslv.c ****     /*Indicate no user specified Sync mode*/
1346:../SSC/Src/ecatslv.c ****     bSyncSetByUser = FALSE;
 2682              	 .loc 3 1346 0
 2683 00ca 174B     	 ldr r3,.L175+80
 2684 00cc 0022     	 movs r2,#0
 2685 00ce 1A70     	 strb r2,[r3]
1347:../SSC/Src/ecatslv.c **** }
 2686              	 .loc 3 1347 0
 2687 00d0 0837     	 adds r7,r7,#8
 2688              	.LCFI67:
 2689              	 .cfi_def_cfa_offset 8
 2690 00d2 BD46     	 mov sp,r7
 2691              	.LCFI68:
 2692              	 .cfi_def_cfa_register 13
 2693              	 
 2694 00d4 80BD     	 pop {r7,pc}
 2695              	.L176:
 2696 00d6 00BF     	 .align 2
 2697              	.L175:
 2698 00d8 00000000 	 .word nPdOutputSize
 2699 00dc 00000000 	 .word nPdInputSize
 2700 00e0 00000000 	 .word bEcatFirstOutputsReceived
 2701 00e4 00000000 	 .word bEscIntEnabled
 2702 00e8 00000000 	 .word bDcSyncActive
 2703 00ec 00000000 	 .word bDcRunning
 2704 00f0 00000000 	 .word bSmSyncSequenceValid
 2705 00f4 00000000 	 .word u16SmSync0Value
 2706 00f8 00000000 	 .word u16SmSync0Counter
 2707 00fc 00000000 	 .word Sync0WdValue
 2708 0100 00000000 	 .word Sync0WdCounter
 2709 0104 00000000 	 .word Sync1WdCounter
 2710 0108 00000000 	 .word Sync1WdValue
 2711 010c 00000000 	 .word LatchInputSync0Value
 2712 0110 00000000 	 .word LatchInputSync0Counter
 2713 0114 00000000 	 .word sSyncManOutPar
 2714 0118 00000000 	 .word sSyncManInPar
 2715 011c 00000000 	 .word i16WaitForPllRunningTimeout
 2716 0120 00000000 	 .word bWdTrigger
 2717 0124 00000000 	 .word bEcatInputUpdateRunning
 2718 0128 00000000 	 .word bSyncSetByUser
 2719              	 .cfi_endproc
 2720              	.LFE187:
 2722              	 .section .text.BackToInitTransition,"ax",%progbits
 2723              	 .align 2
 2724              	 .global BackToInitTransition
 2725              	 .thumb
 2726              	 .thumb_func
 2728              	BackToInitTransition:
 2729              	.LFB188:
1348:../SSC/Src/ecatslv.c **** 
1349:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1350:../SSC/Src/ecatslv.c **** /**
1351:../SSC/Src/ecatslv.c **** \brief    This function is called when a X to Init transition is completed
1352:../SSC/Src/ecatslv.c **** 
1353:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1354:../SSC/Src/ecatslv.c **** 
1355:../SSC/Src/ecatslv.c **** void BackToInitTransition(void)
1356:../SSC/Src/ecatslv.c **** {
 2730              	 .loc 3 1356 0
 2731              	 .cfi_startproc
 2732              	 
 2733              	 
 2734              	 
 2735 0000 80B4     	 push {r7}
 2736              	.LCFI69:
 2737              	 .cfi_def_cfa_offset 4
 2738              	 .cfi_offset 7,-4
 2739 0002 00AF     	 add r7,sp,#0
 2740              	.LCFI70:
 2741              	 .cfi_def_cfa_register 7
1357:../SSC/Src/ecatslv.c ****     /* Reset indication that the user has written a sync mode*/
1358:../SSC/Src/ecatslv.c ****     bSyncSetByUser = FALSE;
 2742              	 .loc 3 1358 0
 2743 0004 034B     	 ldr r3,.L178
 2744 0006 0022     	 movs r2,#0
 2745 0008 1A70     	 strb r2,[r3]
1359:../SSC/Src/ecatslv.c **** }
 2746              	 .loc 3 1359 0
 2747 000a BD46     	 mov sp,r7
 2748              	.LCFI71:
 2749              	 .cfi_def_cfa_register 13
 2750              	 
 2751 000c 5DF8047B 	 ldr r7,[sp],#4
 2752              	.LCFI72:
 2753              	 .cfi_restore 7
 2754              	 .cfi_def_cfa_offset 0
 2755 0010 7047     	 bx lr
 2756              	.L179:
 2757 0012 00BF     	 .align 2
 2758              	.L178:
 2759 0014 00000000 	 .word bSyncSetByUser
 2760              	 .cfi_endproc
 2761              	.LFE188:
 2763              	 .section .text.SetALStatus,"ax",%progbits
 2764              	 .align 2
 2765              	 .global SetALStatus
 2766              	 .thumb
 2767              	 .thumb_func
 2769              	SetALStatus:
 2770              	.LFB189:
1360:../SSC/Src/ecatslv.c **** 
1361:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1362:../SSC/Src/ecatslv.c **** /**
1363:../SSC/Src/ecatslv.c ****  \param alStatus        New AL Status (written to register 0x130)
1364:../SSC/Src/ecatslv.c ****  \param alStatusCode    New AL Status Code (written to register 0x134)
1365:../SSC/Src/ecatslv.c **** 
1366:../SSC/Src/ecatslv.c ****   \brief  The function changes the state of the EtherCAT ASIC to the requested.
1367:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1368:../SSC/Src/ecatslv.c **** void SetALStatus(UINT8 alStatus, UINT16 alStatusCode)
1369:../SSC/Src/ecatslv.c **** {
 2771              	 .loc 3 1369 0
 2772              	 .cfi_startproc
 2773              	 
 2774              	 
 2775              	 
 2776 0000 80B4     	 push {r7}
 2777              	.LCFI73:
 2778              	 .cfi_def_cfa_offset 4
 2779              	 .cfi_offset 7,-4
 2780 0002 85B0     	 sub sp,sp,#20
 2781              	.LCFI74:
 2782              	 .cfi_def_cfa_offset 24
 2783 0004 00AF     	 add r7,sp,#0
 2784              	.LCFI75:
 2785              	 .cfi_def_cfa_register 7
 2786 0006 0346     	 mov r3,r0
 2787 0008 0A46     	 mov r2,r1
 2788 000a FB71     	 strb r3,[r7,#7]
 2789 000c 1346     	 mov r3,r2
 2790 000e BB80     	 strh r3,[r7,#4]
1370:../SSC/Src/ecatslv.c ****     UINT16 Value = alStatusCode;
 2791              	 .loc 3 1370 0
 2792 0010 BB88     	 ldrh r3,[r7,#4]
 2793 0012 FB81     	 strh r3,[r7,#14]
1371:../SSC/Src/ecatslv.c **** 
1372:../SSC/Src/ecatslv.c ****     /*update global status variable if required*/
1373:../SSC/Src/ecatslv.c ****     if(nAlStatus != alStatus)
 2794              	 .loc 3 1373 0
 2795 0014 264B     	 ldr r3,.L189
 2796 0016 1B78     	 ldrb r3,[r3]
 2797 0018 FA79     	 ldrb r2,[r7,#7]
 2798 001a 9A42     	 cmp r2,r3
 2799 001c 02D0     	 beq .L181
1374:../SSC/Src/ecatslv.c ****     {
1375:../SSC/Src/ecatslv.c ****         nAlStatus = alStatus;
 2800              	 .loc 3 1375 0
 2801 001e 244A     	 ldr r2,.L189
 2802 0020 FB79     	 ldrb r3,[r7,#7]
 2803 0022 1370     	 strb r3,[r2]
 2804              	.L181:
1376:../SSC/Src/ecatslv.c ****     }
1377:../SSC/Src/ecatslv.c **** 
1378:../SSC/Src/ecatslv.c **** 
1379:../SSC/Src/ecatslv.c ****     if (alStatusCode != 0xFFFF)
 2805              	 .loc 3 1379 0
 2806 0024 BB88     	 ldrh r3,[r7,#4]
 2807 0026 4FF6FF72 	 movw r2,#65535
 2808 002a 9342     	 cmp r3,r2
 2809 002c 02D0     	 beq .L182
1380:../SSC/Src/ecatslv.c ****     {
1381:../SSC/Src/ecatslv.c ****         Value = SWAPWORD(Value);
1382:../SSC/Src/ecatslv.c **** 
1383:../SSC/Src/ecatslv.c ****         HW_EscWriteWord(Value,ESC_AL_STATUS_CODE_OFFSET);
 2810              	 .loc 3 1383 0
 2811 002e 214A     	 ldr r2,.L189+4
 2812 0030 FB89     	 ldrh r3,[r7,#14]
 2813 0032 1380     	 strh r3,[r2]
 2814              	.L182:
1384:../SSC/Src/ecatslv.c ****     }
1385:../SSC/Src/ecatslv.c **** 
1386:../SSC/Src/ecatslv.c ****     Value = nAlStatus;
 2815              	 .loc 3 1386 0
 2816 0034 1E4B     	 ldr r3,.L189
 2817 0036 1B78     	 ldrb r3,[r3]
 2818 0038 FB81     	 strh r3,[r7,#14]
1387:../SSC/Src/ecatslv.c ****     Value = SWAPWORD(Value);
1388:../SSC/Src/ecatslv.c ****     HW_EscWriteWord(Value,ESC_AL_STATUS_OFFSET);
 2819              	 .loc 3 1388 0
 2820 003a 1F4A     	 ldr r2,.L189+8
 2821 003c FB89     	 ldrh r3,[r7,#14]
 2822 003e 1380     	 strh r3,[r2]
1389:../SSC/Src/ecatslv.c **** 
1390:../SSC/Src/ecatslv.c ****     /*The Run LED state is set in Set LED Indication, only the Error LED blink code is set here*/
1391:../SSC/Src/ecatslv.c **** 
1392:../SSC/Src/ecatslv.c ****     /*set Error blink code*/
1393:../SSC/Src/ecatslv.c ****     if(alStatusCode == 0x00 || !(alStatus & STATE_CHANGE))
 2823              	 .loc 3 1393 0
 2824 0040 BB88     	 ldrh r3,[r7,#4]
 2825 0042 002B     	 cmp r3,#0
 2826 0044 04D0     	 beq .L183
 2827              	 .loc 3 1393 0 is_stmt 0 discriminator 1
 2828 0046 FB79     	 ldrb r3,[r7,#7]
 2829 0048 03F01003 	 and r3,r3,#16
 2830 004c 002B     	 cmp r3,#0
 2831 004e 03D1     	 bne .L184
 2832              	.L183:
1394:../SSC/Src/ecatslv.c ****     {
1395:../SSC/Src/ecatslv.c ****         u8EcatErrorLed = LED_OFF;
 2833              	 .loc 3 1395 0 is_stmt 1
 2834 0050 1A4B     	 ldr r3,.L189+12
 2835 0052 0022     	 movs r2,#0
 2836 0054 1A70     	 strb r2,[r3]
 2837 0056 1AE0     	 b .L185
 2838              	.L184:
1396:../SSC/Src/ecatslv.c ****     }
1397:../SSC/Src/ecatslv.c ****     else if((alStatusCode == ALSTATUSCODE_NOSYNCERROR) ||
 2839              	 .loc 3 1397 0
 2840 0058 BB88     	 ldrh r3,[r7,#4]
 2841 005a 2D2B     	 cmp r3,#45
 2842 005c 09D0     	 beq .L186
 2843              	 .loc 3 1397 0 is_stmt 0 discriminator 1
 2844 005e BB88     	 ldrh r3,[r7,#4]
 2845 0060 1A2B     	 cmp r3,#26
 2846 0062 06D0     	 beq .L186
1398:../SSC/Src/ecatslv.c ****         (alStatusCode == ALSTATUSCODE_SYNCERROR) ||
 2847              	 .loc 3 1398 0 is_stmt 1
 2848 0064 BB88     	 ldrh r3,[r7,#4]
 2849 0066 322B     	 cmp r3,#50
 2850 0068 03D0     	 beq .L186
1399:../SSC/Src/ecatslv.c ****         (alStatusCode == ALSTATUSCODE_DCPLLSYNCERROR)
1400:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ECAT7*/
1401:../SSC/Src/ecatslv.c ****         || (bLocalErrorFlag == TRUE))
 2851              	 .loc 3 1401 0
 2852 006a 154B     	 ldr r3,.L189+16
 2853 006c 1B78     	 ldrb r3,[r3]
 2854 006e 002B     	 cmp r3,#0
 2855 0070 03D0     	 beq .L187
 2856              	.L186:
1402:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT7*/
1403:../SSC/Src/ecatslv.c ****     {
1404:../SSC/Src/ecatslv.c ****         u8EcatErrorLed = LED_SINGLEFLASH;
 2857              	 .loc 3 1404 0
 2858 0072 124B     	 ldr r3,.L189+12
 2859 0074 0122     	 movs r2,#1
 2860 0076 1A70     	 strb r2,[r3]
 2861 0078 09E0     	 b .L185
 2862              	.L187:
1405:../SSC/Src/ecatslv.c ****     }
1406:../SSC/Src/ecatslv.c ****     else if((alStatusCode == ALSTATUSCODE_SMWATCHDOG))
 2863              	 .loc 3 1406 0
 2864 007a BB88     	 ldrh r3,[r7,#4]
 2865 007c 1B2B     	 cmp r3,#27
 2866 007e 03D1     	 bne .L188
1407:../SSC/Src/ecatslv.c ****     {
1408:../SSC/Src/ecatslv.c ****         u8EcatErrorLed = LED_DOUBLEFLASH;
 2867              	 .loc 3 1408 0
 2868 0080 0E4B     	 ldr r3,.L189+12
 2869 0082 0222     	 movs r2,#2
 2870 0084 1A70     	 strb r2,[r3]
 2871 0086 02E0     	 b .L185
 2872              	.L188:
1409:../SSC/Src/ecatslv.c ****     }
1410:../SSC/Src/ecatslv.c ****     else
1411:../SSC/Src/ecatslv.c ****     {
1412:../SSC/Src/ecatslv.c ****         u8EcatErrorLed = LED_BLINKING;
 2873              	 .loc 3 1412 0
 2874 0088 0C4B     	 ldr r3,.L189+12
 2875 008a 0D22     	 movs r2,#13
 2876 008c 1A70     	 strb r2,[r3]
 2877              	.L185:
1413:../SSC/Src/ecatslv.c ****     }
1414:../SSC/Src/ecatslv.c ****     u8EcatErrorLed |= LED_OVERRIDE;
 2878              	 .loc 3 1414 0
 2879 008e 0B4B     	 ldr r3,.L189+12
 2880 0090 1B78     	 ldrb r3,[r3]
 2881 0092 43F01003 	 orr r3,r3,#16
 2882 0096 DAB2     	 uxtb r2,r3
 2883 0098 084B     	 ldr r3,.L189+12
 2884 009a 1A70     	 strb r2,[r3]
1415:../SSC/Src/ecatslv.c **** 
1416:../SSC/Src/ecatslv.c ****     HW_EscWriteByte(u8EcatErrorLed,ESC_ERROR_LED_OVERRIDE);
 2885              	 .loc 3 1416 0
 2886 009c 094B     	 ldr r3,.L189+20
 2887 009e 074A     	 ldr r2,.L189+12
 2888 00a0 1278     	 ldrb r2,[r2]
 2889 00a2 1A70     	 strb r2,[r3]
1417:../SSC/Src/ecatslv.c **** }
 2890              	 .loc 3 1417 0
 2891 00a4 1437     	 adds r7,r7,#20
 2892              	.LCFI76:
 2893              	 .cfi_def_cfa_offset 4
 2894 00a6 BD46     	 mov sp,r7
 2895              	.LCFI77:
 2896              	 .cfi_def_cfa_register 13
 2897              	 
 2898 00a8 5DF8047B 	 ldr r7,[sp],#4
 2899              	.LCFI78:
 2900              	 .cfi_restore 7
 2901              	 .cfi_def_cfa_offset 0
 2902 00ac 7047     	 bx lr
 2903              	.L190:
 2904 00ae 00BF     	 .align 2
 2905              	.L189:
 2906 00b0 00000000 	 .word nAlStatus
 2907 00b4 34010154 	 .word 1409351988
 2908 00b8 30010154 	 .word 1409351984
 2909 00bc 00000000 	 .word u8EcatErrorLed
 2910 00c0 00000000 	 .word bLocalErrorFlag
 2911 00c4 39010154 	 .word 1409351993
 2912              	 .cfi_endproc
 2913              	.LFE189:
 2915              	 .section .text.AL_ControlInd,"ax",%progbits
 2916              	 .align 2
 2917              	 .global AL_ControlInd
 2918              	 .thumb
 2919              	 .thumb_func
 2921              	AL_ControlInd:
 2922              	.LFB190:
1418:../SSC/Src/ecatslv.c **** 
1419:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1420:../SSC/Src/ecatslv.c **** /**
1421:../SSC/Src/ecatslv.c ****  \param    alControl        requested new state
1422:../SSC/Src/ecatslv.c ****  \param alStatusCode    requested status code
1423:../SSC/Src/ecatslv.c **** 
1424:../SSC/Src/ecatslv.c ****  \brief    This function handles the EtherCAT State Machine. It is called
1425:../SSC/Src/ecatslv.c ****             * in case of an AL Control event (Bit 0 of AL-Event (Reg 0x220),
1426:../SSC/Src/ecatslv.c ****                when the Master has written the AL Control Register (from ECAT_Main),
1427:../SSC/Src/ecatslv.c ****               alControl contains the content of the AL Control (Reg 0x120)
1428:../SSC/Src/ecatslv.c ****             * in case of a SM-Change event (Bit 4 of AL-Event (Reg 0x220)),
1429:../SSC/Src/ecatslv.c ****               when an Activate SYNCM y register is written by the master (from ECAT_Main),
1430:../SSC/Src/ecatslv.c ****               alControl contains the actual state (Bit 0-3 of AL Status (Reg 0x130))
1431:../SSC/Src/ecatslv.c ****             * in case of a locally expired watchdog (from ECAT_Main),
1432:../SSC/Src/ecatslv.c ****               alControl contains the requested new state (SAFE_OP)
1433:../SSC/Src/ecatslv.c ****             * in case of an application specific event to change the EtherCAT state (from applicati
1434:../SSC/Src/ecatslv.c ****               alControl contains the requested new state (INIT, PRE_OP or SAFE_OP)
1435:../SSC/Src/ecatslv.c **** 
1436:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1437:../SSC/Src/ecatslv.c **** 
1438:../SSC/Src/ecatslv.c **** void AL_ControlInd(UINT8 alControl, UINT16 alStatusCode)
1439:../SSC/Src/ecatslv.c **** {
 2923              	 .loc 3 1439 0
 2924              	 .cfi_startproc
 2925              	 
 2926              	 
 2927 0000 80B5     	 push {r7,lr}
 2928              	.LCFI79:
 2929              	 .cfi_def_cfa_offset 8
 2930              	 .cfi_offset 7,-8
 2931              	 .cfi_offset 14,-4
 2932 0002 84B0     	 sub sp,sp,#16
 2933              	.LCFI80:
 2934              	 .cfi_def_cfa_offset 24
 2935 0004 00AF     	 add r7,sp,#0
 2936              	.LCFI81:
 2937              	 .cfi_def_cfa_register 7
 2938 0006 0346     	 mov r3,r0
 2939 0008 0A46     	 mov r2,r1
 2940 000a FB71     	 strb r3,[r7,#7]
 2941 000c 1346     	 mov r3,r2
 2942 000e BB80     	 strh r3,[r7,#4]
1440:../SSC/Src/ecatslv.c ****     UINT16        result = 0;
 2943              	 .loc 3 1440 0
 2944 0010 0023     	 movs r3,#0
 2945 0012 FB81     	 strh r3,[r7,#14]
1441:../SSC/Src/ecatslv.c ****     UINT8            bErrAck = 0;
 2946              	 .loc 3 1441 0
 2947 0014 0023     	 movs r3,#0
 2948 0016 7B73     	 strb r3,[r7,#13]
1442:../SSC/Src/ecatslv.c ****     UINT8         stateTrans;
1443:../SSC/Src/ecatslv.c ****     /*deactivate ESM timeout counter*/
1444:../SSC/Src/ecatslv.c ****     EsmTimeoutCounter = -1;
 2949              	 .loc 3 1444 0
 2950 0018 BD4B     	 ldr r3,.L264
 2951 001a 4FF6FF72 	 movw r2,#65535
 2952 001e 1A80     	 strh r2,[r3]
1445:../SSC/Src/ecatslv.c ****     bApplEsmPending = TRUE;
 2953              	 .loc 3 1445 0
 2954 0020 BC4B     	 ldr r3,.L264+4
 2955 0022 0122     	 movs r2,#1
 2956 0024 1A70     	 strb r2,[r3]
1446:../SSC/Src/ecatslv.c **** 
1447:../SSC/Src/ecatslv.c ****     /* reset the Error Flag in case of acknowledge by the Master */
1448:../SSC/Src/ecatslv.c ****     if ( alControl & STATE_CHANGE )
 2957              	 .loc 3 1448 0
 2958 0026 FB79     	 ldrb r3,[r7,#7]
 2959 0028 03F01003 	 and r3,r3,#16
 2960 002c 002B     	 cmp r3,#0
 2961 002e 09D0     	 beq .L192
1449:../SSC/Src/ecatslv.c ****     {
1450:../SSC/Src/ecatslv.c ****         bErrAck = 1;
 2962              	 .loc 3 1450 0
 2963 0030 0123     	 movs r3,#1
 2964 0032 7B73     	 strb r3,[r7,#13]
1451:../SSC/Src/ecatslv.c ****         nAlStatus &= ~STATE_CHANGE;
 2965              	 .loc 3 1451 0
 2966 0034 B84B     	 ldr r3,.L264+8
 2967 0036 1B78     	 ldrb r3,[r3]
 2968 0038 23F01003 	 bic r3,r3,#16
 2969 003c DAB2     	 uxtb r2,r3
 2970 003e B64B     	 ldr r3,.L264+8
 2971 0040 1A70     	 strb r2,[r3]
 2972 0042 12E0     	 b .L193
 2973              	.L192:
1452:../SSC/Src/ecatslv.c ****         /*enable SM2 is moved to state transition block. First check SM Settings.*/
1453:../SSC/Src/ecatslv.c ****     }
1454:../SSC/Src/ecatslv.c ****     else if ((nAlStatus & STATE_CHANGE)
 2974              	 .loc 3 1454 0
 2975 0044 B44B     	 ldr r3,.L264+8
 2976 0046 1B78     	 ldrb r3,[r3]
 2977 0048 03F01003 	 and r3,r3,#16
 2978 004c 002B     	 cmp r3,#0
 2979 004e 05D0     	 beq .L194
1455:../SSC/Src/ecatslv.c ****         // HBu 17.04.08: the error has to be acknowledged before when sending the same (or a higher
1456:../SSC/Src/ecatslv.c ****         //               (the error was acknowledged with the same state before independent of the 
1457:../SSC/Src/ecatslv.c ****         /*Error Acknowledge with 0xX1 is allowed*/
1458:../SSC/Src/ecatslv.c ****         && (alControl & STATE_MASK) != STATE_INIT)
 2980              	 .loc 3 1458 0
 2981 0050 FB79     	 ldrb r3,[r7,#7]
 2982 0052 03F00F03 	 and r3,r3,#15
 2983 0056 012B     	 cmp r3,#1
 2984 0058 00D0     	 beq .L194
1459:../SSC/Src/ecatslv.c ****     {
1460:../SSC/Src/ecatslv.c ****         /* the error flag (Bit 4) is set in the AL-Status and the ErrAck bit (Bit 4)
1461:../SSC/Src/ecatslv.c ****            is not set in the AL-Control, so the state cannot be set to a higher state
1462:../SSC/Src/ecatslv.c ****            and the new state request will be ignored */
1463:../SSC/Src/ecatslv.c ****         return;
 2985              	 .loc 3 1463 0
 2986 005a 7AE3     	 b .L191
 2987              	.L194:
1464:../SSC/Src/ecatslv.c ****     }
1465:../SSC/Src/ecatslv.c ****     else
1466:../SSC/Src/ecatslv.c ****     {
1467:../SSC/Src/ecatslv.c ****         nAlStatus &= STATE_MASK;
 2988              	 .loc 3 1467 0
 2989 005c AE4B     	 ldr r3,.L264+8
 2990 005e 1B78     	 ldrb r3,[r3]
 2991 0060 03F00F03 	 and r3,r3,#15
 2992 0064 DAB2     	 uxtb r2,r3
 2993 0066 AC4B     	 ldr r3,.L264+8
 2994 0068 1A70     	 strb r2,[r3]
 2995              	.L193:
1468:../SSC/Src/ecatslv.c ****     }
1469:../SSC/Src/ecatslv.c **** 
1470:../SSC/Src/ecatslv.c ****     /* generate a variable for the state transition
1471:../SSC/Src/ecatslv.c ****       (Bit 0-3: new state (AL Control), Bit 4-7: old state (AL Status) */
1472:../SSC/Src/ecatslv.c ****     alControl &= STATE_MASK;
 2996              	 .loc 3 1472 0
 2997 006a FB79     	 ldrb r3,[r7,#7]
 2998 006c 03F00F03 	 and r3,r3,#15
 2999 0070 FB71     	 strb r3,[r7,#7]
1473:../SSC/Src/ecatslv.c ****     stateTrans = nAlStatus;
 3000              	 .loc 3 1473 0
 3001 0072 A94B     	 ldr r3,.L264+8
 3002 0074 1B78     	 ldrb r3,[r3]
 3003 0076 3B73     	 strb r3,[r7,#12]
1474:../SSC/Src/ecatslv.c ****     stateTrans <<= 4;
 3004              	 .loc 3 1474 0
 3005 0078 3B7B     	 ldrb r3,[r7,#12]
 3006 007a 1B01     	 lsls r3,r3,#4
 3007 007c 3B73     	 strb r3,[r7,#12]
1475:../SSC/Src/ecatslv.c ****     stateTrans += alControl;
 3008              	 .loc 3 1475 0
 3009 007e 3A7B     	 ldrb r2,[r7,#12]
 3010 0080 FB79     	 ldrb r3,[r7,#7]
 3011 0082 1344     	 add r3,r3,r2
 3012 0084 3B73     	 strb r3,[r7,#12]
1476:../SSC/Src/ecatslv.c **** 
1477:../SSC/Src/ecatslv.c ****     /* check the SYNCM settings depending on the state transition */
1478:../SSC/Src/ecatslv.c ****     switch ( stateTrans )
 3013              	 .loc 3 1478 0
 3014 0086 3B7B     	 ldrb r3,[r7,#12]
 3015 0088 442B     	 cmp r3,#68
 3016 008a 29D0     	 beq .L197
 3017 008c 442B     	 cmp r3,#68
 3018 008e 0BDC     	 bgt .L198
 3019 0090 222B     	 cmp r3,#34
 3020 0092 15D0     	 beq .L199
 3021 0094 222B     	 cmp r3,#34
 3022 0096 02DC     	 bgt .L200
 3023 0098 122B     	 cmp r3,#18
 3024 009a 11D0     	 beq .L199
 3025 009c 28E0     	 b .L196
 3026              	.L200:
 3027 009e 242B     	 cmp r3,#36
 3028 00a0 14D0     	 beq .L201
 3029 00a2 422B     	 cmp r3,#66
 3030 00a4 0CD0     	 beq .L199
 3031 00a6 23E0     	 b .L196
 3032              	.L198:
 3033 00a8 822B     	 cmp r3,#130
 3034 00aa 09D0     	 beq .L199
 3035 00ac 822B     	 cmp r3,#130
 3036 00ae 02DC     	 bgt .L202
 3037 00b0 482B     	 cmp r3,#72
 3038 00b2 15D0     	 beq .L197
 3039 00b4 1CE0     	 b .L196
 3040              	.L202:
 3041 00b6 842B     	 cmp r3,#132
 3042 00b8 12D0     	 beq .L197
 3043 00ba 882B     	 cmp r3,#136
 3044 00bc 10D0     	 beq .L197
 3045 00be 17E0     	 b .L196
 3046              	.L199:
1479:../SSC/Src/ecatslv.c ****     {
1480:../SSC/Src/ecatslv.c ****     case INIT_2_PREOP:
1481:../SSC/Src/ecatslv.c ****     case OP_2_PREOP:
1482:../SSC/Src/ecatslv.c ****     case SAFEOP_2_PREOP:
1483:../SSC/Src/ecatslv.c ****     case PREOP_2_PREOP:
1484:../SSC/Src/ecatslv.c ****         /* in PREOP only the SYNCM settings for SYNCM0 and SYNCM1 (mailbox)
1485:../SSC/Src/ecatslv.c ****            are checked, if result is unequal 0, the slave will stay in or
1486:../SSC/Src/ecatslv.c ****            switch to INIT and set the ErrorInd Bit (bit 4) of the AL-Status */
1487:../SSC/Src/ecatslv.c ****         result = CheckSmSettings(MAILBOX_READ+1);
 3047              	 .loc 3 1487 0
 3048 00c0 0220     	 movs r0,#2
 3049 00c2 FFF7FEFF 	 bl CheckSmSettings
 3050 00c6 0346     	 mov r3,r0
 3051 00c8 FB81     	 strh r3,[r7,#14]
1488:../SSC/Src/ecatslv.c ****         break;
 3052              	 .loc 3 1488 0
 3053 00ca 11E0     	 b .L196
 3054              	.L201:
1489:../SSC/Src/ecatslv.c ****     case PREOP_2_SAFEOP:
1490:../SSC/Src/ecatslv.c ****         {
1491:../SSC/Src/ecatslv.c ****         /* before checking the SYNCM settings for SYNCM2 and SYNCM3 (process data)
1492:../SSC/Src/ecatslv.c ****            the expected length of input data (nPdInputSize) and output data (nPdOutputSize)
1493:../SSC/Src/ecatslv.c ****             could be adapted (changed by PDO-Assign and/or PDO-Mapping)
1494:../SSC/Src/ecatslv.c ****             if result is unequal 0, the slave will stay in PREOP and set
1495:../SSC/Src/ecatslv.c ****             the ErrorInd Bit (bit 4) of the AL-Status */
1496:../SSC/Src/ecatslv.c ****         result = APPL_GenerateMapping(&nPdInputSize,&nPdOutputSize);
 3055              	 .loc 3 1496 0
 3056 00cc 9348     	 ldr r0,.L264+12
 3057 00ce 9449     	 ldr r1,.L264+16
 3058 00d0 FFF7FEFF 	 bl APPL_GenerateMapping
 3059 00d4 0346     	 mov r3,r0
 3060 00d6 FB81     	 strh r3,[r7,#14]
1497:../SSC/Src/ecatslv.c **** 
1498:../SSC/Src/ecatslv.c ****             if (result != 0)
 3061              	 .loc 3 1498 0
 3062 00d8 FB89     	 ldrh r3,[r7,#14]
 3063 00da 002B     	 cmp r3,#0
 3064 00dc 00D0     	 beq .L197
1499:../SSC/Src/ecatslv.c ****             {
1500:../SSC/Src/ecatslv.c ****                 break;
 3065              	 .loc 3 1500 0
 3066 00de 07E0     	 b .L196
 3067              	.L197:
1501:../SSC/Src/ecatslv.c ****             }
1502:../SSC/Src/ecatslv.c ****         }
1503:../SSC/Src/ecatslv.c ****     case SAFEOP_2_OP:
1504:../SSC/Src/ecatslv.c ****     case OP_2_SAFEOP:
1505:../SSC/Src/ecatslv.c ****     case SAFEOP_2_SAFEOP:
1506:../SSC/Src/ecatslv.c ****     case OP_2_OP:
1507:../SSC/Src/ecatslv.c ****         /* in SAFEOP or OP the SYNCM settings for all SYNCM are checked
1508:../SSC/Src/ecatslv.c ****            if result is unequal 0, the slave will stay in or
1509:../SSC/Src/ecatslv.c ****            switch to PREOP and set the ErrorInd Bit (bit 4) of the AL-Status */
1510:../SSC/Src/ecatslv.c ****         result = CheckSmSettings(nMaxSyncMan);
 3068              	 .loc 3 1510 0
 3069 00e0 904B     	 ldr r3,.L264+20
 3070 00e2 1B78     	 ldrb r3,[r3]
 3071 00e4 1846     	 mov r0,r3
 3072 00e6 FFF7FEFF 	 bl CheckSmSettings
 3073 00ea 0346     	 mov r3,r0
 3074 00ec FB81     	 strh r3,[r7,#14]
1511:../SSC/Src/ecatslv.c ****         break;
 3075              	 .loc 3 1511 0
 3076 00ee 00BF     	 nop
 3077              	.L196:
1512:../SSC/Src/ecatslv.c **** 
1513:../SSC/Src/ecatslv.c ****     }
1514:../SSC/Src/ecatslv.c **** 
1515:../SSC/Src/ecatslv.c ****     if ( result == 0 )
 3078              	 .loc 3 1515 0
 3079 00f0 FB89     	 ldrh r3,[r7,#14]
 3080 00f2 002B     	 cmp r3,#0
 3081 00f4 40F05C82 	 bne .L203
1516:../SSC/Src/ecatslv.c ****     {
1517:../SSC/Src/ecatslv.c ****         /* execute the corresponding local management service(s) depending on the state transition 
1518:../SSC/Src/ecatslv.c ****         nEcatStateTrans = 0;
 3082              	 .loc 3 1518 0
 3083 00f8 8B4B     	 ldr r3,.L264+24
 3084 00fa 0022     	 movs r2,#0
 3085 00fc 1A80     	 strh r2,[r3]
1519:../SSC/Src/ecatslv.c ****         switch ( stateTrans )
 3086              	 .loc 3 1519 0
 3087 00fe 3B7B     	 ldrb r3,[r7,#12]
 3088 0100 113B     	 subs r3,r3,#17
 3089 0102 772B     	 cmp r3,#119
 3090 0104 00F25082 	 bhi .L204
 3091 0108 01A2     	 adr r2,.L206
 3092 010a 52F823F0 	 ldr pc,[r2,r3,lsl#2]
 3093 010e 00BF     	 .p2align 2
 3094              	.L206:
 3095 0110 5F050000 	 .word .L205+1
 3096 0114 C1030000 	 .word .L207+1
 3097 0118 F1020000 	 .word .L208+1
 3098 011c A3050000 	 .word .L209+1
 3099 0120 A9050000 	 .word .L204+1
 3100 0124 A9050000 	 .word .L204+1
 3101 0128 A9050000 	 .word .L204+1
 3102 012c A3050000 	 .word .L209+1
 3103 0130 A9050000 	 .word .L204+1
 3104 0134 A9050000 	 .word .L204+1
 3105 0138 A9050000 	 .word .L204+1
 3106 013c A9050000 	 .word .L204+1
 3107 0140 A9050000 	 .word .L204+1
 3108 0144 A9050000 	 .word .L204+1
 3109 0148 A9050000 	 .word .L204+1
 3110 014c A9050000 	 .word .L204+1
 3111 0150 4D050000 	 .word .L210+1
 3112 0154 63050000 	 .word .L211+1
 3113 0158 A3050000 	 .word .L209+1
 3114 015c 2B040000 	 .word .L212+1
 3115 0160 A9050000 	 .word .L204+1
 3116 0164 A9050000 	 .word .L204+1
 3117 0168 A9050000 	 .word .L204+1
 3118 016c A3050000 	 .word .L209+1
 3119 0170 A9050000 	 .word .L204+1
 3120 0174 A9050000 	 .word .L204+1
 3121 0178 A9050000 	 .word .L204+1
 3122 017c A9050000 	 .word .L204+1
 3123 0180 A9050000 	 .word .L204+1
 3124 0184 A9050000 	 .word .L204+1
 3125 0188 A9050000 	 .word .L204+1
 3126 018c A9050000 	 .word .L204+1
 3127 0190 97030000 	 .word .L213+1
 3128 0194 A3050000 	 .word .L209+1
 3129 0198 A9050000 	 .word .L204+1
 3130 019c A3050000 	 .word .L209+1
 3131 01a0 A9050000 	 .word .L204+1
 3132 01a4 A9050000 	 .word .L204+1
 3133 01a8 A9050000 	 .word .L204+1
 3134 01ac A3050000 	 .word .L209+1
 3135 01b0 A9050000 	 .word .L204+1
 3136 01b4 A9050000 	 .word .L204+1
 3137 01b8 A9050000 	 .word .L204+1
 3138 01bc A9050000 	 .word .L204+1
 3139 01c0 A9050000 	 .word .L204+1
 3140 01c4 A9050000 	 .word .L204+1
 3141 01c8 A9050000 	 .word .L204+1
 3142 01cc A9050000 	 .word .L204+1
 3143 01d0 2F050000 	 .word .L214+1
 3144 01d4 01050000 	 .word .L215+1
 3145 01d8 A3050000 	 .word .L209+1
 3146 01dc 63050000 	 .word .L211+1
 3147 01e0 A9050000 	 .word .L204+1
 3148 01e4 A9050000 	 .word .L204+1
 3149 01e8 A9050000 	 .word .L204+1
 3150 01ec 85040000 	 .word .L216+1
 3151 01f0 A9050000 	 .word .L204+1
 3152 01f4 A9050000 	 .word .L204+1
 3153 01f8 A9050000 	 .word .L204+1
 3154 01fc A9050000 	 .word .L204+1
 3155 0200 A9050000 	 .word .L204+1
 3156 0204 A9050000 	 .word .L204+1
 3157 0208 A9050000 	 .word .L204+1
 3158 020c A9050000 	 .word .L204+1
 3159 0210 A9050000 	 .word .L204+1
 3160 0214 A9050000 	 .word .L204+1
 3161 0218 A9050000 	 .word .L204+1
 3162 021c A9050000 	 .word .L204+1
 3163 0220 A9050000 	 .word .L204+1
 3164 0224 A9050000 	 .word .L204+1
 3165 0228 A9050000 	 .word .L204+1
 3166 022c A9050000 	 .word .L204+1
 3167 0230 A9050000 	 .word .L204+1
 3168 0234 A9050000 	 .word .L204+1
 3169 0238 A9050000 	 .word .L204+1
 3170 023c A9050000 	 .word .L204+1
 3171 0240 A9050000 	 .word .L204+1
 3172 0244 A9050000 	 .word .L204+1
 3173 0248 A9050000 	 .word .L204+1
 3174 024c A9050000 	 .word .L204+1
 3175 0250 A9050000 	 .word .L204+1
 3176 0254 A9050000 	 .word .L204+1
 3177 0258 A9050000 	 .word .L204+1
 3178 025c A9050000 	 .word .L204+1
 3179 0260 A9050000 	 .word .L204+1
 3180 0264 A9050000 	 .word .L204+1
 3181 0268 A9050000 	 .word .L204+1
 3182 026c A9050000 	 .word .L204+1
 3183 0270 A9050000 	 .word .L204+1
 3184 0274 A9050000 	 .word .L204+1
 3185 0278 A9050000 	 .word .L204+1
 3186 027c A9050000 	 .word .L204+1
 3187 0280 A9050000 	 .word .L204+1
 3188 0284 A9050000 	 .word .L204+1
 3189 0288 A9050000 	 .word .L204+1
 3190 028c A9050000 	 .word .L204+1
 3191 0290 A9050000 	 .word .L204+1
 3192 0294 A9050000 	 .word .L204+1
 3193 0298 A9050000 	 .word .L204+1
 3194 029c A9050000 	 .word .L204+1
 3195 02a0 A9050000 	 .word .L204+1
 3196 02a4 A9050000 	 .word .L204+1
 3197 02a8 A9050000 	 .word .L204+1
 3198 02ac A9050000 	 .word .L204+1
 3199 02b0 A9050000 	 .word .L204+1
 3200 02b4 A9050000 	 .word .L204+1
 3201 02b8 A9050000 	 .word .L204+1
 3202 02bc A9050000 	 .word .L204+1
 3203 02c0 A9050000 	 .word .L204+1
 3204 02c4 A9050000 	 .word .L204+1
 3205 02c8 A9050000 	 .word .L204+1
 3206 02cc A9050000 	 .word .L204+1
 3207 02d0 11050000 	 .word .L217+1
 3208 02d4 E3040000 	 .word .L218+1
 3209 02d8 A3050000 	 .word .L209+1
 3210 02dc D3040000 	 .word .L219+1
 3211 02e0 A9050000 	 .word .L204+1
 3212 02e4 A9050000 	 .word .L204+1
 3213 02e8 A9050000 	 .word .L204+1
 3214 02ec 63050000 	 .word .L211+1
 3215              	 .p2align 1
 3216              	.L208:
1520:../SSC/Src/ecatslv.c ****         {
1521:../SSC/Src/ecatslv.c ****         case INIT_2_BOOT    :
1522:../SSC/Src/ecatslv.c ****             /* if the application has to execute code when going to BOOT this shall be done at this
1523:../SSC/Src/ecatslv.c ****             bBootMode = TRUE;
 3217              	 .loc 3 1523 0
 3218 02f0 0E4B     	 ldr r3,.L264+28
 3219 02f2 0122     	 movs r2,#1
 3220 02f4 1A70     	 strb r2,[r3]
1524:../SSC/Src/ecatslv.c **** 
1525:../SSC/Src/ecatslv.c ****             if ( CheckSmSettings(MAILBOX_READ+1) != 0 )
 3221              	 .loc 3 1525 0
 3222 02f6 0220     	 movs r0,#2
 3223 02f8 FFF7FEFF 	 bl CheckSmSettings
 3224 02fc 0346     	 mov r3,r0
 3225 02fe 002B     	 cmp r3,#0
 3226 0300 16D0     	 beq .L220
1526:../SSC/Src/ecatslv.c ****             {
1527:../SSC/Src/ecatslv.c ****                 bBootMode = FALSE;
 3227              	 .loc 3 1527 0
 3228 0302 0A4B     	 ldr r3,.L264+28
 3229 0304 0022     	 movs r2,#0
 3230 0306 1A70     	 strb r2,[r3]
1528:../SSC/Src/ecatslv.c ****                 result = ALSTATUSCODE_INVALIDMBXCFGINBOOT;
 3231              	 .loc 3 1528 0
 3232 0308 1523     	 movs r3,#21
 3233 030a FB81     	 strh r3,[r7,#14]
1529:../SSC/Src/ecatslv.c ****                 break;
 3234              	 .loc 3 1529 0
 3235 030c 4FE1     	 b .L221
 3236              	.L265:
 3237 030e 00BF     	 .align 2
 3238              	.L264:
 3239 0310 00000000 	 .word EsmTimeoutCounter
 3240 0314 00000000 	 .word bApplEsmPending
 3241 0318 00000000 	 .word nAlStatus
 3242 031c 00000000 	 .word nPdInputSize
 3243 0320 00000000 	 .word nPdOutputSize
 3244 0324 00000000 	 .word nMaxSyncMan
 3245 0328 00000000 	 .word nEcatStateTrans
 3246 032c 00000000 	 .word bBootMode
 3247              	.L220:
1530:../SSC/Src/ecatslv.c ****             }
1531:../SSC/Src/ecatslv.c ****             /* disable all events in BOOT state */
1532:../SSC/Src/ecatslv.c ****             ResetALEventMask(0);
 3248              	 .loc 3 1532 0
 3249 0330 0020     	 movs r0,#0
 3250 0332 FFF7FEFF 	 bl ResetALEventMask
1533:../SSC/Src/ecatslv.c **** 
1534:../SSC/Src/ecatslv.c ****             /* MBX_StartMailboxHandler (in mailbox.c) checks if the areas of the mailbox
1535:../SSC/Src/ecatslv.c ****                sync managers SM0 and SM1 overlap each other
1536:../SSC/Src/ecatslv.c ****               if result is unequal 0, the slave will stay in INIT
1537:../SSC/Src/ecatslv.c ****               and sets the ErrorInd Bit (bit 4) of the AL-Status */
1538:../SSC/Src/ecatslv.c ****             result = MBX_StartMailboxHandler();
 3251              	 .loc 3 1538 0
 3252 0336 FFF7FEFF 	 bl MBX_StartMailboxHandler
 3253 033a 0346     	 mov r3,r0
 3254 033c FB81     	 strh r3,[r7,#14]
1539:../SSC/Src/ecatslv.c ****             if (result == 0)
 3255              	 .loc 3 1539 0
 3256 033e FB89     	 ldrh r3,[r7,#14]
 3257 0340 002B     	 cmp r3,#0
 3258 0342 0CD1     	 bne .L222
1540:../SSC/Src/ecatslv.c ****             {
1541:../SSC/Src/ecatslv.c ****                 bApplEsmPending = FALSE;
 3259              	 .loc 3 1541 0
 3260 0344 AB4B     	 ldr r3,.L266
 3261 0346 0022     	 movs r2,#0
 3262 0348 1A70     	 strb r2,[r3]
1542:../SSC/Src/ecatslv.c ****                 /* additionally there could be an application specific check (in ecatappl.c)
1543:../SSC/Src/ecatslv.c ****                     if the state transition from INIT to BOOT should be done
1544:../SSC/Src/ecatslv.c ****                     if result is NOERROR_INWORK, the slave will stay in INIT until timeout 
1545:../SSC/Src/ecatslv.c ****                     or transition is complete by AL_ControlRes*/
1546:../SSC/Src/ecatslv.c ****             
1547:../SSC/Src/ecatslv.c ****                 result = APPL_StartMailboxHandler();
 3263              	 .loc 3 1547 0
 3264 034a FFF7FEFF 	 bl APPL_StartMailboxHandler
 3265 034e 0346     	 mov r3,r0
 3266 0350 FB81     	 strh r3,[r7,#14]
1548:../SSC/Src/ecatslv.c ****                 if ( result == 0 )
 3267              	 .loc 3 1548 0
 3268 0352 FB89     	 ldrh r3,[r7,#14]
 3269 0354 002B     	 cmp r3,#0
 3270 0356 02D1     	 bne .L222
1549:../SSC/Src/ecatslv.c ****                 {
1550:../SSC/Src/ecatslv.c ****                     /*transition successful*/
1551:../SSC/Src/ecatslv.c ****                     bMbxRunning = TRUE;
 3271              	 .loc 3 1551 0
 3272 0358 A74B     	 ldr r3,.L266+4
 3273 035a 0122     	 movs r2,#1
 3274 035c 1A70     	 strb r2,[r3]
 3275              	.L222:
1552:../SSC/Src/ecatslv.c ****                 }
1553:../SSC/Src/ecatslv.c ****             }
1554:../SSC/Src/ecatslv.c **** 
1555:../SSC/Src/ecatslv.c ****             if(result != 0 && result != NOERROR_INWORK)
 3276              	 .loc 3 1555 0
 3277 035e FB89     	 ldrh r3,[r7,#14]
 3278 0360 002B     	 cmp r3,#0
 3279 0362 0DD0     	 beq .L223
 3280              	 .loc 3 1555 0 is_stmt 0 discriminator 1
 3281 0364 FB89     	 ldrh r3,[r7,#14]
 3282 0366 FF2B     	 cmp r3,#255
 3283 0368 0AD0     	 beq .L223
1556:../SSC/Src/ecatslv.c ****             {
1557:../SSC/Src/ecatslv.c ****                 /*Stop APPL Mbx handler if the APPL start handler was called before*/
1558:../SSC/Src/ecatslv.c ****                     if (!bApplEsmPending)
 3284              	 .loc 3 1558 0 is_stmt 1
 3285 036a A24B     	 ldr r3,.L266
 3286 036c 1B78     	 ldrb r3,[r3]
 3287 036e 83F00103 	 eor r3,r3,#1
 3288 0372 DBB2     	 uxtb r3,r3
 3289 0374 002B     	 cmp r3,#0
 3290 0376 01D0     	 beq .L224
1559:../SSC/Src/ecatslv.c ****                     {
1560:../SSC/Src/ecatslv.c ****                         APPL_StopMailboxHandler();
 3291              	 .loc 3 1560 0
 3292 0378 FFF7FEFF 	 bl APPL_StopMailboxHandler
 3293              	.L224:
1561:../SSC/Src/ecatslv.c ****                     }
1562:../SSC/Src/ecatslv.c **** 
1563:../SSC/Src/ecatslv.c ****                  MBX_StopMailboxHandler();
 3294              	 .loc 3 1563 0
 3295 037c FFF7FEFF 	 bl MBX_StopMailboxHandler
 3296              	.L223:
1564:../SSC/Src/ecatslv.c ****             }
1565:../SSC/Src/ecatslv.c **** 
1566:../SSC/Src/ecatslv.c ****             BL_Start( STATE_BOOT );
 3297              	 .loc 3 1566 0
 3298 0380 0320     	 movs r0,#3
 3299 0382 FFF7FEFF 	 bl BL_Start
1567:../SSC/Src/ecatslv.c **** 
1568:../SSC/Src/ecatslv.c ****             if (result != 0)
 3300              	 .loc 3 1568 0
 3301 0386 FB89     	 ldrh r3,[r7,#14]
 3302 0388 002B     	 cmp r3,#0
 3303 038a 03D0     	 beq .L225
1569:../SSC/Src/ecatslv.c ****             {
1570:../SSC/Src/ecatslv.c ****                 bBootMode = FALSE;
 3304              	 .loc 3 1570 0
 3305 038c 9B4B     	 ldr r3,.L266+8
 3306 038e 0022     	 movs r2,#0
 3307 0390 1A70     	 strb r2,[r3]
1571:../SSC/Src/ecatslv.c ****             }
1572:../SSC/Src/ecatslv.c **** 
1573:../SSC/Src/ecatslv.c **** 
1574:../SSC/Src/ecatslv.c **** 
1575:../SSC/Src/ecatslv.c ****             break;
 3308              	 .loc 3 1575 0
 3309 0392 0CE1     	 b .L221
 3310              	.L225:
 3311 0394 0BE1     	 b .L221
 3312              	.L213:
1576:../SSC/Src/ecatslv.c **** 
1577:../SSC/Src/ecatslv.c ****         case BOOT_2_INIT    :
1578:../SSC/Src/ecatslv.c ****             if(bBootMode)
 3313              	 .loc 3 1578 0
 3314 0396 994B     	 ldr r3,.L266+8
 3315 0398 1B78     	 ldrb r3,[r3]
 3316 039a 002B     	 cmp r3,#0
 3317 039c 0BD0     	 beq .L226
1579:../SSC/Src/ecatslv.c ****             {
1580:../SSC/Src/ecatslv.c ****                 bBootMode = FALSE;
 3318              	 .loc 3 1580 0
 3319 039e 974B     	 ldr r3,.L266+8
 3320 03a0 0022     	 movs r2,#0
 3321 03a2 1A70     	 strb r2,[r3]
1581:../SSC/Src/ecatslv.c ****                 /* disable all events in BOOT state */
1582:../SSC/Src/ecatslv.c ****                 ResetALEventMask(0);
 3322              	 .loc 3 1582 0
 3323 03a4 0020     	 movs r0,#0
 3324 03a6 FFF7FEFF 	 bl ResetALEventMask
1583:../SSC/Src/ecatslv.c ****                 MBX_StopMailboxHandler();
 3325              	 .loc 3 1583 0
 3326 03aa FFF7FEFF 	 bl MBX_StopMailboxHandler
1584:../SSC/Src/ecatslv.c ****                 result = APPL_StopMailboxHandler();
 3327              	 .loc 3 1584 0
 3328 03ae FFF7FEFF 	 bl APPL_StopMailboxHandler
 3329 03b2 0346     	 mov r3,r0
 3330 03b4 FB81     	 strh r3,[r7,#14]
 3331              	.L226:
1585:../SSC/Src/ecatslv.c ****             }
1586:../SSC/Src/ecatslv.c **** 
1587:../SSC/Src/ecatslv.c ****             BL_Stop();
 3332              	 .loc 3 1587 0
 3333 03b6 FFF7FEFF 	 bl BL_Stop
1588:../SSC/Src/ecatslv.c **** 
1589:../SSC/Src/ecatslv.c ****             BackToInitTransition();
 3334              	 .loc 3 1589 0
 3335 03ba FFF7FEFF 	 bl BackToInitTransition
1590:../SSC/Src/ecatslv.c **** 
1591:../SSC/Src/ecatslv.c **** 
1592:../SSC/Src/ecatslv.c **** 
1593:../SSC/Src/ecatslv.c ****             break;
 3336              	 .loc 3 1593 0
 3337 03be F6E0     	 b .L221
 3338              	.L207:
1594:../SSC/Src/ecatslv.c ****         case INIT_2_PREOP :
1595:../SSC/Src/ecatslv.c **** 
1596:../SSC/Src/ecatslv.c ****            UpdateEEPROMLoadedState();
 3339              	 .loc 3 1596 0
 3340 03c0 FFF7FEFF 	 bl UpdateEEPROMLoadedState
1597:../SSC/Src/ecatslv.c **** 
1598:../SSC/Src/ecatslv.c ****             if (EepromLoaded == FALSE)
 3341              	 .loc 3 1598 0
 3342 03c4 8E4B     	 ldr r3,.L266+12
 3343 03c6 1B78     	 ldrb r3,[r3]
 3344 03c8 83F00103 	 eor r3,r3,#1
 3345 03cc DBB2     	 uxtb r3,r3
 3346 03ce 002B     	 cmp r3,#0
 3347 03d0 01D0     	 beq .L227
1599:../SSC/Src/ecatslv.c ****             {
1600:../SSC/Src/ecatslv.c ****                 //return an error if the EEPROM was not loaded correct  (device restart is required
1601:../SSC/Src/ecatslv.c ****                 result = ALSTATUSCODE_EE_ERROR;
 3348              	 .loc 3 1601 0
 3349 03d2 5123     	 movs r3,#81
 3350 03d4 FB81     	 strh r3,[r7,#14]
 3351              	.L227:
1602:../SSC/Src/ecatslv.c ****             }
1603:../SSC/Src/ecatslv.c ****             if (result == 0)
 3352              	 .loc 3 1603 0
 3353 03d6 FB89     	 ldrh r3,[r7,#14]
 3354 03d8 002B     	 cmp r3,#0
 3355 03da 25D1     	 bne .L228
1604:../SSC/Src/ecatslv.c ****             {
1605:../SSC/Src/ecatslv.c ****             /* MBX_StartMailboxHandler (in mailbox.c) checks if the areas of the mailbox
1606:../SSC/Src/ecatslv.c ****                sync managers SYNCM0 and SYNCM1 overlap each other
1607:../SSC/Src/ecatslv.c ****               if result is unequal 0, the slave will stay in INIT
1608:../SSC/Src/ecatslv.c ****               and sets the ErrorInd Bit (bit 4) of the AL-Status */
1609:../SSC/Src/ecatslv.c ****             result = MBX_StartMailboxHandler();
 3356              	 .loc 3 1609 0
 3357 03dc FFF7FEFF 	 bl MBX_StartMailboxHandler
 3358 03e0 0346     	 mov r3,r0
 3359 03e2 FB81     	 strh r3,[r7,#14]
1610:../SSC/Src/ecatslv.c ****             if (result == 0)
 3360              	 .loc 3 1610 0
 3361 03e4 FB89     	 ldrh r3,[r7,#14]
 3362 03e6 002B     	 cmp r3,#0
 3363 03e8 0CD1     	 bne .L229
1611:../SSC/Src/ecatslv.c ****             {
1612:../SSC/Src/ecatslv.c ****                 bApplEsmPending = FALSE;
 3364              	 .loc 3 1612 0
 3365 03ea 824B     	 ldr r3,.L266
 3366 03ec 0022     	 movs r2,#0
 3367 03ee 1A70     	 strb r2,[r3]
1613:../SSC/Src/ecatslv.c ****                 /* additionally there could be an application specific check (in ecatappl.c)
1614:../SSC/Src/ecatslv.c ****                    if the state transition from INIT to PREOP should be done
1615:../SSC/Src/ecatslv.c ****                  if result is unequal 0, the slave will stay in INIT
1616:../SSC/Src/ecatslv.c ****                  and sets the ErrorInd Bit (bit 4) of the AL-Status */
1617:../SSC/Src/ecatslv.c ****                 result = APPL_StartMailboxHandler();
 3368              	 .loc 3 1617 0
 3369 03f0 FFF7FEFF 	 bl APPL_StartMailboxHandler
 3370 03f4 0346     	 mov r3,r0
 3371 03f6 FB81     	 strh r3,[r7,#14]
1618:../SSC/Src/ecatslv.c ****                 if ( result == 0 )
 3372              	 .loc 3 1618 0
 3373 03f8 FB89     	 ldrh r3,[r7,#14]
 3374 03fa 002B     	 cmp r3,#0
 3375 03fc 02D1     	 bne .L229
1619:../SSC/Src/ecatslv.c ****                 {
1620:../SSC/Src/ecatslv.c ****                     bMbxRunning = TRUE;
 3376              	 .loc 3 1620 0
 3377 03fe 7E4B     	 ldr r3,.L266+4
 3378 0400 0122     	 movs r2,#1
 3379 0402 1A70     	 strb r2,[r3]
 3380              	.L229:
1621:../SSC/Src/ecatslv.c ****                 }
1622:../SSC/Src/ecatslv.c ****             }
1623:../SSC/Src/ecatslv.c **** 
1624:../SSC/Src/ecatslv.c ****             if(result != 0 && result != NOERROR_INWORK)
 3381              	 .loc 3 1624 0
 3382 0404 FB89     	 ldrh r3,[r7,#14]
 3383 0406 002B     	 cmp r3,#0
 3384 0408 0ED0     	 beq .L228
 3385              	 .loc 3 1624 0 is_stmt 0 discriminator 1
 3386 040a FB89     	 ldrh r3,[r7,#14]
 3387 040c FF2B     	 cmp r3,#255
 3388 040e 0BD0     	 beq .L228
1625:../SSC/Src/ecatslv.c ****             {
1626:../SSC/Src/ecatslv.c ****                 /*Stop APPL Mbx handler if APPL Start Mbx handler was called before*/
1627:../SSC/Src/ecatslv.c ****                     if (!bApplEsmPending)
 3389              	 .loc 3 1627 0 is_stmt 1
 3390 0410 784B     	 ldr r3,.L266
 3391 0412 1B78     	 ldrb r3,[r3]
 3392 0414 83F00103 	 eor r3,r3,#1
 3393 0418 DBB2     	 uxtb r3,r3
 3394 041a 002B     	 cmp r3,#0
 3395 041c 01D0     	 beq .L230
1628:../SSC/Src/ecatslv.c ****                     {
1629:../SSC/Src/ecatslv.c ****                         APPL_StopMailboxHandler();
 3396              	 .loc 3 1629 0
 3397 041e FFF7FEFF 	 bl APPL_StopMailboxHandler
 3398              	.L230:
1630:../SSC/Src/ecatslv.c ****                     }
1631:../SSC/Src/ecatslv.c **** 
1632:../SSC/Src/ecatslv.c ****                  MBX_StopMailboxHandler();
 3399              	 .loc 3 1632 0
 3400 0422 FFF7FEFF 	 bl MBX_StopMailboxHandler
1633:../SSC/Src/ecatslv.c ****             }
1634:../SSC/Src/ecatslv.c **** 
1635:../SSC/Src/ecatslv.c ****             }
1636:../SSC/Src/ecatslv.c ****             break;
 3401              	 .loc 3 1636 0
 3402 0426 C2E0     	 b .L221
 3403              	.L228:
 3404              	 .loc 3 1636 0 is_stmt 0 discriminator 2
 3405 0428 C1E0     	 b .L221
 3406              	.L212:
1637:../SSC/Src/ecatslv.c **** 
1638:../SSC/Src/ecatslv.c ****         case PREOP_2_SAFEOP:
1639:../SSC/Src/ecatslv.c ****             /* start the input handler (function is defined above) */
1640:../SSC/Src/ecatslv.c ****             result = StartInputHandler();
 3407              	 .loc 3 1640 0 is_stmt 1
 3408 042a FFF7FEFF 	 bl StartInputHandler
 3409 042e 0346     	 mov r3,r0
 3410 0430 FB81     	 strh r3,[r7,#14]
1641:../SSC/Src/ecatslv.c ****             if ( result == 0 )
 3411              	 .loc 3 1641 0
 3412 0432 FB89     	 ldrh r3,[r7,#14]
 3413 0434 002B     	 cmp r3,#0
 3414 0436 12D1     	 bne .L231
1642:../SSC/Src/ecatslv.c ****             {
1643:../SSC/Src/ecatslv.c ****                 bApplEsmPending = FALSE;
 3415              	 .loc 3 1643 0
 3416 0438 6E4B     	 ldr r3,.L266
 3417 043a 0022     	 movs r2,#0
 3418 043c 1A70     	 strb r2,[r3]
1644:../SSC/Src/ecatslv.c ****                 result = APPL_StartInputHandler(&u16ALEventMask);
 3419              	 .loc 3 1644 0
 3420 043e 7148     	 ldr r0,.L266+16
 3421 0440 FFF7FEFF 	 bl APPL_StartInputHandler
 3422 0444 0346     	 mov r3,r0
 3423 0446 FB81     	 strh r3,[r7,#14]
1645:../SSC/Src/ecatslv.c **** 
1646:../SSC/Src/ecatslv.c ****                 if(result == 0)
 3424              	 .loc 3 1646 0
 3425 0448 FB89     	 ldrh r3,[r7,#14]
 3426 044a 002B     	 cmp r3,#0
 3427 044c 07D1     	 bne .L231
1647:../SSC/Src/ecatslv.c ****                 {
1648:../SSC/Src/ecatslv.c ****                     /* initialize the AL Event Mask register (0x204) */
1649:../SSC/Src/ecatslv.c ****                     SetALEventMask( u16ALEventMask );
 3428              	 .loc 3 1649 0
 3429 044e 6D4B     	 ldr r3,.L266+16
 3430 0450 1B88     	 ldrh r3,[r3]
 3431 0452 1846     	 mov r0,r3
 3432 0454 FFF7FEFF 	 bl SetALEventMask
1650:../SSC/Src/ecatslv.c **** 
1651:../SSC/Src/ecatslv.c ****                     bEcatInputUpdateRunning = TRUE;
 3433              	 .loc 3 1651 0
 3434 0458 6B4B     	 ldr r3,.L266+20
 3435 045a 0122     	 movs r2,#1
 3436 045c 1A70     	 strb r2,[r3]
 3437              	.L231:
1652:../SSC/Src/ecatslv.c ****                 }
1653:../SSC/Src/ecatslv.c ****             }
1654:../SSC/Src/ecatslv.c **** 
1655:../SSC/Src/ecatslv.c ****             /*if one start input handler returned an error stop the input handler*/
1656:../SSC/Src/ecatslv.c ****             if(result != 0 && result != NOERROR_INWORK)
 3438              	 .loc 3 1656 0
 3439 045e FB89     	 ldrh r3,[r7,#14]
 3440 0460 002B     	 cmp r3,#0
 3441 0462 0ED0     	 beq .L232
 3442              	 .loc 3 1656 0 is_stmt 0 discriminator 1
 3443 0464 FB89     	 ldrh r3,[r7,#14]
 3444 0466 FF2B     	 cmp r3,#255
 3445 0468 0BD0     	 beq .L232
1657:../SSC/Src/ecatslv.c ****             {
1658:../SSC/Src/ecatslv.c ****                 if(!bApplEsmPending)
 3446              	 .loc 3 1658 0 is_stmt 1
 3447 046a 624B     	 ldr r3,.L266
 3448 046c 1B78     	 ldrb r3,[r3]
 3449 046e 83F00103 	 eor r3,r3,#1
 3450 0472 DBB2     	 uxtb r3,r3
 3451 0474 002B     	 cmp r3,#0
 3452 0476 01D0     	 beq .L233
1659:../SSC/Src/ecatslv.c ****                 {
1660:../SSC/Src/ecatslv.c ****                     /*Call only the APPL stop handler if the APPL start handler was called before*/
1661:../SSC/Src/ecatslv.c ****                     /*The application can react to the state transition in the function APPL_StopIn
1662:../SSC/Src/ecatslv.c ****                     APPL_StopInputHandler();
 3453              	 .loc 3 1662 0
 3454 0478 FFF7FEFF 	 bl APPL_StopInputHandler
 3455              	.L233:
1663:../SSC/Src/ecatslv.c ****                 }
1664:../SSC/Src/ecatslv.c **** 
1665:../SSC/Src/ecatslv.c ****                 StopInputHandler();
 3456              	 .loc 3 1665 0
 3457 047c FFF7FEFF 	 bl StopInputHandler
1666:../SSC/Src/ecatslv.c ****             }
1667:../SSC/Src/ecatslv.c ****             break;
 3458              	 .loc 3 1667 0
 3459 0480 95E0     	 b .L221
 3460              	.L232:
 3461              	 .loc 3 1667 0 is_stmt 0 discriminator 3
 3462 0482 94E0     	 b .L221
 3463              	.L216:
1668:../SSC/Src/ecatslv.c **** 
1669:../SSC/Src/ecatslv.c ****         case SAFEOP_2_OP:
1670:../SSC/Src/ecatslv.c ****             /* start the output handler (function is defined above) */
1671:../SSC/Src/ecatslv.c ****             result = StartOutputHandler();
 3464              	 .loc 3 1671 0 is_stmt 1
 3465 0484 FFF7FEFF 	 bl StartOutputHandler
 3466 0488 0346     	 mov r3,r0
 3467 048a FB81     	 strh r3,[r7,#14]
1672:../SSC/Src/ecatslv.c ****             if(result == 0)
 3468              	 .loc 3 1672 0
 3469 048c FB89     	 ldrh r3,[r7,#14]
 3470 048e 002B     	 cmp r3,#0
 3471 0490 0CD1     	 bne .L234
1673:../SSC/Src/ecatslv.c ****             {
1674:../SSC/Src/ecatslv.c ****                 bApplEsmPending = FALSE;
 3472              	 .loc 3 1674 0
 3473 0492 584B     	 ldr r3,.L266
 3474 0494 0022     	 movs r2,#0
 3475 0496 1A70     	 strb r2,[r3]
1675:../SSC/Src/ecatslv.c ****                 result = APPL_StartOutputHandler();
 3476              	 .loc 3 1675 0
 3477 0498 FFF7FEFF 	 bl APPL_StartOutputHandler
 3478 049c 0346     	 mov r3,r0
 3479 049e FB81     	 strh r3,[r7,#14]
1676:../SSC/Src/ecatslv.c **** 
1677:../SSC/Src/ecatslv.c ****                 if(result == 0)
 3480              	 .loc 3 1677 0
 3481 04a0 FB89     	 ldrh r3,[r7,#14]
 3482 04a2 002B     	 cmp r3,#0
 3483 04a4 02D1     	 bne .L234
1678:../SSC/Src/ecatslv.c ****                 {
1679:../SSC/Src/ecatslv.c ****                     /*Device is in OPERATINAL*/
1680:../SSC/Src/ecatslv.c ****                     bEcatOutputUpdateRunning = TRUE;
 3484              	 .loc 3 1680 0
 3485 04a6 594B     	 ldr r3,.L266+24
 3486 04a8 0122     	 movs r2,#1
 3487 04aa 1A70     	 strb r2,[r3]
 3488              	.L234:
1681:../SSC/Src/ecatslv.c ****                 }
1682:../SSC/Src/ecatslv.c **** 
1683:../SSC/Src/ecatslv.c ****             }
1684:../SSC/Src/ecatslv.c **** 
1685:../SSC/Src/ecatslv.c ****             if ( result != 0 && result != NOERROR_INWORK)
 3489              	 .loc 3 1685 0
 3490 04ac FB89     	 ldrh r3,[r7,#14]
 3491 04ae 002B     	 cmp r3,#0
 3492 04b0 0ED0     	 beq .L235
 3493              	 .loc 3 1685 0 is_stmt 0 discriminator 1
 3494 04b2 FB89     	 ldrh r3,[r7,#14]
 3495 04b4 FF2B     	 cmp r3,#255
 3496 04b6 0BD0     	 beq .L235
1686:../SSC/Src/ecatslv.c ****             {
1687:../SSC/Src/ecatslv.c ****                     if (!bApplEsmPending)
 3497              	 .loc 3 1687 0 is_stmt 1
 3498 04b8 4E4B     	 ldr r3,.L266
 3499 04ba 1B78     	 ldrb r3,[r3]
 3500 04bc 83F00103 	 eor r3,r3,#1
 3501 04c0 DBB2     	 uxtb r3,r3
 3502 04c2 002B     	 cmp r3,#0
 3503 04c4 01D0     	 beq .L236
1688:../SSC/Src/ecatslv.c ****                     {
1689:../SSC/Src/ecatslv.c ****                         APPL_StopOutputHandler();
 3504              	 .loc 3 1689 0
 3505 04c6 FFF7FEFF 	 bl APPL_StopOutputHandler
 3506              	.L236:
1690:../SSC/Src/ecatslv.c ****                     }
1691:../SSC/Src/ecatslv.c **** 
1692:../SSC/Src/ecatslv.c ****                 StopOutputHandler();
 3507              	 .loc 3 1692 0
 3508 04ca FFF7FEFF 	 bl StopOutputHandler
1693:../SSC/Src/ecatslv.c ****             }
1694:../SSC/Src/ecatslv.c **** 
1695:../SSC/Src/ecatslv.c ****             break;
 3509              	 .loc 3 1695 0
 3510 04ce 6EE0     	 b .L221
 3511              	.L235:
 3512              	 .loc 3 1695 0 is_stmt 0 discriminator 4
 3513 04d0 6DE0     	 b .L221
 3514              	.L219:
1696:../SSC/Src/ecatslv.c **** 
1697:../SSC/Src/ecatslv.c ****         case OP_2_SAFEOP:
1698:../SSC/Src/ecatslv.c ****             /* stop the output handler (function is defined above) */
1699:../SSC/Src/ecatslv.c ****             APPL_StopOutputHandler();
 3515              	 .loc 3 1699 0 is_stmt 1
 3516 04d2 FFF7FEFF 	 bl APPL_StopOutputHandler
1700:../SSC/Src/ecatslv.c **** 
1701:../SSC/Src/ecatslv.c ****             StopOutputHandler();
 3517              	 .loc 3 1701 0
 3518 04d6 FFF7FEFF 	 bl StopOutputHandler
1702:../SSC/Src/ecatslv.c **** 
1703:../SSC/Src/ecatslv.c ****             bApplEsmPending = FALSE;
 3519              	 .loc 3 1703 0
 3520 04da 464B     	 ldr r3,.L266
 3521 04dc 0022     	 movs r2,#0
 3522 04de 1A70     	 strb r2,[r3]
1704:../SSC/Src/ecatslv.c **** 
1705:../SSC/Src/ecatslv.c ****             break;
 3523              	 .loc 3 1705 0
 3524 04e0 65E0     	 b .L221
 3525              	.L218:
1706:../SSC/Src/ecatslv.c **** 
1707:../SSC/Src/ecatslv.c ****         case OP_2_PREOP:
1708:../SSC/Src/ecatslv.c ****             /* stop the output handler (function is defined above) */
1709:../SSC/Src/ecatslv.c ****             result = APPL_StopOutputHandler();
 3526              	 .loc 3 1709 0
 3527 04e2 FFF7FEFF 	 bl APPL_StopOutputHandler
 3528 04e6 0346     	 mov r3,r0
 3529 04e8 FB81     	 strh r3,[r7,#14]
1710:../SSC/Src/ecatslv.c **** 
1711:../SSC/Src/ecatslv.c ****             StopOutputHandler();
 3530              	 .loc 3 1711 0
 3531 04ea FFF7FEFF 	 bl StopOutputHandler
1712:../SSC/Src/ecatslv.c **** 
1713:../SSC/Src/ecatslv.c ****             bApplEsmPending = FALSE;
 3532              	 .loc 3 1713 0
 3533 04ee 414B     	 ldr r3,.L266
 3534 04f0 0022     	 movs r2,#0
 3535 04f2 1A70     	 strb r2,[r3]
1714:../SSC/Src/ecatslv.c **** 
1715:../SSC/Src/ecatslv.c ****             if (result != 0)
 3536              	 .loc 3 1715 0
 3537 04f4 FB89     	 ldrh r3,[r7,#14]
 3538 04f6 002B     	 cmp r3,#0
 3539 04f8 00D0     	 beq .L237
1716:../SSC/Src/ecatslv.c ****             {
1717:../SSC/Src/ecatslv.c ****                 break;
 3540              	 .loc 3 1717 0 discriminator 5
 3541 04fa 58E0     	 b .L221
 3542              	.L237:
1718:../SSC/Src/ecatslv.c ****             }
1719:../SSC/Src/ecatslv.c **** 
1720:../SSC/Src/ecatslv.c ****             stateTrans = SAFEOP_2_PREOP;
 3543              	 .loc 3 1720 0
 3544 04fc 4223     	 movs r3,#66
 3545 04fe 3B73     	 strb r3,[r7,#12]
 3546              	.L215:
1721:../SSC/Src/ecatslv.c **** 
1722:../SSC/Src/ecatslv.c ****         case SAFEOP_2_PREOP:
1723:../SSC/Src/ecatslv.c ****             /* stop the input handler (function is defined above) */
1724:../SSC/Src/ecatslv.c ****             APPL_StopInputHandler();
 3547              	 .loc 3 1724 0
 3548 0500 FFF7FEFF 	 bl APPL_StopInputHandler
1725:../SSC/Src/ecatslv.c ****            
1726:../SSC/Src/ecatslv.c ****             StopInputHandler();
 3549              	 .loc 3 1726 0
 3550 0504 FFF7FEFF 	 bl StopInputHandler
1727:../SSC/Src/ecatslv.c **** 
1728:../SSC/Src/ecatslv.c ****             bApplEsmPending = FALSE;
 3551              	 .loc 3 1728 0
 3552 0508 3A4B     	 ldr r3,.L266
 3553 050a 0022     	 movs r2,#0
 3554 050c 1A70     	 strb r2,[r3]
1729:../SSC/Src/ecatslv.c **** 
1730:../SSC/Src/ecatslv.c ****             break;
 3555              	 .loc 3 1730 0
 3556 050e 4EE0     	 b .L221
 3557              	.L217:
1731:../SSC/Src/ecatslv.c **** 
1732:../SSC/Src/ecatslv.c ****         case OP_2_INIT:
1733:../SSC/Src/ecatslv.c ****             /* stop the output handler (function is defined above) */
1734:../SSC/Src/ecatslv.c ****             result = APPL_StopOutputHandler();
 3558              	 .loc 3 1734 0
 3559 0510 FFF7FEFF 	 bl APPL_StopOutputHandler
 3560 0514 0346     	 mov r3,r0
 3561 0516 FB81     	 strh r3,[r7,#14]
1735:../SSC/Src/ecatslv.c **** 
1736:../SSC/Src/ecatslv.c ****             StopOutputHandler();
 3562              	 .loc 3 1736 0
 3563 0518 FFF7FEFF 	 bl StopOutputHandler
1737:../SSC/Src/ecatslv.c **** 
1738:../SSC/Src/ecatslv.c ****             bApplEsmPending = FALSE;
 3564              	 .loc 3 1738 0
 3565 051c 354B     	 ldr r3,.L266
 3566 051e 0022     	 movs r2,#0
 3567 0520 1A70     	 strb r2,[r3]
1739:../SSC/Src/ecatslv.c **** 
1740:../SSC/Src/ecatslv.c ****             if (result != 0)
 3568              	 .loc 3 1740 0
 3569 0522 FB89     	 ldrh r3,[r7,#14]
 3570 0524 002B     	 cmp r3,#0
 3571 0526 00D0     	 beq .L238
1741:../SSC/Src/ecatslv.c ****             {
1742:../SSC/Src/ecatslv.c ****                 break;
 3572              	 .loc 3 1742 0 discriminator 6
 3573 0528 41E0     	 b .L221
 3574              	.L238:
1743:../SSC/Src/ecatslv.c ****             }
1744:../SSC/Src/ecatslv.c ****             
1745:../SSC/Src/ecatslv.c ****             stateTrans = SAFEOP_2_INIT;
 3575              	 .loc 3 1745 0
 3576 052a 4123     	 movs r3,#65
 3577 052c 3B73     	 strb r3,[r7,#12]
 3578              	.L214:
1746:../SSC/Src/ecatslv.c **** 
1747:../SSC/Src/ecatslv.c ****         case SAFEOP_2_INIT:
1748:../SSC/Src/ecatslv.c ****             /* stop the input handler (function is defined above) */
1749:../SSC/Src/ecatslv.c ****             result = APPL_StopInputHandler();
 3579              	 .loc 3 1749 0
 3580 052e FFF7FEFF 	 bl APPL_StopInputHandler
 3581 0532 0346     	 mov r3,r0
 3582 0534 FB81     	 strh r3,[r7,#14]
1750:../SSC/Src/ecatslv.c ****             
1751:../SSC/Src/ecatslv.c ****             StopInputHandler();
 3583              	 .loc 3 1751 0
 3584 0536 FFF7FEFF 	 bl StopInputHandler
1752:../SSC/Src/ecatslv.c **** 
1753:../SSC/Src/ecatslv.c ****             bApplEsmPending = FALSE;
 3585              	 .loc 3 1753 0
 3586 053a 2E4B     	 ldr r3,.L266
 3587 053c 0022     	 movs r2,#0
 3588 053e 1A70     	 strb r2,[r3]
1754:../SSC/Src/ecatslv.c **** 
1755:../SSC/Src/ecatslv.c ****             if (result != 0)
 3589              	 .loc 3 1755 0
 3590 0540 FB89     	 ldrh r3,[r7,#14]
 3591 0542 002B     	 cmp r3,#0
 3592 0544 00D0     	 beq .L239
1756:../SSC/Src/ecatslv.c ****             {
1757:../SSC/Src/ecatslv.c ****                 break;
 3593              	 .loc 3 1757 0 discriminator 7
 3594 0546 32E0     	 b .L221
 3595              	.L239:
1758:../SSC/Src/ecatslv.c ****             }
1759:../SSC/Src/ecatslv.c ****             stateTrans = PREOP_2_INIT;
 3596              	 .loc 3 1759 0
 3597 0548 2123     	 movs r3,#33
 3598 054a 3B73     	 strb r3,[r7,#12]
 3599              	.L210:
1760:../SSC/Src/ecatslv.c **** 
1761:../SSC/Src/ecatslv.c ****         case PREOP_2_INIT:
1762:../SSC/Src/ecatslv.c ****             MBX_StopMailboxHandler();
 3600              	 .loc 3 1762 0
 3601 054c FFF7FEFF 	 bl MBX_StopMailboxHandler
1763:../SSC/Src/ecatslv.c ****             result = APPL_StopMailboxHandler();
 3602              	 .loc 3 1763 0
 3603 0550 FFF7FEFF 	 bl APPL_StopMailboxHandler
 3604 0554 0346     	 mov r3,r0
 3605 0556 FB81     	 strh r3,[r7,#14]
1764:../SSC/Src/ecatslv.c **** 
1765:../SSC/Src/ecatslv.c ****             BackToInitTransition();
 3606              	 .loc 3 1765 0
 3607 0558 FFF7FEFF 	 bl BackToInitTransition
1766:../SSC/Src/ecatslv.c ****             break;
 3608              	 .loc 3 1766 0
 3609 055c 27E0     	 b .L221
 3610              	.L205:
1767:../SSC/Src/ecatslv.c **** 
1768:../SSC/Src/ecatslv.c ****         case INIT_2_INIT:
1769:../SSC/Src/ecatslv.c ****             BackToInitTransition();
 3611              	 .loc 3 1769 0
 3612 055e FFF7FEFF 	 bl BackToInitTransition
 3613              	.L211:
1770:../SSC/Src/ecatslv.c ****         case PREOP_2_PREOP:
1771:../SSC/Src/ecatslv.c ****         case SAFEOP_2_SAFEOP:
1772:../SSC/Src/ecatslv.c ****         case OP_2_OP:
1773:../SSC/Src/ecatslv.c ****             if(bErrAck)
 3614              	 .loc 3 1773 0
 3615 0562 7B7B     	 ldrb r3,[r7,#13]
 3616 0564 002B     	 cmp r3,#0
 3617 0566 04D0     	 beq .L240
1774:../SSC/Src/ecatslv.c ****             {
1775:../SSC/Src/ecatslv.c ****                 APPL_AckErrorInd(stateTrans);
 3618              	 .loc 3 1775 0
 3619 0568 3B7B     	 ldrb r3,[r7,#12]
 3620 056a 9BB2     	 uxth r3,r3
 3621 056c 1846     	 mov r0,r3
 3622 056e FFF7FEFF 	 bl APPL_AckErrorInd
 3623              	.L240:
1776:../SSC/Src/ecatslv.c ****             }
1777:../SSC/Src/ecatslv.c **** 
1778:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ESM2*/
1779:../SSC/Src/ecatslv.c **** 
1780:../SSC/Src/ecatslv.c ****                 /*no local error flag is currently active, enable SM*/
1781:../SSC/Src/ecatslv.c ****                 if ( nAlStatus & (STATE_SAFEOP | STATE_OP))
 3624              	 .loc 3 1781 0
 3625 0572 274B     	 ldr r3,.L266+28
 3626 0574 1B78     	 ldrb r3,[r3]
 3627 0576 03F00C03 	 and r3,r3,#12
 3628 057a 002B     	 cmp r3,#0
 3629 057c 0ED0     	 beq .L241
1782:../SSC/Src/ecatslv.c ****                 {
1783:../SSC/Src/ecatslv.c ****                     if(nPdOutputSize > 0)
 3630              	 .loc 3 1783 0
 3631 057e 254B     	 ldr r3,.L266+32
 3632 0580 1B88     	 ldrh r3,[r3]
 3633 0582 002B     	 cmp r3,#0
 3634 0584 03D0     	 beq .L242
1784:../SSC/Src/ecatslv.c ****                     {
1785:../SSC/Src/ecatslv.c ****                         EnableSyncManChannel(PROCESS_DATA_OUT);
 3635              	 .loc 3 1785 0
 3636 0586 0220     	 movs r0,#2
 3637 0588 FFF7FEFF 	 bl EnableSyncManChannel
 3638 058c 06E0     	 b .L241
 3639              	.L242:
1786:../SSC/Src/ecatslv.c ****                     }
1787:../SSC/Src/ecatslv.c ****                     else 
1788:../SSC/Src/ecatslv.c ****                     if(nPdInputSize > 0)
 3640              	 .loc 3 1788 0
 3641 058e 224B     	 ldr r3,.L266+36
 3642 0590 1B88     	 ldrh r3,[r3]
 3643 0592 002B     	 cmp r3,#0
 3644 0594 02D0     	 beq .L241
1789:../SSC/Src/ecatslv.c ****                     {
1790:../SSC/Src/ecatslv.c ****                         EnableSyncManChannel(PROCESS_DATA_IN);
 3645              	 .loc 3 1790 0
 3646 0596 0320     	 movs r0,#3
 3647 0598 FFF7FEFF 	 bl EnableSyncManChannel
 3648              	.L241:
1791:../SSC/Src/ecatslv.c ****                     }
1792:../SSC/Src/ecatslv.c ****                 }
1793:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ESM2*/
1794:../SSC/Src/ecatslv.c ****             
1795:../SSC/Src/ecatslv.c ****             result = NOERROR_NOSTATECHANGE;
 3649              	 .loc 3 1795 0
 3650 059c FE23     	 movs r3,#254
 3651 059e FB81     	 strh r3,[r7,#14]
1796:../SSC/Src/ecatslv.c ****             break;
 3652              	 .loc 3 1796 0
 3653 05a0 05E0     	 b .L221
 3654              	.L209:
1797:../SSC/Src/ecatslv.c **** 
1798:../SSC/Src/ecatslv.c ****         case INIT_2_SAFEOP:
1799:../SSC/Src/ecatslv.c ****         case INIT_2_OP:
1800:../SSC/Src/ecatslv.c ****         case PREOP_2_OP:
1801:../SSC/Src/ecatslv.c ****         case PREOP_2_BOOT:
1802:../SSC/Src/ecatslv.c ****         case SAFEOP_2_BOOT:
1803:../SSC/Src/ecatslv.c ****         case OP_2_BOOT:
1804:../SSC/Src/ecatslv.c ****         case BOOT_2_PREOP:
1805:../SSC/Src/ecatslv.c ****         case BOOT_2_SAFEOP:
1806:../SSC/Src/ecatslv.c ****         case BOOT_2_OP:
1807:../SSC/Src/ecatslv.c ****             result = ALSTATUSCODE_INVALIDALCONTROL;
 3655              	 .loc 3 1807 0
 3656 05a2 1123     	 movs r3,#17
 3657 05a4 FB81     	 strh r3,[r7,#14]
1808:../SSC/Src/ecatslv.c ****             break;
 3658              	 .loc 3 1808 0
 3659 05a6 02E0     	 b .L221
 3660              	.L204:
1809:../SSC/Src/ecatslv.c **** 
1810:../SSC/Src/ecatslv.c ****         default:
1811:../SSC/Src/ecatslv.c ****             result = ALSTATUSCODE_UNKNOWNALCONTROL;
 3661              	 .loc 3 1811 0
 3662 05a8 1223     	 movs r3,#18
 3663 05aa FB81     	 strh r3,[r7,#14]
1812:../SSC/Src/ecatslv.c ****             break;
 3664              	 .loc 3 1812 0
 3665 05ac 00BF     	 nop
 3666              	.L221:
 3667 05ae 38E0     	 b .L243
 3668              	.L203:
1813:../SSC/Src/ecatslv.c ****         }
1814:../SSC/Src/ecatslv.c ****     }
1815:../SSC/Src/ecatslv.c ****     else
1816:../SSC/Src/ecatslv.c ****     {
1817:../SSC/Src/ecatslv.c ****         /* the checking of the sync manager settings was not successful
1818:../SSC/Src/ecatslv.c ****             switch back the state to PREOP or INIT */
1819:../SSC/Src/ecatslv.c ****         switch (nAlStatus)
 3669              	 .loc 3 1819 0
 3670 05b0 174B     	 ldr r3,.L266+28
 3671 05b2 1B78     	 ldrb r3,[r3]
 3672 05b4 042B     	 cmp r3,#4
 3673 05b6 08D0     	 beq .L244
 3674 05b8 082B     	 cmp r3,#8
 3675 05ba 02D0     	 beq .L245
 3676 05bc 022B     	 cmp r3,#2
 3677 05be 08D0     	 beq .L246
 3678 05c0 2FE0     	 b .L243
 3679              	.L245:
1820:../SSC/Src/ecatslv.c ****         {
1821:../SSC/Src/ecatslv.c ****         case STATE_OP:
1822:../SSC/Src/ecatslv.c ****             /* stop the output handler (function is defined above) */
1823:../SSC/Src/ecatslv.c ****             APPL_StopOutputHandler();
 3680              	 .loc 3 1823 0
 3681 05c2 FFF7FEFF 	 bl APPL_StopOutputHandler
1824:../SSC/Src/ecatslv.c ****             StopOutputHandler();
 3682              	 .loc 3 1824 0
 3683 05c6 FFF7FEFF 	 bl StopOutputHandler
 3684              	.L244:
1825:../SSC/Src/ecatslv.c ****         case STATE_SAFEOP:
1826:../SSC/Src/ecatslv.c ****             /* stop the input handler (function is defined above) */
1827:../SSC/Src/ecatslv.c ****             APPL_StopInputHandler();
 3685              	 .loc 3 1827 0
 3686 05ca FFF7FEFF 	 bl APPL_StopInputHandler
1828:../SSC/Src/ecatslv.c **** 
1829:../SSC/Src/ecatslv.c ****             StopInputHandler();
 3687              	 .loc 3 1829 0
 3688 05ce FFF7FEFF 	 bl StopInputHandler
 3689              	.L246:
1830:../SSC/Src/ecatslv.c ****         case STATE_PREOP:
1831:../SSC/Src/ecatslv.c ****             if ( result == ALSTATUSCODE_INVALIDMBXCFGINPREOP )
 3690              	 .loc 3 1831 0
 3691 05d2 FB89     	 ldrh r3,[r7,#14]
 3692 05d4 162B     	 cmp r3,#22
 3693 05d6 21D1     	 bne .L247
1832:../SSC/Src/ecatslv.c ****             {
1833:../SSC/Src/ecatslv.c ****                 /* the mailbox sync manager settings were wrong, switch back to INIT */
1834:../SSC/Src/ecatslv.c ****                 MBX_StopMailboxHandler();
 3694              	 .loc 3 1834 0
 3695 05d8 FFF7FEFF 	 bl MBX_StopMailboxHandler
1835:../SSC/Src/ecatslv.c ****                 APPL_StopMailboxHandler();
 3696              	 .loc 3 1835 0
 3697 05dc FFF7FEFF 	 bl APPL_StopMailboxHandler
1836:../SSC/Src/ecatslv.c **** 
1837:../SSC/Src/ecatslv.c ****                 /*Disable SM0 (MBX Out)*/
1838:../SSC/Src/ecatslv.c ****                 DisableSyncManChannel(MAILBOX_WRITE);
 3698              	 .loc 3 1838 0
 3699 05e0 0020     	 movs r0,#0
 3700 05e2 FFF7FEFF 	 bl DisableSyncManChannel
1839:../SSC/Src/ecatslv.c **** 
1840:../SSC/Src/ecatslv.c ****                 /*Disable SM1 (MBX In)*/
1841:../SSC/Src/ecatslv.c ****                 DisableSyncManChannel(MAILBOX_READ);
 3701              	 .loc 3 1841 0
 3702 05e6 0120     	 movs r0,#1
 3703 05e8 FFF7FEFF 	 bl DisableSyncManChannel
1842:../SSC/Src/ecatslv.c **** 
1843:../SSC/Src/ecatslv.c ****                 nAlStatus = STATE_INIT;
 3704              	 .loc 3 1843 0
 3705 05ec 084B     	 ldr r3,.L266+28
 3706 05ee 0122     	 movs r2,#1
 3707 05f0 1A70     	 strb r2,[r3]
 3708 05f2 16E0     	 b .L243
 3709              	.L267:
 3710              	 .align 2
 3711              	.L266:
 3712 05f4 00000000 	 .word bApplEsmPending
 3713 05f8 00000000 	 .word bMbxRunning
 3714 05fc 00000000 	 .word bBootMode
 3715 0600 00000000 	 .word EepromLoaded
 3716 0604 00000000 	 .word u16ALEventMask
 3717 0608 00000000 	 .word bEcatInputUpdateRunning
 3718 060c 00000000 	 .word bEcatOutputUpdateRunning
 3719 0610 00000000 	 .word nAlStatus
 3720 0614 00000000 	 .word nPdOutputSize
 3721 0618 00000000 	 .word nPdInputSize
 3722              	.L247:
1844:../SSC/Src/ecatslv.c ****             }
1845:../SSC/Src/ecatslv.c ****             else
1846:../SSC/Src/ecatslv.c ****             {
1847:../SSC/Src/ecatslv.c ****                 nAlStatus = STATE_PREOP;
 3723              	 .loc 3 1847 0
 3724 061c 4E4B     	 ldr r3,.L268
 3725 061e 0222     	 movs r2,#2
 3726 0620 1A70     	 strb r2,[r3]
 3727              	.L243:
1848:../SSC/Src/ecatslv.c ****             }
1849:../SSC/Src/ecatslv.c ****         }
1850:../SSC/Src/ecatslv.c ****     }
1851:../SSC/Src/ecatslv.c **** 
1852:../SSC/Src/ecatslv.c ****     if ( result == NOERROR_INWORK )
 3728              	 .loc 3 1852 0
 3729 0622 FB89     	 ldrh r3,[r7,#14]
 3730 0624 FF2B     	 cmp r3,#255
 3731 0626 35D1     	 bne .L248
1853:../SSC/Src/ecatslv.c ****     {
1854:../SSC/Src/ecatslv.c ****         /* state transition is still in work
1855:../SSC/Src/ecatslv.c ****             ECAT_StateChange must be called from the application */
1856:../SSC/Src/ecatslv.c ****         bEcatWaitForAlControlRes = TRUE;
 3732              	 .loc 3 1856 0
 3733 0628 4C4B     	 ldr r3,.L268+4
 3734 062a 0122     	 movs r2,#1
 3735 062c 1A70     	 strb r2,[r3]
1857:../SSC/Src/ecatslv.c ****         /* state transition has to be stored */
1858:../SSC/Src/ecatslv.c ****         nEcatStateTrans = stateTrans;
 3736              	 .loc 3 1858 0
 3737 062e 3B7B     	 ldrb r3,[r7,#12]
 3738 0630 9AB2     	 uxth r2,r3
 3739 0632 4B4B     	 ldr r3,.L268+8
 3740 0634 1A80     	 strh r2,[r3]
1859:../SSC/Src/ecatslv.c **** 
1860:../SSC/Src/ecatslv.c ****         /*Init ESM timeout counter (will be decremented with the local 1ms timer)*/
1861:../SSC/Src/ecatslv.c ****         switch(nEcatStateTrans)
 3741              	 .loc 3 1861 0
 3742 0636 4A4B     	 ldr r3,.L268+8
 3743 0638 1B88     	 ldrh r3,[r3]
 3744 063a 242B     	 cmp r3,#36
 3745 063c 0DD0     	 beq .L250
 3746 063e 242B     	 cmp r3,#36
 3747 0640 03DC     	 bgt .L251
 3748 0642 123B     	 subs r3,r3,#18
 3749 0644 012B     	 cmp r3,#1
 3750 0646 0DD8     	 bhi .L249
 3751 0648 02E0     	 b .L263
 3752              	.L251:
 3753 064a 482B     	 cmp r3,#72
 3754 064c 05D0     	 beq .L250
 3755 064e 09E0     	 b .L249
 3756              	.L263:
1862:../SSC/Src/ecatslv.c ****         {
1863:../SSC/Src/ecatslv.c ****             case INIT_2_PREOP:
1864:../SSC/Src/ecatslv.c ****             case INIT_2_BOOT:
1865:../SSC/Src/ecatslv.c ****                 EsmTimeoutCounter = PREOPTIMEOUT;
 3757              	 .loc 3 1865 0
 3758 0650 444B     	 ldr r3,.L268+12
 3759 0652 4FF4FA62 	 mov r2,#2000
 3760 0656 1A80     	 strh r2,[r3]
1866:../SSC/Src/ecatslv.c ****             break;
 3761              	 .loc 3 1866 0
 3762 0658 08E0     	 b .L253
 3763              	.L250:
1867:../SSC/Src/ecatslv.c ****             case PREOP_2_SAFEOP:
1868:../SSC/Src/ecatslv.c ****             case SAFEOP_2_OP:
1869:../SSC/Src/ecatslv.c ****                 EsmTimeoutCounter = SAFEOP2OPTIMEOUT;
 3764              	 .loc 3 1869 0
 3765 065a 424B     	 ldr r3,.L268+12
 3766 065c 42F22832 	 movw r2,#9000
 3767 0660 1A80     	 strh r2,[r3]
1870:../SSC/Src/ecatslv.c ****                 break;
 3768              	 .loc 3 1870 0
 3769 0662 03E0     	 b .L253
 3770              	.L249:
1871:../SSC/Src/ecatslv.c ****            default:
1872:../SSC/Src/ecatslv.c ****                 EsmTimeoutCounter = 200; //Set default timeout value to 200ms
 3771              	 .loc 3 1872 0
 3772 0664 3F4B     	 ldr r3,.L268+12
 3773 0666 C822     	 movs r2,#200
 3774 0668 1A80     	 strh r2,[r3]
1873:../SSC/Src/ecatslv.c ****                 break;
 3775              	 .loc 3 1873 0
 3776 066a 00BF     	 nop
 3777              	.L253:
1874:../SSC/Src/ecatslv.c ****         }
1875:../SSC/Src/ecatslv.c ****         /*ECATCHANGE_START(V5.12) ESM3*/
1876:../SSC/Src/ecatslv.c ****         EsmTimeoutCounter -= (INT16) (EsmTimeoutCounter / 10); //subtract 10% from the timeout to r
 3778              	 .loc 3 1876 0
 3779 066c 3D4B     	 ldr r3,.L268+12
 3780 066e 1B88     	 ldrh r3,[r3]
 3781 0670 9AB2     	 uxth r2,r3
 3782 0672 3C4B     	 ldr r3,.L268+12
 3783 0674 1B88     	 ldrh r3,[r3]
 3784 0676 1BB2     	 sxth r3,r3
 3785 0678 3B49     	 ldr r1,.L268+16
 3786 067a 81FB0301 	 smull r0,r1,r1,r3
 3787 067e 8910     	 asrs r1,r1,#2
 3788 0680 DB17     	 asrs r3,r3,#31
 3789 0682 CB1A     	 subs r3,r1,r3
 3790 0684 9BB2     	 uxth r3,r3
 3791 0686 9BB2     	 uxth r3,r3
 3792 0688 D31A     	 subs r3,r2,r3
 3793 068a 9BB2     	 uxth r3,r3
 3794 068c 9AB2     	 uxth r2,r3
 3795 068e 354B     	 ldr r3,.L268+12
 3796 0690 1A80     	 strh r2,[r3]
 3797 0692 5EE0     	 b .L191
 3798              	.L248:
1877:../SSC/Src/ecatslv.c ****         /*ECATCHANGE_END(V5.12) ESM3*/
1878:../SSC/Src/ecatslv.c **** 
1879:../SSC/Src/ecatslv.c ****     }
1880:../SSC/Src/ecatslv.c ****     else if ( alControl != (nAlStatus & STATE_MASK) )
 3799              	 .loc 3 1880 0
 3800 0694 FA79     	 ldrb r2,[r7,#7]
 3801 0696 304B     	 ldr r3,.L268
 3802 0698 1B78     	 ldrb r3,[r3]
 3803 069a 03F00F03 	 and r3,r3,#15
 3804 069e 9A42     	 cmp r2,r3
 3805 06a0 4ED0     	 beq .L254
1881:../SSC/Src/ecatslv.c ****     {
1882:../SSC/Src/ecatslv.c ****         /* The slave state has changed */
1883:../SSC/Src/ecatslv.c **** 
1884:../SSC/Src/ecatslv.c ****         if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
 3806              	 .loc 3 1884 0
 3807 06a2 FB89     	 ldrh r3,[r7,#14]
 3808 06a4 002B     	 cmp r3,#0
 3809 06a6 02D1     	 bne .L255
 3810              	 .loc 3 1884 0 is_stmt 0 discriminator 2
 3811 06a8 BB88     	 ldrh r3,[r7,#4]
 3812 06aa 002B     	 cmp r3,#0
 3813 06ac 1FD0     	 beq .L256
 3814              	.L255:
 3815              	 .loc 3 1884 0 discriminator 3
 3816 06ae 2A4B     	 ldr r3,.L268
 3817 06b0 1A78     	 ldrb r2,[r3]
 3818 06b2 FB79     	 ldrb r3,[r7,#7]
 3819 06b4 1343     	 orrs r3,r3,r2
 3820 06b6 DBB2     	 uxtb r3,r3
 3821 06b8 03F00803 	 and r3,r3,#8
 3822 06bc 002B     	 cmp r3,#0
 3823 06be 16D0     	 beq .L256
1885:../SSC/Src/ecatslv.c ****         {
1886:../SSC/Src/ecatslv.c ****             /* the local application requested to leave the state OP so we have to disable the SM2
1887:../SSC/Src/ecatslv.c ****                and make the state change from OP to SAFEOP by calling StopOutputHandler */
1888:../SSC/Src/ecatslv.c **** 
1889:../SSC/Src/ecatslv.c ****             //only execute StopOutputHandler() if Output update is still running
1890:../SSC/Src/ecatslv.c ****             if(bEcatOutputUpdateRunning)
 3824              	 .loc 3 1890 0 is_stmt 1
 3825 06c0 2A4B     	 ldr r3,.L268+20
 3826 06c2 1B78     	 ldrb r3,[r3]
 3827 06c4 002B     	 cmp r3,#0
 3828 06c6 03D0     	 beq .L257
1891:../SSC/Src/ecatslv.c ****             {
1892:../SSC/Src/ecatslv.c ****                 APPL_StopOutputHandler();
 3829              	 .loc 3 1892 0
 3830 06c8 FFF7FEFF 	 bl APPL_StopOutputHandler
1893:../SSC/Src/ecatslv.c **** 
1894:../SSC/Src/ecatslv.c ****                 StopOutputHandler();
 3831              	 .loc 3 1894 0
 3832 06cc FFF7FEFF 	 bl StopOutputHandler
 3833              	.L257:
1895:../SSC/Src/ecatslv.c ****             }
1896:../SSC/Src/ecatslv.c **** 
1897:../SSC/Src/ecatslv.c ****             if(nPdOutputSize > 0)
 3834              	 .loc 3 1897 0
 3835 06d0 274B     	 ldr r3,.L268+24
 3836 06d2 1B88     	 ldrh r3,[r3]
 3837 06d4 002B     	 cmp r3,#0
 3838 06d6 03D0     	 beq .L258
1898:../SSC/Src/ecatslv.c ****             {
1899:../SSC/Src/ecatslv.c ****                 /* disable the Sync Manager Channel 2 (outputs) */
1900:../SSC/Src/ecatslv.c ****                 DisableSyncManChannel(PROCESS_DATA_OUT);
 3839              	 .loc 3 1900 0
 3840 06d8 0220     	 movs r0,#2
 3841 06da FFF7FEFF 	 bl DisableSyncManChannel
 3842 06de 06E0     	 b .L256
 3843              	.L258:
1901:../SSC/Src/ecatslv.c ****             }
1902:../SSC/Src/ecatslv.c ****             else
1903:../SSC/Src/ecatslv.c ****                 if(nPdInputSize > 0)
 3844              	 .loc 3 1903 0
 3845 06e0 244B     	 ldr r3,.L268+28
 3846 06e2 1B88     	 ldrh r3,[r3]
 3847 06e4 002B     	 cmp r3,#0
 3848 06e6 02D0     	 beq .L256
1904:../SSC/Src/ecatslv.c ****             {
1905:../SSC/Src/ecatslv.c ****                 /*disable Sync Manager 3 (inputs) if no outputs available*/
1906:../SSC/Src/ecatslv.c ****                 DisableSyncManChannel(PROCESS_DATA_IN);
 3849              	 .loc 3 1906 0
 3850 06e8 0320     	 movs r0,#3
 3851 06ea FFF7FEFF 	 bl DisableSyncManChannel
 3852              	.L256:
1907:../SSC/Src/ecatslv.c ****             }
1908:../SSC/Src/ecatslv.c **** 
1909:../SSC/Src/ecatslv.c ****         }
1910:../SSC/Src/ecatslv.c ****         if ( result != 0 )
 3853              	 .loc 3 1910 0
 3854 06ee FB89     	 ldrh r3,[r7,#14]
 3855 06f0 002B     	 cmp r3,#0
 3856 06f2 0ED0     	 beq .L259
1911:../SSC/Src/ecatslv.c ****         {
1912:../SSC/Src/ecatslv.c ****                 if (nAlStatus == STATE_OP)
 3857              	 .loc 3 1912 0
 3858 06f4 184B     	 ldr r3,.L268
 3859 06f6 1B78     	 ldrb r3,[r3]
 3860 06f8 082B     	 cmp r3,#8
 3861 06fa 02D1     	 bne .L260
1913:../SSC/Src/ecatslv.c ****                 {
1914:../SSC/Src/ecatslv.c ****                     nAlStatus = STATE_SAFEOP;
 3862              	 .loc 3 1914 0
 3863 06fc 164B     	 ldr r3,.L268
 3864 06fe 0422     	 movs r2,#4
 3865 0700 1A70     	 strb r2,[r3]
 3866              	.L260:
1915:../SSC/Src/ecatslv.c ****                 }
1916:../SSC/Src/ecatslv.c ****             /* save the failed status to be able to decide, if the AL Status Code shall be
1917:../SSC/Src/ecatslv.c ****                reset in case of a coming successful state transition */
1918:../SSC/Src/ecatslv.c ****             nAlStatus |= STATE_CHANGE;
 3867              	 .loc 3 1918 0
 3868 0702 154B     	 ldr r3,.L268
 3869 0704 1B78     	 ldrb r3,[r3]
 3870 0706 43F01003 	 orr r3,r3,#16
 3871 070a DAB2     	 uxtb r2,r3
 3872 070c 124B     	 ldr r3,.L268
 3873 070e 1A70     	 strb r2,[r3]
 3874 0710 0BE0     	 b .L261
 3875              	.L259:
1919:../SSC/Src/ecatslv.c ****         }
1920:../SSC/Src/ecatslv.c ****         else
1921:../SSC/Src/ecatslv.c ****         {
1922:../SSC/Src/ecatslv.c ****             /* state transition was successful */
1923:../SSC/Src/ecatslv.c ****             if ( alStatusCode != 0 )
 3876              	 .loc 3 1923 0
 3877 0712 BB88     	 ldrh r3,[r7,#4]
 3878 0714 002B     	 cmp r3,#0
 3879 0716 05D0     	 beq .L262
1924:../SSC/Src/ecatslv.c ****             {
1925:../SSC/Src/ecatslv.c ****                 /* state change request from the user */
1926:../SSC/Src/ecatslv.c ****                 result = alStatusCode;
 3880              	 .loc 3 1926 0
 3881 0718 BB88     	 ldrh r3,[r7,#4]
 3882 071a FB81     	 strh r3,[r7,#14]
1927:../SSC/Src/ecatslv.c ****                 alControl |= STATE_CHANGE;
 3883              	 .loc 3 1927 0
 3884 071c FB79     	 ldrb r3,[r7,#7]
 3885 071e 43F01003 	 orr r3,r3,#16
 3886 0722 FB71     	 strb r3,[r7,#7]
 3887              	.L262:
1928:../SSC/Src/ecatslv.c ****             }
1929:../SSC/Src/ecatslv.c ****             /* acknowledge the new state */
1930:../SSC/Src/ecatslv.c ****             nAlStatus = alControl;
 3888              	 .loc 3 1930 0
 3889 0724 0C4A     	 ldr r2,.L268
 3890 0726 FB79     	 ldrb r3,[r7,#7]
 3891 0728 1370     	 strb r3,[r2]
 3892              	.L261:
1931:../SSC/Src/ecatslv.c ****         }
1932:../SSC/Src/ecatslv.c **** 
1933:../SSC/Src/ecatslv.c ****         bEcatWaitForAlControlRes = FALSE;
 3893              	 .loc 3 1933 0
 3894 072a 0C4B     	 ldr r3,.L268+4
 3895 072c 0022     	 movs r2,#0
 3896 072e 1A70     	 strb r2,[r3]
1934:../SSC/Src/ecatslv.c **** 
1935:../SSC/Src/ecatslv.c ****         /* write the AL Status register */
1936:../SSC/Src/ecatslv.c ****         SetALStatus(nAlStatus, result);
 3897              	 .loc 3 1936 0
 3898 0730 094B     	 ldr r3,.L268
 3899 0732 1A78     	 ldrb r2,[r3]
 3900 0734 FB89     	 ldrh r3,[r7,#14]
 3901 0736 1046     	 mov r0,r2
 3902 0738 1946     	 mov r1,r3
 3903 073a FFF7FEFF 	 bl SetALStatus
 3904 073e 08E0     	 b .L191
 3905              	.L254:
1937:../SSC/Src/ecatslv.c ****     }
1938:../SSC/Src/ecatslv.c ****     else
1939:../SSC/Src/ecatslv.c ****     {
1940:../SSC/Src/ecatslv.c ****         /* Error acknowledgement without a state transition */
1941:../SSC/Src/ecatslv.c **** 
1942:../SSC/Src/ecatslv.c ****          bEcatWaitForAlControlRes = FALSE;
 3906              	 .loc 3 1942 0
 3907 0740 064B     	 ldr r3,.L268+4
 3908 0742 0022     	 movs r2,#0
 3909 0744 1A70     	 strb r2,[r3]
1943:../SSC/Src/ecatslv.c **** 
1944:../SSC/Src/ecatslv.c ****         /* AL-Status has to be updated and AL-Status-Code has to be reset
1945:../SSC/Src/ecatslv.c ****            if the the error bit was acknowledged */
1946:../SSC/Src/ecatslv.c ****         SetALStatus(nAlStatus, 0);
 3910              	 .loc 3 1946 0
 3911 0746 044B     	 ldr r3,.L268
 3912 0748 1B78     	 ldrb r3,[r3]
 3913 074a 1846     	 mov r0,r3
 3914 074c 0021     	 movs r1,#0
 3915 074e FFF7FEFF 	 bl SetALStatus
 3916              	.L191:
1947:../SSC/Src/ecatslv.c ****     }
1948:../SSC/Src/ecatslv.c **** 
1949:../SSC/Src/ecatslv.c **** }
 3917              	 .loc 3 1949 0
 3918 0752 1037     	 adds r7,r7,#16
 3919              	.LCFI82:
 3920              	 .cfi_def_cfa_offset 8
 3921 0754 BD46     	 mov sp,r7
 3922              	.LCFI83:
 3923              	 .cfi_def_cfa_register 13
 3924              	 
 3925 0756 80BD     	 pop {r7,pc}
 3926              	.L269:
 3927              	 .align 2
 3928              	.L268:
 3929 0758 00000000 	 .word nAlStatus
 3930 075c 00000000 	 .word bEcatWaitForAlControlRes
 3931 0760 00000000 	 .word nEcatStateTrans
 3932 0764 00000000 	 .word EsmTimeoutCounter
 3933 0768 67666666 	 .word 1717986919
 3934 076c 00000000 	 .word bEcatOutputUpdateRunning
 3935 0770 00000000 	 .word nPdOutputSize
 3936 0774 00000000 	 .word nPdInputSize
 3937              	 .cfi_endproc
 3938              	.LFE190:
 3940              	 .section .text.AL_ControlRes,"ax",%progbits
 3941              	 .align 2
 3942              	 .global AL_ControlRes
 3943              	 .thumb
 3944              	 .thumb_func
 3946              	AL_ControlRes:
 3947              	.LFB191:
1950:../SSC/Src/ecatslv.c **** 
1951:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1952:../SSC/Src/ecatslv.c **** /**
1953:../SSC/Src/ecatslv.c **** 
1954:../SSC/Src/ecatslv.c ****  \brief    This function is called cyclic if a state transition is pending (bEcatWaitForAlControlRe
1955:../SSC/Src/ecatslv.c ****  \brief    If the ESM timeout is expired the state transition will be rejected. Otherwise the appli
1956:../SSC/Src/ecatslv.c ****  \brief    If the pending state transition is triggered by the application the transition need to b
1957:../SSC/Src/ecatslv.c ****   *////////////////////////////////////////////////////////////////////////////////////////
1958:../SSC/Src/ecatslv.c **** void AL_ControlRes(void)
1959:../SSC/Src/ecatslv.c **** {
 3948              	 .loc 3 1959 0
 3949              	 .cfi_startproc
 3950              	 
 3951              	 
 3952 0000 80B5     	 push {r7,lr}
 3953              	.LCFI84:
 3954              	 .cfi_def_cfa_offset 8
 3955              	 .cfi_offset 7,-8
 3956              	 .cfi_offset 14,-4
 3957 0002 82B0     	 sub sp,sp,#8
 3958              	.LCFI85:
 3959              	 .cfi_def_cfa_offset 16
 3960 0004 00AF     	 add r7,sp,#0
 3961              	.LCFI86:
 3962              	 .cfi_def_cfa_register 7
1960:../SSC/Src/ecatslv.c ****     if(bEcatWaitForAlControlRes)
 3963              	 .loc 3 1960 0
 3964 0006 A14B     	 ldr r3,.L312
 3965 0008 1B78     	 ldrb r3,[r3]
 3966 000a 002B     	 cmp r3,#0
 3967 000c 00F03B81 	 beq .L270
 3968              	.LBB8:
1961:../SSC/Src/ecatslv.c ****     {
1962:../SSC/Src/ecatslv.c ****         UINT16 result = 0;
 3969              	 .loc 3 1962 0
 3970 0010 0023     	 movs r3,#0
 3971 0012 7B80     	 strh r3,[r7,#2]
1963:../SSC/Src/ecatslv.c ****         UINT8 Status = 0;
 3972              	 .loc 3 1963 0
 3973 0014 0023     	 movs r3,#0
 3974 0016 FB71     	 strb r3,[r7,#7]
1964:../SSC/Src/ecatslv.c ****         UINT16 StatusCode = 0;
 3975              	 .loc 3 1964 0
 3976 0018 0023     	 movs r3,#0
 3977 001a BB80     	 strh r3,[r7,#4]
1965:../SSC/Src/ecatslv.c **** 
1966:../SSC/Src/ecatslv.c ****         if(EsmTimeoutCounter == 0)
 3978              	 .loc 3 1966 0
 3979 001c 9C4B     	 ldr r3,.L312+4
 3980 001e 1B88     	 ldrh r3,[r3]
 3981 0020 002B     	 cmp r3,#0
 3982 0022 7CD1     	 bne .L272
1967:../SSC/Src/ecatslv.c ****         {
1968:../SSC/Src/ecatslv.c ****             Status =  (UINT8)(nEcatStateTrans >> 4);
 3983              	 .loc 3 1968 0
 3984 0024 9B4B     	 ldr r3,.L312+8
 3985 0026 1B88     	 ldrh r3,[r3]
 3986 0028 1B09     	 lsrs r3,r3,#4
 3987 002a 9BB2     	 uxth r3,r3
 3988 002c FB71     	 strb r3,[r7,#7]
1969:../SSC/Src/ecatslv.c **** 
1970:../SSC/Src/ecatslv.c ****             /* ESM timeout expired*/
1971:../SSC/Src/ecatslv.c ****             switch(nEcatStateTrans)
 3989              	 .loc 3 1971 0
 3990 002e 994B     	 ldr r3,.L312+8
 3991 0030 1B88     	 ldrh r3,[r3]
 3992 0032 242B     	 cmp r3,#36
 3993 0034 1FD0     	 beq .L274
 3994 0036 242B     	 cmp r3,#36
 3995 0038 04DC     	 bgt .L275
 3996 003a 123B     	 subs r3,r3,#18
 3997 003c 012B     	 cmp r3,#1
 3998 003e 00F20F81 	 bhi .L292
 3999 0042 02E0     	 b .L308
 4000              	.L275:
 4001 0044 482B     	 cmp r3,#72
 4002 0046 2CD0     	 beq .L277
 4003 0048 0AE1     	 b .L292
 4004              	.L308:
1972:../SSC/Src/ecatslv.c ****             {
1973:../SSC/Src/ecatslv.c ****                 case INIT_2_PREOP:
1974:../SSC/Src/ecatslv.c ****                 case INIT_2_BOOT:
1975:../SSC/Src/ecatslv.c **** 
1976:../SSC/Src/ecatslv.c ****                         if (!bApplEsmPending)
 4005              	 .loc 3 1976 0
 4006 004a 934B     	 ldr r3,.L312+12
 4007 004c 1B78     	 ldrb r3,[r3]
 4008 004e 83F00103 	 eor r3,r3,#1
 4009 0052 DBB2     	 uxtb r3,r3
 4010 0054 002B     	 cmp r3,#0
 4011 0056 01D0     	 beq .L278
1977:../SSC/Src/ecatslv.c ****                         {
1978:../SSC/Src/ecatslv.c ****                             APPL_StopMailboxHandler();
 4012              	 .loc 3 1978 0
 4013 0058 FFF7FEFF 	 bl APPL_StopMailboxHandler
 4014              	.L278:
1979:../SSC/Src/ecatslv.c ****                         }
1980:../SSC/Src/ecatslv.c **** 
1981:../SSC/Src/ecatslv.c ****                     MBX_StopMailboxHandler();
 4015              	 .loc 3 1981 0
 4016 005c FFF7FEFF 	 bl MBX_StopMailboxHandler
1982:../SSC/Src/ecatslv.c ****                     if(bLocalErrorFlag)
 4017              	 .loc 3 1982 0
 4018 0060 8E4B     	 ldr r3,.L312+16
 4019 0062 1B78     	 ldrb r3,[r3]
 4020 0064 002B     	 cmp r3,#0
 4021 0066 03D0     	 beq .L279
1983:../SSC/Src/ecatslv.c ****                     {
1984:../SSC/Src/ecatslv.c ****                         /*Set application specified error*/
1985:../SSC/Src/ecatslv.c ****                         StatusCode = u16LocalErrorCode;
 4022              	 .loc 3 1985 0
 4023 0068 8D4B     	 ldr r3,.L312+20
 4024 006a 1B88     	 ldrh r3,[r3]
 4025 006c BB80     	 strh r3,[r7,#4]
1986:../SSC/Src/ecatslv.c ****                     }
1987:../SSC/Src/ecatslv.c ****                     else
1988:../SSC/Src/ecatslv.c ****                     {
1989:../SSC/Src/ecatslv.c ****                         /*Set unspecified error*/
1990:../SSC/Src/ecatslv.c ****                         StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
1991:../SSC/Src/ecatslv.c ****                     }
1992:../SSC/Src/ecatslv.c ****                 break;
 4026              	 .loc 3 1992 0
 4027 006e 55E0     	 b .L273
 4028              	.L279:
1990:../SSC/Src/ecatslv.c ****                     }
 4029              	 .loc 3 1990 0
 4030 0070 0123     	 movs r3,#1
 4031 0072 BB80     	 strh r3,[r7,#4]
 4032              	 .loc 3 1992 0
 4033 0074 52E0     	 b .L273
 4034              	.L274:
1993:../SSC/Src/ecatslv.c ****                 case PREOP_2_SAFEOP:
1994:../SSC/Src/ecatslv.c **** 
1995:../SSC/Src/ecatslv.c ****                         if (!bApplEsmPending)
 4035              	 .loc 3 1995 0
 4036 0076 884B     	 ldr r3,.L312+12
 4037 0078 1B78     	 ldrb r3,[r3]
 4038 007a 83F00103 	 eor r3,r3,#1
 4039 007e DBB2     	 uxtb r3,r3
 4040 0080 002B     	 cmp r3,#0
 4041 0082 01D0     	 beq .L281
1996:../SSC/Src/ecatslv.c ****                         {
1997:../SSC/Src/ecatslv.c ****                             APPL_StopInputHandler();
 4042              	 .loc 3 1997 0
 4043 0084 FFF7FEFF 	 bl APPL_StopInputHandler
 4044              	.L281:
1998:../SSC/Src/ecatslv.c ****                         }
1999:../SSC/Src/ecatslv.c **** 
2000:../SSC/Src/ecatslv.c ****                     StopInputHandler();
 4045              	 .loc 3 2000 0
 4046 0088 FFF7FEFF 	 bl StopInputHandler
2001:../SSC/Src/ecatslv.c ****                     
2002:../SSC/Src/ecatslv.c ****                     if(bLocalErrorFlag)
 4047              	 .loc 3 2002 0
 4048 008c 834B     	 ldr r3,.L312+16
 4049 008e 1B78     	 ldrb r3,[r3]
 4050 0090 002B     	 cmp r3,#0
 4051 0092 03D0     	 beq .L282
2003:../SSC/Src/ecatslv.c ****                     {
2004:../SSC/Src/ecatslv.c ****                         /*Set application specified error*/
2005:../SSC/Src/ecatslv.c ****                         StatusCode = u16LocalErrorCode;
 4052              	 .loc 3 2005 0
 4053 0094 824B     	 ldr r3,.L312+20
 4054 0096 1B88     	 ldrh r3,[r3]
 4055 0098 BB80     	 strh r3,[r7,#4]
2006:../SSC/Src/ecatslv.c ****                     }
2007:../SSC/Src/ecatslv.c ****                     else
2008:../SSC/Src/ecatslv.c ****                     {
2009:../SSC/Src/ecatslv.c ****                         /*Set unspecified error*/
2010:../SSC/Src/ecatslv.c ****                         StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
2011:../SSC/Src/ecatslv.c ****                     }
2012:../SSC/Src/ecatslv.c ****                 break;
 4056              	 .loc 3 2012 0
 4057 009a 3FE0     	 b .L273
 4058              	.L282:
2010:../SSC/Src/ecatslv.c ****                     }
 4059              	 .loc 3 2010 0
 4060 009c 0123     	 movs r3,#1
 4061 009e BB80     	 strh r3,[r7,#4]
 4062              	 .loc 3 2012 0
 4063 00a0 3CE0     	 b .L273
 4064              	.L277:
2013:../SSC/Src/ecatslv.c ****                 case SAFEOP_2_OP:
2014:../SSC/Src/ecatslv.c ****                     if(bDcSyncActive)
 4065              	 .loc 3 2014 0
 4066 00a2 804B     	 ldr r3,.L312+24
 4067 00a4 1B78     	 ldrb r3,[r3]
 4068 00a6 002B     	 cmp r3,#0
 4069 00a8 1AD0     	 beq .L284
2015:../SSC/Src/ecatslv.c ****                     {
2016:../SSC/Src/ecatslv.c ****                         /*SafeOP to OP timeout expired check which AL status code need to be writte
2017:../SSC/Src/ecatslv.c ****                         if(!bDcRunning)
 4070              	 .loc 3 2017 0
 4071 00aa 7F4B     	 ldr r3,.L312+28
 4072 00ac 1B78     	 ldrb r3,[r3]
 4073 00ae 83F00103 	 eor r3,r3,#1
 4074 00b2 DBB2     	 uxtb r3,r3
 4075 00b4 002B     	 cmp r3,#0
 4076 00b6 02D0     	 beq .L285
2018:../SSC/Src/ecatslv.c ****                         {
2019:../SSC/Src/ecatslv.c ****                             /*no Sync0 signal received*/
2020:../SSC/Src/ecatslv.c ****                             StatusCode = ALSTATUSCODE_NOSYNCERROR;
 4077              	 .loc 3 2020 0
 4078 00b8 2D23     	 movs r3,#45
 4079 00ba BB80     	 strh r3,[r7,#4]
 4080 00bc 1EE0     	 b .L288
 4081              	.L285:
2021:../SSC/Src/ecatslv.c ****                         }
2022:../SSC/Src/ecatslv.c ****                         else if(!bEcatFirstOutputsReceived && (nPdOutputSize > 0))
 4082              	 .loc 3 2022 0
 4083 00be 7B4B     	 ldr r3,.L312+32
 4084 00c0 1B78     	 ldrb r3,[r3]
 4085 00c2 83F00103 	 eor r3,r3,#1
 4086 00c6 DBB2     	 uxtb r3,r3
 4087 00c8 002B     	 cmp r3,#0
 4088 00ca 06D0     	 beq .L287
 4089              	 .loc 3 2022 0 is_stmt 0 discriminator 1
 4090 00cc 784B     	 ldr r3,.L312+36
 4091 00ce 1B88     	 ldrh r3,[r3]
 4092 00d0 002B     	 cmp r3,#0
 4093 00d2 02D0     	 beq .L287
2023:../SSC/Src/ecatslv.c ****                         {
2024:../SSC/Src/ecatslv.c ****                             /*no process data received*/
2025:../SSC/Src/ecatslv.c ****                             StatusCode = ALSTATUSCODE_SMWATCHDOG;
 4094              	 .loc 3 2025 0 is_stmt 1
 4095 00d4 1B23     	 movs r3,#27
 4096 00d6 BB80     	 strh r3,[r7,#4]
 4097 00d8 10E0     	 b .L288
 4098              	.L287:
2026:../SSC/Src/ecatslv.c ****                         }
2027:../SSC/Src/ecatslv.c ****                         else
2028:../SSC/Src/ecatslv.c ****                         {
2029:../SSC/Src/ecatslv.c ****                             /*SM/Sync Sequence is not valid*/
2030:../SSC/Src/ecatslv.c ****                             StatusCode = ALSTATUSCODE_SYNCERROR;
 4099              	 .loc 3 2030 0
 4100 00da 1A23     	 movs r3,#26
 4101 00dc BB80     	 strh r3,[r7,#4]
 4102 00de 0DE0     	 b .L288
 4103              	.L284:
2031:../SSC/Src/ecatslv.c ****                         }
2032:../SSC/Src/ecatslv.c ****                     }
2033:../SSC/Src/ecatslv.c ****                     else
2034:../SSC/Src/ecatslv.c ****                     {
2035:../SSC/Src/ecatslv.c ****                         if (nPdOutputSize > 0)
 4104              	 .loc 3 2035 0
 4105 00e0 734B     	 ldr r3,.L312+36
 4106 00e2 1B88     	 ldrh r3,[r3]
 4107 00e4 002B     	 cmp r3,#0
 4108 00e6 02D0     	 beq .L289
2036:../SSC/Src/ecatslv.c ****                         {
2037:../SSC/Src/ecatslv.c ****                             StatusCode = ALSTATUSCODE_SMWATCHDOG;
 4109              	 .loc 3 2037 0
 4110 00e8 1B23     	 movs r3,#27
 4111 00ea BB80     	 strh r3,[r7,#4]
 4112 00ec 06E0     	 b .L288
 4113              	.L289:
2038:../SSC/Src/ecatslv.c ****                         }
2039:../SSC/Src/ecatslv.c ****                         else
2040:../SSC/Src/ecatslv.c ****                         {
2041:../SSC/Src/ecatslv.c ****                             /*Set valid state transition even if timeout expired*/
2042:../SSC/Src/ecatslv.c ****                             Status = STATE_OP;
 4114              	 .loc 3 2042 0
 4115 00ee 0823     	 movs r3,#8
 4116 00f0 FB71     	 strb r3,[r7,#7]
2043:../SSC/Src/ecatslv.c ****                             StatusCode = 0;
 4117              	 .loc 3 2043 0
 4118 00f2 0023     	 movs r3,#0
 4119 00f4 BB80     	 strh r3,[r7,#4]
2044:../SSC/Src/ecatslv.c ****                             /* Slave is OPERATIONAL */
2045:../SSC/Src/ecatslv.c ****                             bEcatOutputUpdateRunning = TRUE;
 4120              	 .loc 3 2045 0
 4121 00f6 6F4B     	 ldr r3,.L312+40
 4122 00f8 0122     	 movs r2,#1
 4123 00fa 1A70     	 strb r2,[r3]
 4124              	.L288:
2046:../SSC/Src/ecatslv.c ****                         }
2047:../SSC/Src/ecatslv.c ****                     }
2048:../SSC/Src/ecatslv.c **** 
2049:../SSC/Src/ecatslv.c ****                     /*Stop handler on failed transition*/
2050:../SSC/Src/ecatslv.c ****                     if(StatusCode != 0)
 4125              	 .loc 3 2050 0
 4126 00fc BB88     	 ldrh r3,[r7,#4]
 4127 00fe 002B     	 cmp r3,#0
 4128 0100 0BD0     	 beq .L290
2051:../SSC/Src/ecatslv.c ****                     {
2052:../SSC/Src/ecatslv.c ****                             if (!bApplEsmPending)
 4129              	 .loc 3 2052 0
 4130 0102 654B     	 ldr r3,.L312+12
 4131 0104 1B78     	 ldrb r3,[r3]
 4132 0106 83F00103 	 eor r3,r3,#1
 4133 010a DBB2     	 uxtb r3,r3
 4134 010c 002B     	 cmp r3,#0
 4135 010e 01D0     	 beq .L291
2053:../SSC/Src/ecatslv.c ****                             {
2054:../SSC/Src/ecatslv.c ****                                 APPL_StopOutputHandler();
 4136              	 .loc 3 2054 0
 4137 0110 FFF7FEFF 	 bl APPL_StopOutputHandler
 4138              	.L291:
2055:../SSC/Src/ecatslv.c ****                             }
2056:../SSC/Src/ecatslv.c **** 
2057:../SSC/Src/ecatslv.c ****                         StopOutputHandler();
 4139              	 .loc 3 2057 0
 4140 0114 FFF7FEFF 	 bl StopOutputHandler
2058:../SSC/Src/ecatslv.c ****                     }
2059:../SSC/Src/ecatslv.c ****                 break;
 4141              	 .loc 3 2059 0
 4142 0118 FFE7     	 b .L310
 4143              	.L290:
 4144              	.L310:
 4145 011a 00BF     	 nop
 4146              	.L273:
 4147 011c A0E0     	 b .L292
 4148              	.L272:
2060:../SSC/Src/ecatslv.c ****             }
2061:../SSC/Src/ecatslv.c ****         } //ESM timeout
2062:../SSC/Src/ecatslv.c ****         else
2063:../SSC/Src/ecatslv.c ****         {
2064:../SSC/Src/ecatslv.c ****             /*Call application specific transition function and complete transition it the function
2065:../SSC/Src/ecatslv.c ****             switch(nEcatStateTrans)
 4149              	 .loc 3 2065 0
 4150 011e 5D4B     	 ldr r3,.L312+8
 4151 0120 1B88     	 ldrh r3,[r3]
 4152 0122 242B     	 cmp r3,#36
 4153 0124 2AD0     	 beq .L293
 4154 0126 242B     	 cmp r3,#36
 4155 0128 04DC     	 bgt .L294
 4156 012a 123B     	 subs r3,r3,#18
 4157 012c 012B     	 cmp r3,#1
 4158 012e 00F29780 	 bhi .L292
 4159 0132 02E0     	 b .L309
 4160              	.L294:
 4161 0134 482B     	 cmp r3,#72
 4162 0136 3FD0     	 beq .L296
 4163 0138 92E0     	 b .L292
 4164              	.L309:
2066:../SSC/Src/ecatslv.c ****             {
2067:../SSC/Src/ecatslv.c ****                 case INIT_2_PREOP:
2068:../SSC/Src/ecatslv.c ****                 case INIT_2_BOOT:
2069:../SSC/Src/ecatslv.c ****                     if(bApplEsmPending)
 4165              	 .loc 3 2069 0
 4166 013a 574B     	 ldr r3,.L312+12
 4167 013c 1B78     	 ldrb r3,[r3]
 4168 013e 002B     	 cmp r3,#0
 4169 0140 1BD0     	 beq .L297
2070:../SSC/Src/ecatslv.c ****                     {
2071:../SSC/Src/ecatslv.c ****                         bApplEsmPending = FALSE;
 4170              	 .loc 3 2071 0
 4171 0142 554B     	 ldr r3,.L312+12
 4172 0144 0022     	 movs r2,#0
 4173 0146 1A70     	 strb r2,[r3]
2072:../SSC/Src/ecatslv.c ****                         /*APPL_StartMailboxHandler() need to be called*/
2073:../SSC/Src/ecatslv.c ****                         result = APPL_StartMailboxHandler();
 4174              	 .loc 3 2073 0
 4175 0148 FFF7FEFF 	 bl APPL_StartMailboxHandler
 4176 014c 0346     	 mov r3,r0
 4177 014e 7B80     	 strh r3,[r7,#2]
2074:../SSC/Src/ecatslv.c **** 
2075:../SSC/Src/ecatslv.c ****                         if(result == 0)
 4178              	 .loc 3 2075 0
 4179 0150 7B88     	 ldrh r3,[r7,#2]
 4180 0152 002B     	 cmp r3,#0
 4181 0154 09D1     	 bne .L298
2076:../SSC/Src/ecatslv.c ****                         {
2077:../SSC/Src/ecatslv.c ****                             /*The application specific transition was successful => set active mail
2078:../SSC/Src/ecatslv.c ****                             bMbxRunning = TRUE;
 4182              	 .loc 3 2078 0
 4183 0156 584B     	 ldr r3,.L312+44
 4184 0158 0122     	 movs r2,#1
 4185 015a 1A70     	 strb r2,[r3]
2079:../SSC/Src/ecatslv.c ****                             Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
 4186              	 .loc 3 2079 0
 4187 015c 4D4B     	 ldr r3,.L312+8
 4188 015e 1B88     	 ldrh r3,[r3]
 4189 0160 DBB2     	 uxtb r3,r3
 4190 0162 03F00F03 	 and r3,r3,#15
 4191 0166 FB71     	 strb r3,[r7,#7]
 4192 0168 07E0     	 b .L297
 4193              	.L298:
2080:../SSC/Src/ecatslv.c ****                         }
2081:../SSC/Src/ecatslv.c ****                         else
2082:../SSC/Src/ecatslv.c ****                         {
2083:../SSC/Src/ecatslv.c ****                             /*The application specific transition failed.
2084:../SSC/Src/ecatslv.c ****                             (In pending case the application need to complete the transition)*/
2085:../SSC/Src/ecatslv.c **** 
2086:../SSC/Src/ecatslv.c ****                             if(result != NOERROR_INWORK)
 4194              	 .loc 3 2086 0
 4195 016a 7B88     	 ldrh r3,[r7,#2]
 4196 016c FF2B     	 cmp r3,#255
 4197 016e 04D0     	 beq .L297
2087:../SSC/Src/ecatslv.c ****                             {
2088:../SSC/Src/ecatslv.c ****                                 APPL_StopMailboxHandler();
 4198              	 .loc 3 2088 0
 4199 0170 FFF7FEFF 	 bl APPL_StopMailboxHandler
2089:../SSC/Src/ecatslv.c ****                                 MBX_StopMailboxHandler();
 4200              	 .loc 3 2089 0
 4201 0174 FFF7FEFF 	 bl MBX_StopMailboxHandler
2090:../SSC/Src/ecatslv.c ****                             }
2091:../SSC/Src/ecatslv.c ****                         }
2092:../SSC/Src/ecatslv.c ****                     }
2093:../SSC/Src/ecatslv.c ****                 break;
 4202              	 .loc 3 2093 0
 4203 0178 72E0     	 b .L292
 4204              	.L297:
 4205 017a 71E0     	 b .L292
 4206              	.L293:
2094:../SSC/Src/ecatslv.c ****                 case PREOP_2_SAFEOP:
2095:../SSC/Src/ecatslv.c ****                     if(bApplEsmPending)
 4207              	 .loc 3 2095 0
 4208 017c 464B     	 ldr r3,.L312+12
 4209 017e 1B78     	 ldrb r3,[r3]
 4210 0180 002B     	 cmp r3,#0
 4211 0182 18D0     	 beq .L299
2096:../SSC/Src/ecatslv.c ****                     {
2097:../SSC/Src/ecatslv.c ****                         bApplEsmPending = FALSE;
 4212              	 .loc 3 2097 0
 4213 0184 444B     	 ldr r3,.L312+12
 4214 0186 0022     	 movs r2,#0
 4215 0188 1A70     	 strb r2,[r3]
2098:../SSC/Src/ecatslv.c ****                         result = APPL_StartInputHandler(&u16ALEventMask);
 4216              	 .loc 3 2098 0
 4217 018a 4C48     	 ldr r0,.L312+48
 4218 018c FFF7FEFF 	 bl APPL_StartInputHandler
 4219 0190 0346     	 mov r3,r0
 4220 0192 7B80     	 strh r3,[r7,#2]
2099:../SSC/Src/ecatslv.c **** 
2100:../SSC/Src/ecatslv.c ****                         if(result == 0)
 4221              	 .loc 3 2100 0
 4222 0194 7B88     	 ldrh r3,[r7,#2]
 4223 0196 002B     	 cmp r3,#0
 4224 0198 05D1     	 bne .L300
2101:../SSC/Src/ecatslv.c ****                         {
2102:../SSC/Src/ecatslv.c ****                             bEcatInputUpdateRunning = TRUE;
 4225              	 .loc 3 2102 0
 4226 019a 494B     	 ldr r3,.L312+52
 4227 019c 0122     	 movs r2,#1
 4228 019e 1A70     	 strb r2,[r3]
2103:../SSC/Src/ecatslv.c ****                             Status = STATE_SAFEOP;
 4229              	 .loc 3 2103 0
 4230 01a0 0423     	 movs r3,#4
 4231 01a2 FB71     	 strb r3,[r7,#7]
 4232 01a4 07E0     	 b .L299
 4233              	.L300:
2104:../SSC/Src/ecatslv.c ****                         }
2105:../SSC/Src/ecatslv.c ****                         else
2106:../SSC/Src/ecatslv.c ****                         {
2107:../SSC/Src/ecatslv.c ****                             /*The application specific transition failed.
2108:../SSC/Src/ecatslv.c ****                             (In pending case the application need to complete the transition)*/
2109:../SSC/Src/ecatslv.c **** 
2110:../SSC/Src/ecatslv.c ****                             if(result != NOERROR_INWORK)
 4234              	 .loc 3 2110 0
 4235 01a6 7B88     	 ldrh r3,[r7,#2]
 4236 01a8 FF2B     	 cmp r3,#255
 4237 01aa 04D0     	 beq .L299
2111:../SSC/Src/ecatslv.c ****                             {
2112:../SSC/Src/ecatslv.c ****                                 APPL_StopInputHandler();
 4238              	 .loc 3 2112 0
 4239 01ac FFF7FEFF 	 bl APPL_StopInputHandler
2113:../SSC/Src/ecatslv.c ****                                 StopInputHandler();
 4240              	 .loc 3 2113 0
 4241 01b0 FFF7FEFF 	 bl StopInputHandler
2114:../SSC/Src/ecatslv.c ****                             }
2115:../SSC/Src/ecatslv.c ****                         }
2116:../SSC/Src/ecatslv.c ****                     }
2117:../SSC/Src/ecatslv.c ****                 break;
 4242              	 .loc 3 2117 0
 4243 01b4 54E0     	 b .L292
 4244              	.L299:
 4245 01b6 53E0     	 b .L292
 4246              	.L296:
2118:../SSC/Src/ecatslv.c ****                 case SAFEOP_2_OP:
2119:../SSC/Src/ecatslv.c ****                    if(bApplEsmPending)
 4247              	 .loc 3 2119 0
 4248 01b8 374B     	 ldr r3,.L312+12
 4249 01ba 1B78     	 ldrb r3,[r3]
 4250 01bc 002B     	 cmp r3,#0
 4251 01be 4ED0     	 beq .L301
2120:../SSC/Src/ecatslv.c ****                     {
2121:../SSC/Src/ecatslv.c ****                         if(bDcSyncActive)
 4252              	 .loc 3 2121 0
 4253 01c0 384B     	 ldr r3,.L312+24
 4254 01c2 1B78     	 ldrb r3,[r3]
 4255 01c4 002B     	 cmp r3,#0
 4256 01c6 2AD0     	 beq .L302
2122:../SSC/Src/ecatslv.c ****                         {
2123:../SSC/Src/ecatslv.c ****                             if(i16WaitForPllRunningTimeout > 0 && i16WaitForPllRunningTimeout <= i1
 4257              	 .loc 3 2123 0
 4258 01c8 3E4B     	 ldr r3,.L312+56
 4259 01ca 1B88     	 ldrh r3,[r3]
 4260 01cc 1BB2     	 sxth r3,r3
 4261 01ce 002B     	 cmp r3,#0
 4262 01d0 45DD     	 ble .L301
 4263              	 .loc 3 2123 0 is_stmt 0 discriminator 1
 4264 01d2 3C4B     	 ldr r3,.L312+56
 4265 01d4 1A88     	 ldrh r2,[r3]
 4266 01d6 3C4B     	 ldr r3,.L312+60
 4267 01d8 1B88     	 ldrh r3,[r3]
 4268 01da 12B2     	 sxth r2,r2
 4269 01dc 1BB2     	 sxth r3,r3
 4270 01de 9A42     	 cmp r2,r3
 4271 01e0 3DDC     	 bgt .L301
2124:../SSC/Src/ecatslv.c ****                             {
2125:../SSC/Src/ecatslv.c ****                                 /*Pll sequence valid for 200ms (set in APPL_StartOutputHandler() )
2126:../SSC/Src/ecatslv.c ****                                 acknowledge state transition to OP */
2127:../SSC/Src/ecatslv.c **** 
2128:../SSC/Src/ecatslv.c ****                                 i16WaitForPllRunningTimeout = 0;
 4272              	 .loc 3 2128 0 is_stmt 1
 4273 01e2 384B     	 ldr r3,.L312+56
 4274 01e4 0022     	 movs r2,#0
 4275 01e6 1A80     	 strh r2,[r3]
2129:../SSC/Src/ecatslv.c ****                                 i16WaitForPllRunningCnt = 0;
 4276              	 .loc 3 2129 0
 4277 01e8 374B     	 ldr r3,.L312+60
 4278 01ea 0022     	 movs r2,#0
 4279 01ec 1A80     	 strh r2,[r3]
2130:../SSC/Src/ecatslv.c **** 
2131:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ESM4*/
2132:../SSC/Src/ecatslv.c ****                                 bApplEsmPending = FALSE;
 4280              	 .loc 3 2132 0
 4281 01ee 2A4B     	 ldr r3,.L312+12
 4282 01f0 0022     	 movs r2,#0
 4283 01f2 1A70     	 strb r2,[r3]
2133:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ESM4*/
2134:../SSC/Src/ecatslv.c ****                                 result = APPL_StartOutputHandler();
 4284              	 .loc 3 2134 0
 4285 01f4 FFF7FEFF 	 bl APPL_StartOutputHandler
 4286 01f8 0346     	 mov r3,r0
 4287 01fa 7B80     	 strh r3,[r7,#2]
2135:../SSC/Src/ecatslv.c **** 
2136:../SSC/Src/ecatslv.c ****                                 if(result == 0)
 4288              	 .loc 3 2136 0
 4289 01fc 7B88     	 ldrh r3,[r7,#2]
 4290 01fe 002B     	 cmp r3,#0
 4291 0200 05D1     	 bne .L304
2137:../SSC/Src/ecatslv.c ****                                 {
2138:../SSC/Src/ecatslv.c ****                                     /* Slave is OPERATIONAL */
2139:../SSC/Src/ecatslv.c ****                                     bEcatOutputUpdateRunning = TRUE;
 4292              	 .loc 3 2139 0
 4293 0202 2C4B     	 ldr r3,.L312+40
 4294 0204 0122     	 movs r2,#1
 4295 0206 1A70     	 strb r2,[r3]
2140:../SSC/Src/ecatslv.c ****                                     Status = STATE_OP;
 4296              	 .loc 3 2140 0
 4297 0208 0823     	 movs r3,#8
 4298 020a FB71     	 strb r3,[r7,#7]
 4299 020c 27E0     	 b .L301
 4300              	.L304:
2141:../SSC/Src/ecatslv.c ****                                 }
2142:../SSC/Src/ecatslv.c ****                                 else
2143:../SSC/Src/ecatslv.c ****                                 {
2144:../SSC/Src/ecatslv.c ****                                     if(result != NOERROR_INWORK)
 4301              	 .loc 3 2144 0
 4302 020e 7B88     	 ldrh r3,[r7,#2]
 4303 0210 FF2B     	 cmp r3,#255
 4304 0212 24D0     	 beq .L301
2145:../SSC/Src/ecatslv.c ****                                     {
2146:../SSC/Src/ecatslv.c ****                                         APPL_StopOutputHandler();
 4305              	 .loc 3 2146 0
 4306 0214 FFF7FEFF 	 bl APPL_StopOutputHandler
2147:../SSC/Src/ecatslv.c ****                                         StopOutputHandler();
 4307              	 .loc 3 2147 0
 4308 0218 FFF7FEFF 	 bl StopOutputHandler
2148:../SSC/Src/ecatslv.c ****                                     }
2149:../SSC/Src/ecatslv.c ****                                 }
2150:../SSC/Src/ecatslv.c ****                             }
2151:../SSC/Src/ecatslv.c ****                         }
2152:../SSC/Src/ecatslv.c ****                         else
2153:../SSC/Src/ecatslv.c ****                         {
2154:../SSC/Src/ecatslv.c ****                             if(nPdOutputSize == 0 || bEcatFirstOutputsReceived)
2155:../SSC/Src/ecatslv.c ****                             {
2156:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ESM4*/
2157:../SSC/Src/ecatslv.c ****                                 bApplEsmPending = FALSE;  
2158:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ESM4*/
2159:../SSC/Src/ecatslv.c ****                                 result = APPL_StartOutputHandler();
2160:../SSC/Src/ecatslv.c **** 
2161:../SSC/Src/ecatslv.c ****                                 if(result == 0)
2162:../SSC/Src/ecatslv.c ****                                 {
2163:../SSC/Src/ecatslv.c ****                                     /* Slave is OPERATIONAL */
2164:../SSC/Src/ecatslv.c ****                                     bEcatOutputUpdateRunning = TRUE;
2165:../SSC/Src/ecatslv.c ****                                     Status = STATE_OP;
2166:../SSC/Src/ecatslv.c ****                                 }
2167:../SSC/Src/ecatslv.c ****                                 else
2168:../SSC/Src/ecatslv.c ****                                 {
2169:../SSC/Src/ecatslv.c ****                                     if(result != NOERROR_INWORK)
2170:../SSC/Src/ecatslv.c ****                                     {
2171:../SSC/Src/ecatslv.c ****                                         APPL_StopOutputHandler();
2172:../SSC/Src/ecatslv.c ****                                         StopOutputHandler();
2173:../SSC/Src/ecatslv.c ****                                     }
2174:../SSC/Src/ecatslv.c ****                                 }
2175:../SSC/Src/ecatslv.c ****                             }
2176:../SSC/Src/ecatslv.c ****                         }       
2177:../SSC/Src/ecatslv.c ****                     }             
2178:../SSC/Src/ecatslv.c ****                 break;
 4309              	 .loc 3 2178 0
 4310 021c 1FE0     	 b .L311
 4311              	.L302:
2154:../SSC/Src/ecatslv.c ****                             {
 4312              	 .loc 3 2154 0
 4313 021e 244B     	 ldr r3,.L312+36
 4314 0220 1B88     	 ldrh r3,[r3]
 4315 0222 002B     	 cmp r3,#0
 4316 0224 03D0     	 beq .L305
2154:../SSC/Src/ecatslv.c ****                             {
 4317              	 .loc 3 2154 0 is_stmt 0 discriminator 1
 4318 0226 214B     	 ldr r3,.L312+32
 4319 0228 1B78     	 ldrb r3,[r3]
 4320 022a 002B     	 cmp r3,#0
 4321 022c 17D0     	 beq .L301
 4322              	.L305:
2157:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ESM4*/
 4323              	 .loc 3 2157 0 is_stmt 1
 4324 022e 1A4B     	 ldr r3,.L312+12
 4325 0230 0022     	 movs r2,#0
 4326 0232 1A70     	 strb r2,[r3]
2159:../SSC/Src/ecatslv.c **** 
 4327              	 .loc 3 2159 0
 4328 0234 FFF7FEFF 	 bl APPL_StartOutputHandler
 4329 0238 0346     	 mov r3,r0
 4330 023a 7B80     	 strh r3,[r7,#2]
2161:../SSC/Src/ecatslv.c ****                                 {
 4331              	 .loc 3 2161 0
 4332 023c 7B88     	 ldrh r3,[r7,#2]
 4333 023e 002B     	 cmp r3,#0
 4334 0240 05D1     	 bne .L306
2164:../SSC/Src/ecatslv.c ****                                     Status = STATE_OP;
 4335              	 .loc 3 2164 0
 4336 0242 1C4B     	 ldr r3,.L312+40
 4337 0244 0122     	 movs r2,#1
 4338 0246 1A70     	 strb r2,[r3]
2165:../SSC/Src/ecatslv.c ****                                 }
 4339              	 .loc 3 2165 0
 4340 0248 0823     	 movs r3,#8
 4341 024a FB71     	 strb r3,[r7,#7]
 4342 024c 07E0     	 b .L301
 4343              	.L306:
2169:../SSC/Src/ecatslv.c ****                                     {
 4344              	 .loc 3 2169 0
 4345 024e 7B88     	 ldrh r3,[r7,#2]
 4346 0250 FF2B     	 cmp r3,#255
 4347 0252 04D0     	 beq .L301
2171:../SSC/Src/ecatslv.c ****                                         StopOutputHandler();
 4348              	 .loc 3 2171 0
 4349 0254 FFF7FEFF 	 bl APPL_StopOutputHandler
2172:../SSC/Src/ecatslv.c ****                                     }
 4350              	 .loc 3 2172 0
 4351 0258 FFF7FEFF 	 bl StopOutputHandler
 4352              	 .loc 3 2178 0
 4353 025c FFE7     	 b .L311
 4354              	.L301:
 4355              	.L311:
 4356 025e 00BF     	 nop
 4357              	.L292:
2179:../SSC/Src/ecatslv.c ****             }//Switch - transition
2180:../SSC/Src/ecatslv.c ****         }
2181:../SSC/Src/ecatslv.c **** 
2182:../SSC/Src/ecatslv.c ****         if(Status != 0)
 4358              	 .loc 3 2182 0
 4359 0260 FB79     	 ldrb r3,[r7,#7]
 4360 0262 002B     	 cmp r3,#0
 4361 0264 0FD0     	 beq .L270
2183:../SSC/Src/ecatslv.c ****         {
2184:../SSC/Src/ecatslv.c ****             /*Pending state transition finished => write AL Status and AL Status Code*/
2185:../SSC/Src/ecatslv.c ****             bEcatWaitForAlControlRes = FALSE;
 4362              	 .loc 3 2185 0
 4363 0266 094B     	 ldr r3,.L312
 4364 0268 0022     	 movs r2,#0
 4365 026a 1A70     	 strb r2,[r3]
2186:../SSC/Src/ecatslv.c **** 
2187:../SSC/Src/ecatslv.c ****             if (StatusCode != 0)
 4366              	 .loc 3 2187 0
 4367 026c BB88     	 ldrh r3,[r7,#4]
 4368 026e 002B     	 cmp r3,#0
 4369 0270 03D0     	 beq .L307
2188:../SSC/Src/ecatslv.c ****             {
2189:../SSC/Src/ecatslv.c ****                 Status |= STATE_CHANGE;
 4370              	 .loc 3 2189 0
 4371 0272 FB79     	 ldrb r3,[r7,#7]
 4372 0274 43F01003 	 orr r3,r3,#16
 4373 0278 FB71     	 strb r3,[r7,#7]
 4374              	.L307:
2190:../SSC/Src/ecatslv.c ****             }
2191:../SSC/Src/ecatslv.c **** 
2192:../SSC/Src/ecatslv.c ****             SetALStatus(Status,StatusCode);
 4375              	 .loc 3 2192 0
 4376 027a FA79     	 ldrb r2,[r7,#7]
 4377 027c BB88     	 ldrh r3,[r7,#4]
 4378 027e 1046     	 mov r0,r2
 4379 0280 1946     	 mov r1,r3
 4380 0282 FFF7FEFF 	 bl SetALStatus
 4381              	.L270:
 4382              	.LBE8:
2193:../SSC/Src/ecatslv.c ****         }
2194:../SSC/Src/ecatslv.c ****     }// Pending state transition (bEcatWaitForAlControlRes == true)
2195:../SSC/Src/ecatslv.c **** }
 4383              	 .loc 3 2195 0
 4384 0286 0837     	 adds r7,r7,#8
 4385              	.LCFI87:
 4386              	 .cfi_def_cfa_offset 8
 4387 0288 BD46     	 mov sp,r7
 4388              	.LCFI88:
 4389              	 .cfi_def_cfa_register 13
 4390              	 
 4391 028a 80BD     	 pop {r7,pc}
 4392              	.L313:
 4393              	 .align 2
 4394              	.L312:
 4395 028c 00000000 	 .word bEcatWaitForAlControlRes
 4396 0290 00000000 	 .word EsmTimeoutCounter
 4397 0294 00000000 	 .word nEcatStateTrans
 4398 0298 00000000 	 .word bApplEsmPending
 4399 029c 00000000 	 .word bLocalErrorFlag
 4400 02a0 00000000 	 .word u16LocalErrorCode
 4401 02a4 00000000 	 .word bDcSyncActive
 4402 02a8 00000000 	 .word bDcRunning
 4403 02ac 00000000 	 .word bEcatFirstOutputsReceived
 4404 02b0 00000000 	 .word nPdOutputSize
 4405 02b4 00000000 	 .word bEcatOutputUpdateRunning
 4406 02b8 00000000 	 .word bMbxRunning
 4407 02bc 00000000 	 .word u16ALEventMask
 4408 02c0 00000000 	 .word bEcatInputUpdateRunning
 4409 02c4 00000000 	 .word i16WaitForPllRunningTimeout
 4410 02c8 00000000 	 .word i16WaitForPllRunningCnt
 4411              	 .cfi_endproc
 4412              	.LFE191:
 4414              	 .section .text.DC_CheckWatchdog,"ax",%progbits
 4415              	 .align 2
 4416              	 .global DC_CheckWatchdog
 4417              	 .thumb
 4418              	 .thumb_func
 4420              	DC_CheckWatchdog:
 4421              	.LFB192:
2196:../SSC/Src/ecatslv.c **** 
2197:../SSC/Src/ecatslv.c **** 
2198:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
2199:../SSC/Src/ecatslv.c **** /**
2200:../SSC/Src/ecatslv.c **** 
2201:../SSC/Src/ecatslv.c ****  \brief    This function checks the current Sync state and set the local flags
2202:../SSC/Src/ecatslv.c ****  The analyse of the local flags is handled in "CheckIfEcatError"
2203:../SSC/Src/ecatslv.c **** 
2204:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
2205:../SSC/Src/ecatslv.c **** void DC_CheckWatchdog(void)
2206:../SSC/Src/ecatslv.c **** {
 4422              	 .loc 3 2206 0
 4423              	 .cfi_startproc
 4424              	 
 4425              	 
 4426              	 
 4427 0000 80B4     	 push {r7}
 4428              	.LCFI89:
 4429              	 .cfi_def_cfa_offset 4
 4430              	 .cfi_offset 7,-4
 4431 0002 00AF     	 add r7,sp,#0
 4432              	.LCFI90:
 4433              	 .cfi_def_cfa_register 7
2207:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ECAT5*/
2208:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ECAT5*/
2209:../SSC/Src/ecatslv.c **** 
2210:../SSC/Src/ecatslv.c ****     if(bDcSyncActive && bEcatInputUpdateRunning)
 4434              	 .loc 3 2210 0
 4435 0004 394B     	 ldr r3,.L325
 4436 0006 1B78     	 ldrb r3,[r3]
 4437 0008 002B     	 cmp r3,#0
 4438 000a 6BD0     	 beq .L314
 4439              	 .loc 3 2210 0 is_stmt 0 discriminator 1
 4440 000c 384B     	 ldr r3,.L325+4
 4441 000e 1B78     	 ldrb r3,[r3]
 4442 0010 002B     	 cmp r3,#0
 4443 0012 67D0     	 beq .L314
2211:../SSC/Src/ecatslv.c ****     {
2212:../SSC/Src/ecatslv.c ****         /*If Sync0 watchdog is enabled and expired*/
2213:../SSC/Src/ecatslv.c ****         if((Sync0WdValue > 0) && (Sync0WdCounter >= Sync0WdValue))
 4444              	 .loc 3 2213 0 is_stmt 1
 4445 0014 374B     	 ldr r3,.L325+8
 4446 0016 1B88     	 ldrh r3,[r3]
 4447 0018 002B     	 cmp r3,#0
 4448 001a 09D0     	 beq .L316
 4449              	 .loc 3 2213 0 is_stmt 0 discriminator 1
 4450 001c 364B     	 ldr r3,.L325+12
 4451 001e 1A88     	 ldrh r2,[r3]
 4452 0020 344B     	 ldr r3,.L325+8
 4453 0022 1B88     	 ldrh r3,[r3]
 4454 0024 9A42     	 cmp r2,r3
 4455 0026 03D3     	 bcc .L316
2214:../SSC/Src/ecatslv.c ****         {
2215:../SSC/Src/ecatslv.c ****                 /*Sync0 watchdog expired*/
2216:../SSC/Src/ecatslv.c ****                 bDcRunning = FALSE;        
 4456              	 .loc 3 2216 0 is_stmt 1
 4457 0028 344B     	 ldr r3,.L325+16
 4458 002a 0022     	 movs r2,#0
 4459 002c 1A70     	 strb r2,[r3]
 4460 002e 0EE0     	 b .L317
 4461              	.L316:
2217:../SSC/Src/ecatslv.c ****         }
2218:../SSC/Src/ecatslv.c ****         else
2219:../SSC/Src/ecatslv.c ****         {
2220:../SSC/Src/ecatslv.c ****             if(Sync0WdCounter < Sync0WdValue)
 4462              	 .loc 3 2220 0
 4463 0030 314B     	 ldr r3,.L325+12
 4464 0032 1A88     	 ldrh r2,[r3]
 4465 0034 2F4B     	 ldr r3,.L325+8
 4466 0036 1B88     	 ldrh r3,[r3]
 4467 0038 9A42     	 cmp r2,r3
 4468 003a 05D2     	 bcs .L318
2221:../SSC/Src/ecatslv.c ****             {
2222:../SSC/Src/ecatslv.c ****                 Sync0WdCounter ++;
 4469              	 .loc 3 2222 0
 4470 003c 2E4B     	 ldr r3,.L325+12
 4471 003e 1B88     	 ldrh r3,[r3]
 4472 0040 0133     	 adds r3,r3,#1
 4473 0042 9AB2     	 uxth r2,r3
 4474 0044 2C4B     	 ldr r3,.L325+12
 4475 0046 1A80     	 strh r2,[r3]
 4476              	.L318:
2223:../SSC/Src/ecatslv.c ****             }
2224:../SSC/Src/ecatslv.c **** 
2225:../SSC/Src/ecatslv.c ****             bDcRunning = TRUE;
 4477              	 .loc 3 2225 0
 4478 0048 2C4B     	 ldr r3,.L325+16
 4479 004a 0122     	 movs r2,#1
 4480 004c 1A70     	 strb r2,[r3]
 4481              	.L317:
2226:../SSC/Src/ecatslv.c ****         }
2227:../SSC/Src/ecatslv.c **** 
2228:../SSC/Src/ecatslv.c ****         if(bDcRunning)
 4482              	 .loc 3 2228 0
 4483 004e 2B4B     	 ldr r3,.L325+16
 4484 0050 1B78     	 ldrb r3,[r3]
 4485 0052 002B     	 cmp r3,#0
 4486 0054 13D0     	 beq .L319
2229:../SSC/Src/ecatslv.c ****         {
2230:../SSC/Src/ecatslv.c ****             /*Check the Sync1 cycle if Sync1 Wd is enabled*/
2231:../SSC/Src/ecatslv.c ****             if(Sync1WdValue > 0)
 4487              	 .loc 3 2231 0
 4488 0056 2A4B     	 ldr r3,.L325+20
 4489 0058 1B88     	 ldrh r3,[r3]
 4490 005a 002B     	 cmp r3,#0
 4491 005c 0FD0     	 beq .L319
2232:../SSC/Src/ecatslv.c ****             {
2233:../SSC/Src/ecatslv.c ****                 if(Sync1WdCounter < Sync1WdValue)
 4492              	 .loc 3 2233 0
 4493 005e 294B     	 ldr r3,.L325+24
 4494 0060 1A88     	 ldrh r2,[r3]
 4495 0062 274B     	 ldr r3,.L325+20
 4496 0064 1B88     	 ldrh r3,[r3]
 4497 0066 9A42     	 cmp r2,r3
 4498 0068 06D2     	 bcs .L320
2234:../SSC/Src/ecatslv.c ****                 {
2235:../SSC/Src/ecatslv.c ****                     Sync1WdCounter ++;
 4499              	 .loc 3 2235 0
 4500 006a 264B     	 ldr r3,.L325+24
 4501 006c 1B88     	 ldrh r3,[r3]
 4502 006e 0133     	 adds r3,r3,#1
 4503 0070 9AB2     	 uxth r2,r3
 4504 0072 244B     	 ldr r3,.L325+24
 4505 0074 1A80     	 strh r2,[r3]
 4506 0076 02E0     	 b .L319
 4507              	.L320:
2236:../SSC/Src/ecatslv.c ****                 }
2237:../SSC/Src/ecatslv.c ****                 else
2238:../SSC/Src/ecatslv.c ****                 {
2239:../SSC/Src/ecatslv.c ****                     /*Sync1 watchdog expired*/
2240:../SSC/Src/ecatslv.c ****                     bDcRunning = FALSE;
 4508              	 .loc 3 2240 0
 4509 0078 204B     	 ldr r3,.L325+16
 4510 007a 0022     	 movs r2,#0
 4511 007c 1A70     	 strb r2,[r3]
 4512              	.L319:
2241:../SSC/Src/ecatslv.c ****                 }
2242:../SSC/Src/ecatslv.c ****             }
2243:../SSC/Src/ecatslv.c ****         }
2244:../SSC/Src/ecatslv.c ****         if(bDcRunning)
 4513              	 .loc 3 2244 0
 4514 007e 1F4B     	 ldr r3,.L325+16
 4515 0080 1B78     	 ldrb r3,[r3]
 4516 0082 002B     	 cmp r3,#0
 4517 0084 27D0     	 beq .L321
2245:../SSC/Src/ecatslv.c ****         {
2246:../SSC/Src/ecatslv.c ****            if(sSyncManOutPar.u16SmEventMissedCounter < sErrorSettings.u16SyncErrorCounterLimit)
 4518              	 .loc 3 2246 0
 4519 0086 204B     	 ldr r3,.L325+28
 4520 0088 1A8D     	 ldrh r2,[r3,#40]
 4521 008a 204B     	 ldr r3,.L325+32
 4522 008c 1B89     	 ldrh r3,[r3,#8]
 4523 008e 9A42     	 cmp r2,r3
 4524 0090 11D2     	 bcs .L322
2247:../SSC/Src/ecatslv.c ****             {
2248:../SSC/Src/ecatslv.c ****                 bSmSyncSequenceValid = TRUE;
 4525              	 .loc 3 2248 0
 4526 0092 1F4B     	 ldr r3,.L325+36
 4527 0094 0122     	 movs r2,#1
 4528 0096 1A70     	 strb r2,[r3]
2249:../SSC/Src/ecatslv.c **** 
2250:../SSC/Src/ecatslv.c ****                 /*Wait for PLL is active increment the Pll valid counter*/
2251:../SSC/Src/ecatslv.c ****                 if (i16WaitForPllRunningTimeout > 0)
 4529              	 .loc 3 2251 0
 4530 0098 1E4B     	 ldr r3,.L325+40
 4531 009a 1B88     	 ldrh r3,[r3]
 4532 009c 1BB2     	 sxth r3,r3
 4533 009e 002B     	 cmp r3,#0
 4534 00a0 20DD     	 ble .L314
2252:../SSC/Src/ecatslv.c ****                 {
2253:../SSC/Src/ecatslv.c ****                     i16WaitForPllRunningCnt++;
 4535              	 .loc 3 2253 0
 4536 00a2 1D4B     	 ldr r3,.L325+44
 4537 00a4 1B88     	 ldrh r3,[r3]
 4538 00a6 9BB2     	 uxth r3,r3
 4539 00a8 9BB2     	 uxth r3,r3
 4540 00aa 0133     	 adds r3,r3,#1
 4541 00ac 9BB2     	 uxth r3,r3
 4542 00ae 9AB2     	 uxth r2,r3
 4543 00b0 194B     	 ldr r3,.L325+44
 4544 00b2 1A80     	 strh r2,[r3]
 4545 00b4 16E0     	 b .L314
 4546              	.L322:
2254:../SSC/Src/ecatslv.c ****                 }
2255:../SSC/Src/ecatslv.c ****             }
2256:../SSC/Src/ecatslv.c ****             else if (bSmSyncSequenceValid)
 4547              	 .loc 3 2256 0
 4548 00b6 164B     	 ldr r3,.L325+36
 4549 00b8 1B78     	 ldrb r3,[r3]
 4550 00ba 002B     	 cmp r3,#0
 4551 00bc 12D0     	 beq .L314
2257:../SSC/Src/ecatslv.c ****             {
2258:../SSC/Src/ecatslv.c ****                     bSmSyncSequenceValid = FALSE;
 4552              	 .loc 3 2258 0
 4553 00be 144B     	 ldr r3,.L325+36
 4554 00c0 0022     	 movs r2,#0
 4555 00c2 1A70     	 strb r2,[r3]
2259:../SSC/Src/ecatslv.c **** 
2260:../SSC/Src/ecatslv.c ****                 /*Wait for PLL is active reset the Pll valid counter*/
2261:../SSC/Src/ecatslv.c ****                 if (i16WaitForPllRunningTimeout > 0)
 4556              	 .loc 3 2261 0
 4557 00c4 134B     	 ldr r3,.L325+40
 4558 00c6 1B88     	 ldrh r3,[r3]
 4559 00c8 1BB2     	 sxth r3,r3
 4560 00ca 002B     	 cmp r3,#0
 4561 00cc 0ADD     	 ble .L314
2262:../SSC/Src/ecatslv.c ****                 {
2263:../SSC/Src/ecatslv.c ****                     i16WaitForPllRunningCnt = 0;
 4562              	 .loc 3 2263 0
 4563 00ce 124B     	 ldr r3,.L325+44
 4564 00d0 0022     	 movs r2,#0
 4565 00d2 1A80     	 strh r2,[r3]
 4566 00d4 06E0     	 b .L314
 4567              	.L321:
2264:../SSC/Src/ecatslv.c ****                 }
2265:../SSC/Src/ecatslv.c ****             }
2266:../SSC/Src/ecatslv.c ****         }
2267:../SSC/Src/ecatslv.c ****         else if(bSmSyncSequenceValid)
 4568              	 .loc 3 2267 0
 4569 00d6 0E4B     	 ldr r3,.L325+36
 4570 00d8 1B78     	 ldrb r3,[r3]
 4571 00da 002B     	 cmp r3,#0
 4572 00dc 02D0     	 beq .L314
2268:../SSC/Src/ecatslv.c ****         {
2269:../SSC/Src/ecatslv.c ****            bSmSyncSequenceValid = FALSE;
 4573              	 .loc 3 2269 0
 4574 00de 0C4B     	 ldr r3,.L325+36
 4575 00e0 0022     	 movs r2,#0
 4576 00e2 1A70     	 strb r2,[r3]
 4577              	.L314:
2270:../SSC/Src/ecatslv.c ****         }
2271:../SSC/Src/ecatslv.c ****     }
2272:../SSC/Src/ecatslv.c ****     /*ECATCHANGE_START(V5.12) ECAT5*/
2273:../SSC/Src/ecatslv.c ****     /*ECATCHANGE_END(V5.12) ECAT5*/
2274:../SSC/Src/ecatslv.c **** }
 4578              	 .loc 3 2274 0
 4579 00e4 BD46     	 mov sp,r7
 4580              	.LCFI91:
 4581              	 .cfi_def_cfa_register 13
 4582              	 
 4583 00e6 5DF8047B 	 ldr r7,[sp],#4
 4584              	.LCFI92:
 4585              	 .cfi_restore 7
 4586              	 .cfi_def_cfa_offset 0
 4587 00ea 7047     	 bx lr
 4588              	.L326:
 4589              	 .align 2
 4590              	.L325:
 4591 00ec 00000000 	 .word bDcSyncActive
 4592 00f0 00000000 	 .word bEcatInputUpdateRunning
 4593 00f4 00000000 	 .word Sync0WdValue
 4594 00f8 00000000 	 .word Sync0WdCounter
 4595 00fc 00000000 	 .word bDcRunning
 4596 0100 00000000 	 .word Sync1WdValue
 4597 0104 00000000 	 .word Sync1WdCounter
 4598 0108 00000000 	 .word sSyncManOutPar
 4599 010c 00000000 	 .word sErrorSettings
 4600 0110 00000000 	 .word bSmSyncSequenceValid
 4601 0114 00000000 	 .word i16WaitForPllRunningTimeout
 4602 0118 00000000 	 .word i16WaitForPllRunningCnt
 4603              	 .cfi_endproc
 4604              	.LFE192:
 4606              	 .section .text.CheckIfEcatError,"ax",%progbits
 4607              	 .align 2
 4608              	 .global CheckIfEcatError
 4609              	 .thumb
 4610              	 .thumb_func
 4612              	CheckIfEcatError:
 4613              	.LFB193:
2275:../SSC/Src/ecatslv.c **** 
2276:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
2277:../SSC/Src/ecatslv.c **** /**
2278:../SSC/Src/ecatslv.c **** 
2279:../SSC/Src/ecatslv.c ****  \brief    Checks communication and synchronisation variables and update AL status / AL status code
2280:../SSC/Src/ecatslv.c **** 
2281:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
2282:../SSC/Src/ecatslv.c **** void CheckIfEcatError(void)
2283:../SSC/Src/ecatslv.c **** {
 4614              	 .loc 3 2283 0
 4615              	 .cfi_startproc
 4616              	 
 4617              	 
 4618 0000 80B5     	 push {r7,lr}
 4619              	.LCFI93:
 4620              	 .cfi_def_cfa_offset 8
 4621              	 .cfi_offset 7,-8
 4622              	 .cfi_offset 14,-4
 4623 0002 82B0     	 sub sp,sp,#8
 4624              	.LCFI94:
 4625              	 .cfi_def_cfa_offset 16
 4626 0004 00AF     	 add r7,sp,#0
 4627              	.LCFI95:
 4628              	 .cfi_def_cfa_register 7
2284:../SSC/Src/ecatslv.c ****    /*if the watchdog is enabled check the the process data watchdog in the ESC
2285:../SSC/Src/ecatslv.c ****    and set the AL status code 0x1B if the watchdog expired*/
2286:../SSC/Src/ecatslv.c ****    if (EcatWdValue != 0)
 4629              	 .loc 3 2286 0
 4630 0006 204B     	 ldr r3,.L332
 4631 0008 1B88     	 ldrh r3,[r3]
 4632 000a 002B     	 cmp r3,#0
 4633 000c 19D0     	 beq .L328
 4634              	.LBB9:
2287:../SSC/Src/ecatslv.c ****    {
2288:../SSC/Src/ecatslv.c ****       /*watchdog time is set => watchdog is active*/
2289:../SSC/Src/ecatslv.c ****       UINT16 WdStatusOK = 0;
 4635              	 .loc 3 2289 0
 4636 000e 0023     	 movs r3,#0
 4637 0010 FB80     	 strh r3,[r7,#6]
2290:../SSC/Src/ecatslv.c **** 
2291:../SSC/Src/ecatslv.c ****       HW_EscReadWord(WdStatusOK, ESC_PD_WD_STATE);
 4638              	 .loc 3 2291 0
 4639 0012 1E4B     	 ldr r3,.L332+4
 4640 0014 1B88     	 ldrh r3,[r3]
 4641 0016 FB80     	 strh r3,[r7,#6]
2292:../SSC/Src/ecatslv.c ****       WdStatusOK = SWAPWORD(WdStatusOK);
2293:../SSC/Src/ecatslv.c **** 
2294:../SSC/Src/ecatslv.c ****       if (!(WdStatusOK & ESC_PD_WD_TRIGGER_MASK) && (nPdOutputSize > 0))
 4642              	 .loc 3 2294 0
 4643 0018 FB88     	 ldrh r3,[r7,#6]
 4644 001a 03F00103 	 and r3,r3,#1
 4645 001e 002B     	 cmp r3,#0
 4646 0020 0FD1     	 bne .L328
 4647              	 .loc 3 2294 0 is_stmt 0 discriminator 1
 4648 0022 1B4B     	 ldr r3,.L332+8
 4649 0024 1B88     	 ldrh r3,[r3]
 4650 0026 002B     	 cmp r3,#0
 4651 0028 0BD0     	 beq .L328
2295:../SSC/Src/ecatslv.c ****       {
2296:../SSC/Src/ecatslv.c ****          /*The device is in OP state*/
2297:../SSC/Src/ecatslv.c **** 
2298:../SSC/Src/ecatslv.c ****          if (bEcatOutputUpdateRunning
 4652              	 .loc 3 2298 0 is_stmt 1
 4653 002a 1A4B     	 ldr r3,.L332+12
 4654 002c 1B78     	 ldrb r3,[r3]
 4655 002e 002B     	 cmp r3,#0
 4656 0030 04D0     	 beq .L329
2299:../SSC/Src/ecatslv.c ****             )
2300:../SSC/Src/ecatslv.c ****          {
2301:../SSC/Src/ecatslv.c ****             AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SMWATCHDOG);
 4657              	 .loc 3 2301 0
 4658 0032 0420     	 movs r0,#4
 4659 0034 1B21     	 movs r1,#27
 4660 0036 FFF7FEFF 	 bl AL_ControlInd
2302:../SSC/Src/ecatslv.c ****             return;
 4661              	 .loc 3 2302 0
 4662 003a 22E0     	 b .L327
 4663              	.L329:
2303:../SSC/Src/ecatslv.c ****          }
2304:../SSC/Src/ecatslv.c **** 
2305:../SSC/Src/ecatslv.c ****          else
2306:../SSC/Src/ecatslv.c ****          {
2307:../SSC/Src/ecatslv.c ****             bEcatFirstOutputsReceived = FALSE;
 4664              	 .loc 3 2307 0
 4665 003c 164B     	 ldr r3,.L332+16
 4666 003e 0022     	 movs r2,#0
 4667 0040 1A70     	 strb r2,[r3]
 4668              	.L328:
 4669              	.LBE9:
2308:../SSC/Src/ecatslv.c ****          }
2309:../SSC/Src/ecatslv.c ****       }
2310:../SSC/Src/ecatslv.c ****    }
2311:../SSC/Src/ecatslv.c **** 
2312:../SSC/Src/ecatslv.c ****    if(bDcSyncActive)
 4670              	 .loc 3 2312 0
 4671 0042 164B     	 ldr r3,.L332+20
 4672 0044 1B78     	 ldrb r3,[r3]
 4673 0046 002B     	 cmp r3,#0
 4674 0048 1BD0     	 beq .L327
2313:../SSC/Src/ecatslv.c ****    {
2314:../SSC/Src/ecatslv.c ****        if(bEcatOutputUpdateRunning)
 4675              	 .loc 3 2314 0
 4676 004a 124B     	 ldr r3,.L332+12
 4677 004c 1B78     	 ldrb r3,[r3]
 4678 004e 002B     	 cmp r3,#0
 4679 0050 17D0     	 beq .L327
2315:../SSC/Src/ecatslv.c ****        {
2316:../SSC/Src/ecatslv.c ****            /*Slave is in OP state*/
2317:../SSC/Src/ecatslv.c ****            if(!bDcRunning)
 4680              	 .loc 3 2317 0
 4681 0052 134B     	 ldr r3,.L332+24
 4682 0054 1B78     	 ldrb r3,[r3]
 4683 0056 83F00103 	 eor r3,r3,#1
 4684 005a DBB2     	 uxtb r3,r3
 4685 005c 002B     	 cmp r3,#0
 4686 005e 04D0     	 beq .L331
2318:../SSC/Src/ecatslv.c ****            {
2319:../SSC/Src/ecatslv.c ****                AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
 4687              	 .loc 3 2319 0
 4688 0060 0420     	 movs r0,#4
 4689 0062 2C21     	 movs r1,#44
 4690 0064 FFF7FEFF 	 bl AL_ControlInd
2320:../SSC/Src/ecatslv.c ****                return;
 4691              	 .loc 3 2320 0
 4692 0068 0BE0     	 b .L327
 4693              	.L331:
2321:../SSC/Src/ecatslv.c ****            }
2322:../SSC/Src/ecatslv.c ****            else if(!bSmSyncSequenceValid)
 4694              	 .loc 3 2322 0
 4695 006a 0E4B     	 ldr r3,.L332+28
 4696 006c 1B78     	 ldrb r3,[r3]
 4697 006e 83F00103 	 eor r3,r3,#1
 4698 0072 DBB2     	 uxtb r3,r3
 4699 0074 002B     	 cmp r3,#0
 4700 0076 04D0     	 beq .L327
2323:../SSC/Src/ecatslv.c ****            {
2324:../SSC/Src/ecatslv.c ****                AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
 4701              	 .loc 3 2324 0
 4702 0078 0420     	 movs r0,#4
 4703 007a 1A21     	 movs r1,#26
 4704 007c FFF7FEFF 	 bl AL_ControlInd
2325:../SSC/Src/ecatslv.c ****                return;
 4705              	 .loc 3 2325 0
 4706 0080 00BF     	 nop
 4707              	.L327:
2326:../SSC/Src/ecatslv.c ****            }
2327:../SSC/Src/ecatslv.c ****         
2328:../SSC/Src/ecatslv.c ****        }
2329:../SSC/Src/ecatslv.c ****    }
2330:../SSC/Src/ecatslv.c **** }
 4708              	 .loc 3 2330 0
 4709 0082 0837     	 adds r7,r7,#8
 4710              	.LCFI96:
 4711              	 .cfi_def_cfa_offset 8
 4712 0084 BD46     	 mov sp,r7
 4713              	.LCFI97:
 4714              	 .cfi_def_cfa_register 13
 4715              	 
 4716 0086 80BD     	 pop {r7,pc}
 4717              	.L333:
 4718              	 .align 2
 4719              	.L332:
 4720 0088 00000000 	 .word EcatWdValue
 4721 008c 40040154 	 .word 1409352768
 4722 0090 00000000 	 .word nPdOutputSize
 4723 0094 00000000 	 .word bEcatOutputUpdateRunning
 4724 0098 00000000 	 .word bEcatFirstOutputsReceived
 4725 009c 00000000 	 .word bDcSyncActive
 4726 00a0 00000000 	 .word bDcRunning
 4727 00a4 00000000 	 .word bSmSyncSequenceValid
 4728              	 .cfi_endproc
 4729              	.LFE193:
 4731              	 .section .text.ECAT_StateChange,"ax",%progbits
 4732              	 .align 2
 4733              	 .global ECAT_StateChange
 4734              	 .thumb
 4735              	 .thumb_func
 4737              	ECAT_StateChange:
 4738              	.LFB194:
2331:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
2332:../SSC/Src/ecatslv.c **** /**
2333:../SSC/Src/ecatslv.c ****  \param    alStatus: requested state
2334:../SSC/Src/ecatslv.c ****  \param    alStatusCode: value for the AL-Status register
2335:../SSC/Src/ecatslv.c ****  
2336:../SSC/Src/ecatslv.c ****  \brief    This function changes the state of the EtherCAT slave if the requested state
2337:../SSC/Src/ecatslv.c ****              is lower than the actual state, otherwise the error condition will be reset.
2338:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
2339:../SSC/Src/ecatslv.c **** 
2340:../SSC/Src/ecatslv.c **** void ECAT_StateChange(UINT8 alStatus, UINT16 alStatusCode)
2341:../SSC/Src/ecatslv.c **** {
 4739              	 .loc 3 2341 0
 4740              	 .cfi_startproc
 4741              	 
 4742              	 
 4743 0000 80B5     	 push {r7,lr}
 4744              	.LCFI98:
 4745              	 .cfi_def_cfa_offset 8
 4746              	 .cfi_offset 7,-8
 4747              	 .cfi_offset 14,-4
 4748 0002 84B0     	 sub sp,sp,#16
 4749              	.LCFI99:
 4750              	 .cfi_def_cfa_offset 24
 4751 0004 00AF     	 add r7,sp,#0
 4752              	.LCFI100:
 4753              	 .cfi_def_cfa_register 7
 4754 0006 0346     	 mov r3,r0
 4755 0008 0A46     	 mov r2,r1
 4756 000a FB71     	 strb r3,[r7,#7]
 4757 000c 1346     	 mov r3,r2
 4758 000e BB80     	 strh r3,[r7,#4]
2342:../SSC/Src/ecatslv.c ****     UINT8 Status = alStatus;
 4759              	 .loc 3 2342 0
 4760 0010 FB79     	 ldrb r3,[r7,#7]
 4761 0012 FB73     	 strb r3,[r7,#15]
2343:../SSC/Src/ecatslv.c **** 
2344:../SSC/Src/ecatslv.c **** 
2345:../SSC/Src/ecatslv.c ****     if(bEcatWaitForAlControlRes)
 4762              	 .loc 3 2345 0
 4763 0014 504B     	 ldr r3,.L358
 4764 0016 1B78     	 ldrb r3,[r3]
 4765 0018 002B     	 cmp r3,#0
 4766 001a 71D0     	 beq .L335
2346:../SSC/Src/ecatslv.c ****     {
2347:../SSC/Src/ecatslv.c ****         /*State transition is pending*/
2348:../SSC/Src/ecatslv.c **** 
2349:../SSC/Src/ecatslv.c ****         if(bApplEsmPending)
 4767              	 .loc 3 2349 0
 4768 001c 4F4B     	 ldr r3,.L358+4
 4769 001e 1B78     	 ldrb r3,[r3]
 4770 0020 002B     	 cmp r3,#0
 4771 0022 0DD0     	 beq .L336
2350:../SSC/Src/ecatslv.c ****         {
2351:../SSC/Src/ecatslv.c ****             /*The generic stack has currently control of the state transition.
2352:../SSC/Src/ecatslv.c ****             In case on an local error force ESM timeout*/
2353:../SSC/Src/ecatslv.c ****             if(alStatusCode != 0)
 4772              	 .loc 3 2353 0
 4773 0024 BB88     	 ldrh r3,[r7,#4]
 4774 0026 002B     	 cmp r3,#0
 4775 0028 00F09380 	 beq .L334
2354:../SSC/Src/ecatslv.c ****             {
2355:../SSC/Src/ecatslv.c ****                 bLocalErrorFlag = TRUE;
 4776              	 .loc 3 2355 0
 4777 002c 4C4B     	 ldr r3,.L358+8
 4778 002e 0122     	 movs r2,#1
 4779 0030 1A70     	 strb r2,[r3]
2356:../SSC/Src/ecatslv.c ****                 u16LocalErrorCode = alStatusCode;
 4780              	 .loc 3 2356 0
 4781 0032 4C4A     	 ldr r2,.L358+12
 4782 0034 BB88     	 ldrh r3,[r7,#4]
 4783 0036 1380     	 strh r3,[r2]
2357:../SSC/Src/ecatslv.c ****                 EsmTimeoutCounter = 0;
 4784              	 .loc 3 2357 0
 4785 0038 4B4B     	 ldr r3,.L358+16
 4786 003a 0022     	 movs r2,#0
 4787 003c 1A80     	 strh r2,[r3]
 4788 003e 88E0     	 b .L334
 4789              	.L336:
2358:../SSC/Src/ecatslv.c ****             }
2359:../SSC/Src/ecatslv.c ****         }
2360:../SSC/Src/ecatslv.c ****         else
2361:../SSC/Src/ecatslv.c ****         {
2362:../SSC/Src/ecatslv.c ****             /*complete the state transition*/
2363:../SSC/Src/ecatslv.c **** 
2364:../SSC/Src/ecatslv.c ****             if(alStatusCode != 0)
 4790              	 .loc 3 2364 0
 4791 0040 BB88     	 ldrh r3,[r7,#4]
 4792 0042 002B     	 cmp r3,#0
 4793 0044 27D0     	 beq .L339
2365:../SSC/Src/ecatslv.c ****             {
2366:../SSC/Src/ecatslv.c ****                 bLocalErrorFlag = TRUE;
 4794              	 .loc 3 2366 0
 4795 0046 464B     	 ldr r3,.L358+8
 4796 0048 0122     	 movs r2,#1
 4797 004a 1A70     	 strb r2,[r3]
2367:../SSC/Src/ecatslv.c ****                 u16LocalErrorCode = alStatusCode;
 4798              	 .loc 3 2367 0
 4799 004c 454A     	 ldr r2,.L358+12
 4800 004e BB88     	 ldrh r3,[r7,#4]
 4801 0050 1380     	 strh r3,[r2]
2368:../SSC/Src/ecatslv.c **** 
2369:../SSC/Src/ecatslv.c ****                 /*State transition failed due to local application reasons*/
2370:../SSC/Src/ecatslv.c ****                 switch(nEcatStateTrans)
 4802              	 .loc 3 2370 0
 4803 0052 464B     	 ldr r3,.L358+20
 4804 0054 1B88     	 ldrh r3,[r3]
 4805 0056 242B     	 cmp r3,#36
 4806 0058 0DD0     	 beq .L341
 4807 005a 242B     	 cmp r3,#36
 4808 005c 03DC     	 bgt .L342
 4809 005e 123B     	 subs r3,r3,#18
 4810 0060 012B     	 cmp r3,#1
 4811 0062 12D8     	 bhi .L340
 4812 0064 02E0     	 b .L356
 4813              	.L342:
 4814 0066 482B     	 cmp r3,#72
 4815 0068 0AD0     	 beq .L344
 4816 006a 0EE0     	 b .L340
 4817              	.L356:
2371:../SSC/Src/ecatslv.c ****                 {
2372:../SSC/Src/ecatslv.c ****                     case INIT_2_PREOP:
2373:../SSC/Src/ecatslv.c ****                     case INIT_2_BOOT:
2374:../SSC/Src/ecatslv.c ****                      
2375:../SSC/Src/ecatslv.c ****                           APPL_StopMailboxHandler();
 4818              	 .loc 3 2375 0
 4819 006c FFF7FEFF 	 bl APPL_StopMailboxHandler
2376:../SSC/Src/ecatslv.c ****                           MBX_StopMailboxHandler();
 4820              	 .loc 3 2376 0
 4821 0070 FFF7FEFF 	 bl MBX_StopMailboxHandler
2377:../SSC/Src/ecatslv.c ****                     break;
 4822              	 .loc 3 2377 0
 4823 0074 09E0     	 b .L340
 4824              	.L341:
2378:../SSC/Src/ecatslv.c ****                     case PREOP_2_SAFEOP:
2379:../SSC/Src/ecatslv.c ****                           APPL_StopInputHandler();
 4825              	 .loc 3 2379 0
 4826 0076 FFF7FEFF 	 bl APPL_StopInputHandler
2380:../SSC/Src/ecatslv.c ****                           StopInputHandler();
 4827              	 .loc 3 2380 0
 4828 007a FFF7FEFF 	 bl StopInputHandler
2381:../SSC/Src/ecatslv.c ****                     break;
 4829              	 .loc 3 2381 0
 4830 007e 04E0     	 b .L340
 4831              	.L344:
2382:../SSC/Src/ecatslv.c ****                     case SAFEOP_2_OP:
2383:../SSC/Src/ecatslv.c ****                           APPL_StopOutputHandler();
 4832              	 .loc 3 2383 0
 4833 0080 FFF7FEFF 	 bl APPL_StopOutputHandler
2384:../SSC/Src/ecatslv.c ****                           StopOutputHandler();
 4834              	 .loc 3 2384 0
 4835 0084 FFF7FEFF 	 bl StopOutputHandler
2385:../SSC/Src/ecatslv.c ****                     break;
 4836              	 .loc 3 2385 0
 4837 0088 00BF     	 nop
 4838              	.L340:
2386:../SSC/Src/ecatslv.c ****                 }
2387:../SSC/Src/ecatslv.c **** 
2388:../SSC/Src/ecatslv.c ****                 /*In case of a failed state transition the */
2389:../SSC/Src/ecatslv.c ****                 Status =  (UINT8)(nEcatStateTrans >> 4);
 4839              	 .loc 3 2389 0
 4840 008a 384B     	 ldr r3,.L358+20
 4841 008c 1B88     	 ldrh r3,[r3]
 4842 008e 1B09     	 lsrs r3,r3,#4
 4843 0090 9BB2     	 uxth r3,r3
 4844 0092 FB73     	 strb r3,[r7,#15]
 4845 0094 23E0     	 b .L345
 4846              	.L339:
2390:../SSC/Src/ecatslv.c ****             }
2391:../SSC/Src/ecatslv.c ****             else
2392:../SSC/Src/ecatslv.c ****             {
2393:../SSC/Src/ecatslv.c ****                 /*State transition succeed*/
2394:../SSC/Src/ecatslv.c ****                  
2395:../SSC/Src/ecatslv.c ****                 switch(nEcatStateTrans)
 4847              	 .loc 3 2395 0
 4848 0096 354B     	 ldr r3,.L358+20
 4849 0098 1B88     	 ldrh r3,[r3]
 4850 009a 242B     	 cmp r3,#36
 4851 009c 0CD0     	 beq .L347
 4852 009e 242B     	 cmp r3,#36
 4853 00a0 03DC     	 bgt .L348
 4854 00a2 123B     	 subs r3,r3,#18
 4855 00a4 012B     	 cmp r3,#1
 4856 00a6 14D8     	 bhi .L346
 4857 00a8 02E0     	 b .L357
 4858              	.L348:
 4859 00aa 482B     	 cmp r3,#72
 4860 00ac 0DD0     	 beq .L350
 4861 00ae 10E0     	 b .L346
 4862              	.L357:
2396:../SSC/Src/ecatslv.c ****                 {
2397:../SSC/Src/ecatslv.c ****                     case INIT_2_PREOP:
2398:../SSC/Src/ecatslv.c ****                     case INIT_2_BOOT:
2399:../SSC/Src/ecatslv.c ****                         bMbxRunning = TRUE;
 4863              	 .loc 3 2399 0
 4864 00b0 2F4B     	 ldr r3,.L358+24
 4865 00b2 0122     	 movs r2,#1
 4866 00b4 1A70     	 strb r2,[r3]
2400:../SSC/Src/ecatslv.c ****                     break;
 4867              	 .loc 3 2400 0
 4868 00b6 0CE0     	 b .L346
 4869              	.L347:
2401:../SSC/Src/ecatslv.c ****                     case PREOP_2_SAFEOP:
2402:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ESM4*/
2403:../SSC/Src/ecatslv.c ****                         /* initialize the AL Event Mask register (0x204) */
2404:../SSC/Src/ecatslv.c ****                         SetALEventMask(u16ALEventMask);
 4870              	 .loc 3 2404 0
 4871 00b8 2E4B     	 ldr r3,.L358+28
 4872 00ba 1B88     	 ldrh r3,[r3]
 4873 00bc 1846     	 mov r0,r3
 4874 00be FFF7FEFF 	 bl SetALEventMask
2405:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ESM4*/
2406:../SSC/Src/ecatslv.c ****                         bEcatInputUpdateRunning = TRUE;
 4875              	 .loc 3 2406 0
 4876 00c2 2D4B     	 ldr r3,.L358+32
 4877 00c4 0122     	 movs r2,#1
 4878 00c6 1A70     	 strb r2,[r3]
2407:../SSC/Src/ecatslv.c ****                     break;
 4879              	 .loc 3 2407 0
 4880 00c8 03E0     	 b .L346
 4881              	.L350:
2408:../SSC/Src/ecatslv.c ****                     case SAFEOP_2_OP:
2409:../SSC/Src/ecatslv.c ****                           bEcatOutputUpdateRunning = TRUE;
 4882              	 .loc 3 2409 0
 4883 00ca 2C4B     	 ldr r3,.L358+36
 4884 00cc 0122     	 movs r2,#1
 4885 00ce 1A70     	 strb r2,[r3]
2410:../SSC/Src/ecatslv.c ****                     break;
 4886              	 .loc 3 2410 0
 4887 00d0 00BF     	 nop
 4888              	.L346:
2411:../SSC/Src/ecatslv.c ****                 }
2412:../SSC/Src/ecatslv.c **** 
2413:../SSC/Src/ecatslv.c ****                 /*In case of a failed state transition the */
2414:../SSC/Src/ecatslv.c ****                 Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
 4889              	 .loc 3 2414 0
 4890 00d2 264B     	 ldr r3,.L358+20
 4891 00d4 1B88     	 ldrh r3,[r3]
 4892 00d6 DBB2     	 uxtb r3,r3
 4893 00d8 03F00F03 	 and r3,r3,#15
 4894 00dc FB73     	 strb r3,[r7,#15]
 4895              	.L345:
2415:../SSC/Src/ecatslv.c ****             }
2416:../SSC/Src/ecatslv.c ****                 /*Pending state transition finished => write AL Status and AL Status Code*/
2417:../SSC/Src/ecatslv.c ****                 bEcatWaitForAlControlRes = FALSE;
 4896              	 .loc 3 2417 0
 4897 00de 1E4B     	 ldr r3,.L358
 4898 00e0 0022     	 movs r2,#0
 4899 00e2 1A70     	 strb r2,[r3]
2418:../SSC/Src/ecatslv.c **** 
2419:../SSC/Src/ecatslv.c ****                 if (alStatusCode != 0)
 4900              	 .loc 3 2419 0
 4901 00e4 BB88     	 ldrh r3,[r7,#4]
 4902 00e6 002B     	 cmp r3,#0
 4903 00e8 03D0     	 beq .L351
2420:../SSC/Src/ecatslv.c ****                 {
2421:../SSC/Src/ecatslv.c ****                     Status |= STATE_CHANGE;
 4904              	 .loc 3 2421 0
 4905 00ea FB7B     	 ldrb r3,[r7,#15]
 4906 00ec 43F01003 	 orr r3,r3,#16
 4907 00f0 FB73     	 strb r3,[r7,#15]
 4908              	.L351:
2422:../SSC/Src/ecatslv.c ****                 }
2423:../SSC/Src/ecatslv.c **** 
2424:../SSC/Src/ecatslv.c ****                 SetALStatus(Status,alStatusCode);
 4909              	 .loc 3 2424 0
 4910 00f2 FA7B     	 ldrb r2,[r7,#15]
 4911 00f4 BB88     	 ldrh r3,[r7,#4]
 4912 00f6 1046     	 mov r0,r2
 4913 00f8 1946     	 mov r1,r3
 4914 00fa FFF7FEFF 	 bl SetALStatus
 4915 00fe 28E0     	 b .L334
 4916              	.L335:
2425:../SSC/Src/ecatslv.c **** 
2426:../SSC/Src/ecatslv.c ****         }// state transition need to be completed by the local application
2427:../SSC/Src/ecatslv.c ****     }//State transition pending
2428:../SSC/Src/ecatslv.c ****     else
2429:../SSC/Src/ecatslv.c ****     {
2430:../SSC/Src/ecatslv.c ****         if ( alStatusCode != 0 )
 4917              	 .loc 3 2430 0
 4918 0100 BB88     	 ldrh r3,[r7,#4]
 4919 0102 002B     	 cmp r3,#0
 4920 0104 1BD0     	 beq .L353
2431:../SSC/Src/ecatslv.c ****         {
2432:../SSC/Src/ecatslv.c ****             bLocalErrorFlag = TRUE;
 4921              	 .loc 3 2432 0
 4922 0106 164B     	 ldr r3,.L358+8
 4923 0108 0122     	 movs r2,#1
 4924 010a 1A70     	 strb r2,[r3]
2433:../SSC/Src/ecatslv.c ****             u16LocalErrorCode = alStatusCode;
 4925              	 .loc 3 2433 0
 4926 010c 154A     	 ldr r2,.L358+12
 4927 010e BB88     	 ldrh r3,[r7,#4]
 4928 0110 1380     	 strh r3,[r2]
2434:../SSC/Src/ecatslv.c **** 
2435:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.12) ESM1*/    
2436:../SSC/Src/ecatslv.c ****             if (((nAlStatus & STATE_CHANGE) != STATE_CHANGE) || ((alStatus & STATE_MASK) < (nAlStat
 4929              	 .loc 3 2436 0
 4930 0112 1B4B     	 ldr r3,.L358+40
 4931 0114 1B78     	 ldrb r3,[r3]
 4932 0116 03F01003 	 and r3,r3,#16
 4933 011a 002B     	 cmp r3,#0
 4934 011c 08D0     	 beq .L354
 4935              	 .loc 3 2436 0 is_stmt 0 discriminator 1
 4936 011e FB79     	 ldrb r3,[r7,#7]
 4937 0120 03F00F02 	 and r2,r3,#15
 4938 0124 164B     	 ldr r3,.L358+40
 4939 0126 1B78     	 ldrb r3,[r3]
 4940 0128 03F00F03 	 and r3,r3,#15
 4941 012c 9A42     	 cmp r2,r3
 4942 012e 10DA     	 bge .L334
 4943              	.L354:
2437:../SSC/Src/ecatslv.c ****             {
2438:../SSC/Src/ecatslv.c ****                 /* Local error has happened, we change the state if necessary */
2439:../SSC/Src/ecatslv.c **** 
2440:../SSC/Src/ecatslv.c ****                /* no error pending and the target state is lower than the current one*/
2441:../SSC/Src/ecatslv.c ****                 AL_ControlInd(alStatus, alStatusCode);
 4944              	 .loc 3 2441 0 is_stmt 1
 4945 0130 FA79     	 ldrb r2,[r7,#7]
 4946 0132 BB88     	 ldrh r3,[r7,#4]
 4947 0134 1046     	 mov r0,r2
 4948 0136 1946     	 mov r1,r3
 4949 0138 FFF7FEFF 	 bl AL_ControlInd
 4950 013c 09E0     	 b .L334
 4951              	.L353:
2442:../SSC/Src/ecatslv.c ****             }
2443:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.12) ESM1*/    
2444:../SSC/Src/ecatslv.c ****         }
2445:../SSC/Src/ecatslv.c ****         else if (bLocalErrorFlag)
 4952              	 .loc 3 2445 0
 4953 013e 084B     	 ldr r3,.L358+8
 4954 0140 1B78     	 ldrb r3,[r3]
 4955 0142 002B     	 cmp r3,#0
 4956 0144 05D0     	 beq .L334
2446:../SSC/Src/ecatslv.c ****         {
2447:../SSC/Src/ecatslv.c ****             /*a local error is gone*/
2448:../SSC/Src/ecatslv.c ****             bLocalErrorFlag = FALSE;
 4957              	 .loc 3 2448 0
 4958 0146 064B     	 ldr r3,.L358+8
 4959 0148 0022     	 movs r2,#0
 4960 014a 1A70     	 strb r2,[r3]
2449:../SSC/Src/ecatslv.c ****             u16LocalErrorCode = 0x00;
 4961              	 .loc 3 2449 0
 4962 014c 054B     	 ldr r3,.L358+12
 4963 014e 0022     	 movs r2,#0
 4964 0150 1A80     	 strh r2,[r3]
 4965              	.L334:
2450:../SSC/Src/ecatslv.c ****         }
2451:../SSC/Src/ecatslv.c ****     }
2452:../SSC/Src/ecatslv.c **** }
 4966              	 .loc 3 2452 0
 4967 0152 1037     	 adds r7,r7,#16
 4968              	.LCFI101:
 4969              	 .cfi_def_cfa_offset 8
 4970 0154 BD46     	 mov sp,r7
 4971              	.LCFI102:
 4972              	 .cfi_def_cfa_register 13
 4973              	 
 4974 0156 80BD     	 pop {r7,pc}
 4975              	.L359:
 4976              	 .align 2
 4977              	.L358:
 4978 0158 00000000 	 .word bEcatWaitForAlControlRes
 4979 015c 00000000 	 .word bApplEsmPending
 4980 0160 00000000 	 .word bLocalErrorFlag
 4981 0164 00000000 	 .word u16LocalErrorCode
 4982 0168 00000000 	 .word EsmTimeoutCounter
 4983 016c 00000000 	 .word nEcatStateTrans
 4984 0170 00000000 	 .word bMbxRunning
 4985 0174 00000000 	 .word u16ALEventMask
 4986 0178 00000000 	 .word bEcatInputUpdateRunning
 4987 017c 00000000 	 .word bEcatOutputUpdateRunning
 4988 0180 00000000 	 .word nAlStatus
 4989              	 .cfi_endproc
 4990              	.LFE194:
 4992              	 .section .text.ECAT_Init,"ax",%progbits
 4993              	 .align 2
 4994              	 .global ECAT_Init
 4995              	 .thumb
 4996              	 .thumb_func
 4998              	ECAT_Init:
 4999              	.LFB195:
2453:../SSC/Src/ecatslv.c **** 
2454:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
2455:../SSC/Src/ecatslv.c **** /**
2456:../SSC/Src/ecatslv.c **** 
2457:../SSC/Src/ecatslv.c ****  \brief    This function initialize the EtherCAT Slave Interface.
2458:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
2459:../SSC/Src/ecatslv.c **** 
2460:../SSC/Src/ecatslv.c **** void ECAT_Init(void)
2461:../SSC/Src/ecatslv.c **** {
 5000              	 .loc 3 2461 0
 5001              	 .cfi_startproc
 5002              	 
 5003              	 
 5004 0000 80B5     	 push {r7,lr}
 5005              	.LCFI103:
 5006              	 .cfi_def_cfa_offset 8
 5007              	 .cfi_offset 7,-8
 5008              	 .cfi_offset 14,-4
 5009 0002 82B0     	 sub sp,sp,#8
 5010              	.LCFI104:
 5011              	 .cfi_def_cfa_offset 16
 5012 0004 00AF     	 add r7,sp,#0
 5013              	.LCFI105:
 5014              	 .cfi_def_cfa_register 7
2462:../SSC/Src/ecatslv.c ****     UINT8 i;
2463:../SSC/Src/ecatslv.c **** 
2464:../SSC/Src/ecatslv.c ****     /*Get Maximum Number of SyncManagers and supported DPRAM size*/
2465:../SSC/Src/ecatslv.c ****     HW_EscReadByte(nMaxSyncMan, ESC_SM_CHANNELS_OFFSET);
 5015              	 .loc 3 2465 0
 5016 0006 3B4B     	 ldr r3,.L363
 5017 0008 1B78     	 ldrb r3,[r3]
 5018 000a DAB2     	 uxtb r2,r3
 5019 000c 3A4B     	 ldr r3,.L363+4
 5020 000e 1A70     	 strb r2,[r3]
2466:../SSC/Src/ecatslv.c **** 
2467:../SSC/Src/ecatslv.c ****     HW_EscReadWord(nMaxEscAddress, ESC_DPRAM_SIZE_OFFSET);
 5021              	 .loc 3 2467 0
 5022 0010 3A4B     	 ldr r3,.L363+8
 5023 0012 1B88     	 ldrh r3,[r3]
 5024 0014 9AB2     	 uxth r2,r3
 5025 0016 3A4B     	 ldr r3,.L363+12
 5026 0018 1A80     	 strh r2,[r3]
2468:../SSC/Src/ecatslv.c ****     //get max address (register + DPRAM size in Byte (in the register it is stored in KB))
2469:../SSC/Src/ecatslv.c ****     nMaxEscAddress = (nMaxEscAddress << 10) + 0xFFF;
 5027              	 .loc 3 2469 0
 5028 001a 394B     	 ldr r3,.L363+12
 5029 001c 1B88     	 ldrh r3,[r3]
 5030 001e 9B02     	 lsls r3,r3,#10
 5031 0020 9BB2     	 uxth r3,r3
 5032 0022 03F6FF73 	 addw r3,r3,#4095
 5033 0026 9AB2     	 uxth r2,r3
 5034 0028 354B     	 ldr r3,.L363+12
 5035 002a 1A80     	 strh r2,[r3]
2470:../SSC/Src/ecatslv.c **** 
2471:../SSC/Src/ecatslv.c ****     /* Get EEPROM loaded information */
2472:../SSC/Src/ecatslv.c ****     UpdateEEPROMLoadedState();
 5036              	 .loc 3 2472 0
 5037 002c FFF7FEFF 	 bl UpdateEEPROMLoadedState
2473:../SSC/Src/ecatslv.c **** 
2474:../SSC/Src/ecatslv.c ****     /* disable all Sync Manager channels */
2475:../SSC/Src/ecatslv.c ****     for (i = 0; i < nMaxSyncMan; i++)
 5038              	 .loc 3 2475 0
 5039 0030 0023     	 movs r3,#0
 5040 0032 FB71     	 strb r3,[r7,#7]
 5041 0034 06E0     	 b .L361
 5042              	.L362:
2476:../SSC/Src/ecatslv.c ****     {
2477:../SSC/Src/ecatslv.c ****         DisableSyncManChannel(i);
 5043              	 .loc 3 2477 0 discriminator 3
 5044 0036 FB79     	 ldrb r3,[r7,#7]
 5045 0038 1846     	 mov r0,r3
 5046 003a FFF7FEFF 	 bl DisableSyncManChannel
2475:../SSC/Src/ecatslv.c ****     {
 5047              	 .loc 3 2475 0 discriminator 3
 5048 003e FB79     	 ldrb r3,[r7,#7]
 5049 0040 0133     	 adds r3,r3,#1
 5050 0042 FB71     	 strb r3,[r7,#7]
 5051              	.L361:
2475:../SSC/Src/ecatslv.c ****     {
 5052              	 .loc 3 2475 0 is_stmt 0 discriminator 1
 5053 0044 2C4B     	 ldr r3,.L363+4
 5054 0046 1B78     	 ldrb r3,[r3]
 5055 0048 FA79     	 ldrb r2,[r7,#7]
 5056 004a 9A42     	 cmp r2,r3
 5057 004c F3D3     	 bcc .L362
2478:../SSC/Src/ecatslv.c ****     }
2479:../SSC/Src/ecatslv.c **** 
2480:../SSC/Src/ecatslv.c ****     /* initialize the mailbox handler */
2481:../SSC/Src/ecatslv.c ****     MBX_Init();
 5058              	 .loc 3 2481 0 is_stmt 1
 5059 004e FFF7FEFF 	 bl MBX_Init
2482:../SSC/Src/ecatslv.c **** 
2483:../SSC/Src/ecatslv.c ****     /* initialize variables */
2484:../SSC/Src/ecatslv.c ****     bBootMode = FALSE;
 5060              	 .loc 3 2484 0
 5061 0052 2C4B     	 ldr r3,.L363+16
 5062 0054 0022     	 movs r2,#0
 5063 0056 1A70     	 strb r2,[r3]
2485:../SSC/Src/ecatslv.c ****     bApplEsmPending = FALSE;
 5064              	 .loc 3 2485 0
 5065 0058 2B4B     	 ldr r3,.L363+20
 5066 005a 0022     	 movs r2,#0
 5067 005c 1A70     	 strb r2,[r3]
2486:../SSC/Src/ecatslv.c ****     bEcatWaitForAlControlRes = FALSE;
 5068              	 .loc 3 2486 0
 5069 005e 2B4B     	 ldr r3,.L363+24
 5070 0060 0022     	 movs r2,#0
 5071 0062 1A70     	 strb r2,[r3]
2487:../SSC/Src/ecatslv.c ****     bEcatFirstOutputsReceived = FALSE;
 5072              	 .loc 3 2487 0
 5073 0064 2A4B     	 ldr r3,.L363+28
 5074 0066 0022     	 movs r2,#0
 5075 0068 1A70     	 strb r2,[r3]
2488:../SSC/Src/ecatslv.c ****      bEcatOutputUpdateRunning = FALSE;
 5076              	 .loc 3 2488 0
 5077 006a 2A4B     	 ldr r3,.L363+32
 5078 006c 0022     	 movs r2,#0
 5079 006e 1A70     	 strb r2,[r3]
2489:../SSC/Src/ecatslv.c ****      bEcatInputUpdateRunning = FALSE;
 5080              	 .loc 3 2489 0
 5081 0070 294B     	 ldr r3,.L363+36
 5082 0072 0022     	 movs r2,#0
 5083 0074 1A70     	 strb r2,[r3]
2490:../SSC/Src/ecatslv.c ****     bWdTrigger = FALSE;
 5084              	 .loc 3 2490 0
 5085 0076 294B     	 ldr r3,.L363+40
 5086 0078 0022     	 movs r2,#0
 5087 007a 1A70     	 strb r2,[r3]
2491:../SSC/Src/ecatslv.c ****     EcatWdValue = 0;
 5088              	 .loc 3 2491 0
 5089 007c 284B     	 ldr r3,.L363+44
 5090 007e 0022     	 movs r2,#0
 5091 0080 1A80     	 strh r2,[r3]
2492:../SSC/Src/ecatslv.c ****     Sync0WdCounter = 0;
 5092              	 .loc 3 2492 0
 5093 0082 284B     	 ldr r3,.L363+48
 5094 0084 0022     	 movs r2,#0
 5095 0086 1A80     	 strh r2,[r3]
2493:../SSC/Src/ecatslv.c ****     Sync0WdValue = 0;
 5096              	 .loc 3 2493 0
 5097 0088 274B     	 ldr r3,.L363+52
 5098 008a 0022     	 movs r2,#0
 5099 008c 1A80     	 strh r2,[r3]
2494:../SSC/Src/ecatslv.c ****     Sync1WdCounter = 0;
 5100              	 .loc 3 2494 0
 5101 008e 274B     	 ldr r3,.L363+56
 5102 0090 0022     	 movs r2,#0
 5103 0092 1A80     	 strh r2,[r3]
2495:../SSC/Src/ecatslv.c ****     Sync1WdValue = 0;
 5104              	 .loc 3 2495 0
 5105 0094 264B     	 ldr r3,.L363+60
 5106 0096 0022     	 movs r2,#0
 5107 0098 1A80     	 strh r2,[r3]
2496:../SSC/Src/ecatslv.c ****     bDcSyncActive = FALSE;
 5108              	 .loc 3 2496 0
 5109 009a 264B     	 ldr r3,.L363+64
 5110 009c 0022     	 movs r2,#0
 5111 009e 1A70     	 strb r2,[r3]
2497:../SSC/Src/ecatslv.c ****     bLocalErrorFlag = FALSE;
 5112              	 .loc 3 2497 0
 5113 00a0 254B     	 ldr r3,.L363+68
 5114 00a2 0022     	 movs r2,#0
 5115 00a4 1A70     	 strb r2,[r3]
2498:../SSC/Src/ecatslv.c ****     u16LocalErrorCode = 0x00;
 5116              	 .loc 3 2498 0
 5117 00a6 254B     	 ldr r3,.L363+72
 5118 00a8 0022     	 movs r2,#0
 5119 00aa 1A80     	 strh r2,[r3]
2499:../SSC/Src/ecatslv.c **** 
2500:../SSC/Src/ecatslv.c ****     u16ALEventMask = 0;
 5120              	 .loc 3 2500 0
 5121 00ac 244B     	 ldr r3,.L363+76
 5122 00ae 0022     	 movs r2,#0
 5123 00b0 1A80     	 strh r2,[r3]
2501:../SSC/Src/ecatslv.c ****     nPdOutputSize = 0;
 5124              	 .loc 3 2501 0
 5125 00b2 244B     	 ldr r3,.L363+80
 5126 00b4 0022     	 movs r2,#0
 5127 00b6 1A80     	 strh r2,[r3]
2502:../SSC/Src/ecatslv.c ****     nPdInputSize = 0;
 5128              	 .loc 3 2502 0
 5129 00b8 234B     	 ldr r3,.L363+84
 5130 00ba 0022     	 movs r2,#0
 5131 00bc 1A80     	 strh r2,[r3]
2503:../SSC/Src/ecatslv.c **** 
2504:../SSC/Src/ecatslv.c ****     /* initialize the AL Status register */
2505:../SSC/Src/ecatslv.c ****     nAlStatus    = STATE_INIT;
 5132              	 .loc 3 2505 0
 5133 00be 234B     	 ldr r3,.L363+88
 5134 00c0 0122     	 movs r2,#1
 5135 00c2 1A70     	 strb r2,[r3]
2506:../SSC/Src/ecatslv.c ****     SetALStatus(nAlStatus, 0);
 5136              	 .loc 3 2506 0
 5137 00c4 214B     	 ldr r3,.L363+88
 5138 00c6 1B78     	 ldrb r3,[r3]
 5139 00c8 1846     	 mov r0,r3
 5140 00ca 0021     	 movs r1,#0
 5141 00cc FFF7FEFF 	 bl SetALStatus
2507:../SSC/Src/ecatslv.c ****     nEcatStateTrans = 0;
 5142              	 .loc 3 2507 0
 5143 00d0 1F4B     	 ldr r3,.L363+92
 5144 00d2 0022     	 movs r2,#0
 5145 00d4 1A80     	 strh r2,[r3]
2508:../SSC/Src/ecatslv.c ****     u8EcatErrorLed = LED_OFF;
 5146              	 .loc 3 2508 0
 5147 00d6 1F4B     	 ldr r3,.L363+96
 5148 00d8 0022     	 movs r2,#0
 5149 00da 1A70     	 strb r2,[r3]
2509:../SSC/Src/ecatslv.c **** 
2510:../SSC/Src/ecatslv.c ****     bEscIntEnabled = FALSE;
 5150              	 .loc 3 2510 0
 5151 00dc 1E4B     	 ldr r3,.L363+100
 5152 00de 0022     	 movs r2,#0
 5153 00e0 1A70     	 strb r2,[r3]
2511:../SSC/Src/ecatslv.c **** 
2512:../SSC/Src/ecatslv.c ****     /* initialize the COE part */
2513:../SSC/Src/ecatslv.c ****     COE_Init();
 5154              	 .loc 3 2513 0
 5155 00e2 FFF7FEFF 	 bl COE_Init
2514:../SSC/Src/ecatslv.c **** 
2515:../SSC/Src/ecatslv.c ****     /*reset AL event mask*/
2516:../SSC/Src/ecatslv.c ****     ResetALEventMask(0);
 5156              	 .loc 3 2516 0
 5157 00e6 0020     	 movs r0,#0
 5158 00e8 FFF7FEFF 	 bl ResetALEventMask
2517:../SSC/Src/ecatslv.c **** }
 5159              	 .loc 3 2517 0
 5160 00ec 0837     	 adds r7,r7,#8
 5161              	.LCFI106:
 5162              	 .cfi_def_cfa_offset 8
 5163 00ee BD46     	 mov sp,r7
 5164              	.LCFI107:
 5165              	 .cfi_def_cfa_register 13
 5166              	 
 5167 00f0 80BD     	 pop {r7,pc}
 5168              	.L364:
 5169 00f2 00BF     	 .align 2
 5170              	.L363:
 5171 00f4 05000154 	 .word 1409351685
 5172 00f8 00000000 	 .word nMaxSyncMan
 5173 00fc 06000154 	 .word 1409351686
 5174 0100 00000000 	 .word nMaxEscAddress
 5175 0104 00000000 	 .word bBootMode
 5176 0108 00000000 	 .word bApplEsmPending
 5177 010c 00000000 	 .word bEcatWaitForAlControlRes
 5178 0110 00000000 	 .word bEcatFirstOutputsReceived
 5179 0114 00000000 	 .word bEcatOutputUpdateRunning
 5180 0118 00000000 	 .word bEcatInputUpdateRunning
 5181 011c 00000000 	 .word bWdTrigger
 5182 0120 00000000 	 .word EcatWdValue
 5183 0124 00000000 	 .word Sync0WdCounter
 5184 0128 00000000 	 .word Sync0WdValue
 5185 012c 00000000 	 .word Sync1WdCounter
 5186 0130 00000000 	 .word Sync1WdValue
 5187 0134 00000000 	 .word bDcSyncActive
 5188 0138 00000000 	 .word bLocalErrorFlag
 5189 013c 00000000 	 .word u16LocalErrorCode
 5190 0140 00000000 	 .word u16ALEventMask
 5191 0144 00000000 	 .word nPdOutputSize
 5192 0148 00000000 	 .word nPdInputSize
 5193 014c 00000000 	 .word nAlStatus
 5194 0150 00000000 	 .word nEcatStateTrans
 5195 0154 00000000 	 .word u8EcatErrorLed
 5196 0158 00000000 	 .word bEscIntEnabled
 5197              	 .cfi_endproc
 5198              	.LFE195:
 5200              	 .section .text.ECAT_Main,"ax",%progbits
 5201              	 .align 2
 5202              	 .global ECAT_Main
 5203              	 .thumb
 5204              	 .thumb_func
 5206              	ECAT_Main:
 5207              	.LFB196:
2518:../SSC/Src/ecatslv.c **** 
2519:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
2520:../SSC/Src/ecatslv.c **** /**
2521:../SSC/Src/ecatslv.c ****  \brief        This function has to be called cyclically.
2522:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
2523:../SSC/Src/ecatslv.c **** 
2524:../SSC/Src/ecatslv.c **** void ECAT_Main(void)
2525:../SSC/Src/ecatslv.c **** {
 5208              	 .loc 3 2525 0
 5209              	 .cfi_startproc
 5210              	 
 5211              	 
 5212 0000 80B5     	 push {r7,lr}
 5213              	.LCFI108:
 5214              	 .cfi_def_cfa_offset 8
 5215              	 .cfi_offset 7,-8
 5216              	 .cfi_offset 14,-4
 5217 0002 82B0     	 sub sp,sp,#8
 5218              	.LCFI109:
 5219              	 .cfi_def_cfa_offset 16
 5220 0004 00AF     	 add r7,sp,#0
 5221              	.LCFI110:
 5222              	 .cfi_def_cfa_register 7
2526:../SSC/Src/ecatslv.c ****     UINT16 ALEventReg;
2527:../SSC/Src/ecatslv.c ****     UINT16 EscAlControl = 0x0000;
 5223              	 .loc 3 2527 0
 5224 0006 0023     	 movs r3,#0
 5225 0008 7B80     	 strh r3,[r7,#2]
2528:../SSC/Src/ecatslv.c ****     UINT8 sm1Activate = SM_SETTING_ENABLE_VALUE;
 5226              	 .loc 3 2528 0
 5227 000a 0123     	 movs r3,#1
 5228 000c 7B71     	 strb r3,[r7,#5]
2529:../SSC/Src/ecatslv.c **** 
2530:../SSC/Src/ecatslv.c **** 
2531:../SSC/Src/ecatslv.c ****     /* check if services are stored in the mailbox */
2532:../SSC/Src/ecatslv.c ****     MBX_Main();
 5229              	 .loc 3 2532 0
 5230 000e FFF7FEFF 	 bl MBX_Main
2533:../SSC/Src/ecatslv.c **** 
2534:../SSC/Src/ecatslv.c **** 
2535:../SSC/Src/ecatslv.c ****     if ( bMbxRunning )
 5231              	 .loc 3 2535 0
 5232 0012 584B     	 ldr r3,.L377
 5233 0014 1B78     	 ldrb r3,[r3]
 5234 0016 002B     	 cmp r3,#0
 5235 0018 02D0     	 beq .L366
2536:../SSC/Src/ecatslv.c ****     {
2537:../SSC/Src/ecatslv.c ****         /* Slave is at least in PREOP, Mailbox is running */
2538:../SSC/Src/ecatslv.c ****         /* get the Activate-Byte of SM 1 (Register 0x80E) to check if a mailbox repeat request was 
2539:../SSC/Src/ecatslv.c ****         HW_EscReadByte(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
 5236              	 .loc 3 2539 0
 5237 001a 574B     	 ldr r3,.L377+4
 5238 001c 1B78     	 ldrb r3,[r3]
 5239 001e 7B71     	 strb r3,[r7,#5]
 5240              	.L366:
2540:../SSC/Src/ecatslv.c ****     }
2541:../SSC/Src/ecatslv.c **** 
2542:../SSC/Src/ecatslv.c ****     /* Read AL Event-Register from ESC */
2543:../SSC/Src/ecatslv.c ****     ALEventReg = HW_GetALEventRegister();
 5241              	 .loc 3 2543 0
 5242 0020 FFF7FEFF 	 bl HW_GetALEventRegister
 5243 0024 0346     	 mov r3,r0
 5244 0026 FB80     	 strh r3,[r7,#6]
2544:../SSC/Src/ecatslv.c ****     ALEventReg = SWAPWORD(ALEventReg);
2545:../SSC/Src/ecatslv.c **** 
2546:../SSC/Src/ecatslv.c ****     if ((ALEventReg & EEPROM_CMD_PENDING)) 
 5245              	 .loc 3 2546 0
 5246 0028 FB88     	 ldrh r3,[r7,#6]
 5247 002a 03F02003 	 and r3,r3,#32
 5248 002e 002B     	 cmp r3,#0
 5249 0030 01D0     	 beq .L367
2547:../SSC/Src/ecatslv.c ****     {
2548:../SSC/Src/ecatslv.c ****         EEPROM_CommandHandler();
 5250              	 .loc 3 2548 0
 5251 0032 FFF7FEFF 	 bl EEPROM_CommandHandler
 5252              	.L367:
2549:../SSC/Src/ecatslv.c ****     }
2550:../SSC/Src/ecatslv.c **** 
2551:../SSC/Src/ecatslv.c ****     if ((ALEventReg & AL_CONTROL_EVENT) && !bEcatWaitForAlControlRes)
 5253              	 .loc 3 2551 0
 5254 0036 FB88     	 ldrh r3,[r7,#6]
 5255 0038 03F00103 	 and r3,r3,#1
 5256 003c 002B     	 cmp r3,#0
 5257 003e 14D0     	 beq .L368
 5258              	 .loc 3 2551 0 is_stmt 0 discriminator 1
 5259 0040 4E4B     	 ldr r3,.L377+8
 5260 0042 1B78     	 ldrb r3,[r3]
 5261 0044 83F00103 	 eor r3,r3,#1
 5262 0048 DBB2     	 uxtb r3,r3
 5263 004a 002B     	 cmp r3,#0
 5264 004c 0DD0     	 beq .L368
2552:../SSC/Src/ecatslv.c ****     {
2553:../SSC/Src/ecatslv.c ****         /* AL Control event is set, get the AL Control register sent by the Master to acknowledge t
2554:../SSC/Src/ecatslv.c ****           (that the corresponding bit in the AL Event register will be reset) */
2555:../SSC/Src/ecatslv.c ****         HW_EscReadByte( EscAlControl, ESC_AL_CONTROL_OFFSET);
 5265              	 .loc 3 2555 0 is_stmt 1
 5266 004e 4C4B     	 ldr r3,.L377+12
 5267 0050 1B78     	 ldrb r3,[r3]
 5268 0052 DBB2     	 uxtb r3,r3
 5269 0054 7B80     	 strh r3,[r7,#2]
2556:../SSC/Src/ecatslv.c ****         EscAlControl = SWAPWORD(EscAlControl);
2557:../SSC/Src/ecatslv.c **** 
2558:../SSC/Src/ecatslv.c **** 
2559:../SSC/Src/ecatslv.c ****         /* reset AL Control event and the SM Change event (because the Sync Manager settings will b
2560:../SSC/Src/ecatslv.c ****            in AL_ControlInd, too)*/
2561:../SSC/Src/ecatslv.c ****         ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));
 5270              	 .loc 3 2561 0
 5271 0056 FB88     	 ldrh r3,[r7,#6]
 5272 0058 23F01103 	 bic r3,r3,#17
 5273 005c FB80     	 strh r3,[r7,#6]
2562:../SSC/Src/ecatslv.c **** 
2563:../SSC/Src/ecatslv.c ****         AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be che
 5274              	 .loc 3 2563 0
 5275 005e 7B88     	 ldrh r3,[r7,#2]
 5276 0060 DBB2     	 uxtb r3,r3
 5277 0062 1846     	 mov r0,r3
 5278 0064 0021     	 movs r1,#0
 5279 0066 FFF7FEFF 	 bl AL_ControlInd
 5280              	.L368:
2564:../SSC/Src/ecatslv.c ****         
2565:../SSC/Src/ecatslv.c ****         /* SM-Change-Event was handled too */
2566:../SSC/Src/ecatslv.c ****     }
2567:../SSC/Src/ecatslv.c **** 
2568:../SSC/Src/ecatslv.c ****     if ( (ALEventReg & SM_CHANGE_EVENT) && !bEcatWaitForAlControlRes && (nAlStatus & STATE_CHANGE) 
 5281              	 .loc 3 2568 0
 5282 006a FB88     	 ldrh r3,[r7,#6]
 5283 006c 03F01003 	 and r3,r3,#16
 5284 0070 002B     	 cmp r3,#0
 5285 0072 1FD0     	 beq .L369
 5286              	 .loc 3 2568 0 is_stmt 0 discriminator 1
 5287 0074 414B     	 ldr r3,.L377+8
 5288 0076 1B78     	 ldrb r3,[r3]
 5289 0078 83F00103 	 eor r3,r3,#1
 5290 007c DBB2     	 uxtb r3,r3
 5291 007e 002B     	 cmp r3,#0
 5292 0080 18D0     	 beq .L369
 5293              	 .loc 3 2568 0 discriminator 2
 5294 0082 404B     	 ldr r3,.L377+16
 5295 0084 1B78     	 ldrb r3,[r3]
 5296 0086 03F01003 	 and r3,r3,#16
 5297 008a 002B     	 cmp r3,#0
 5298 008c 12D1     	 bne .L369
 5299              	 .loc 3 2568 0 discriminator 3
 5300 008e 3D4B     	 ldr r3,.L377+16
 5301 0090 1B78     	 ldrb r3,[r3]
 5302 0092 23F01003 	 bic r3,r3,#16
 5303 0096 012B     	 cmp r3,#1
 5304 0098 0CD0     	 beq .L369
2569:../SSC/Src/ecatslv.c ****     {
2570:../SSC/Src/ecatslv.c ****         /* the SM Change event is set (Bit 4 of Register 0x220), when the Byte 6 (Enable, Lo-Byte o
2571:../SSC/Src/ecatslv.c ****            of a Sync Manager channel was written */
2572:../SSC/Src/ecatslv.c ****         ALEventReg &= ~(SM_CHANGE_EVENT);
 5305              	 .loc 3 2572 0 is_stmt 1
 5306 009a FB88     	 ldrh r3,[r7,#6]
 5307 009c 23F01003 	 bic r3,r3,#16
 5308 00a0 FB80     	 strh r3,[r7,#6]
2573:../SSC/Src/ecatslv.c **** 
2574:../SSC/Src/ecatslv.c ****         /* AL_ControlInd is called with the actual state, so that the correct SM settings will be c
2575:../SSC/Src/ecatslv.c ****         AL_ControlInd(nAlStatus & STATE_MASK, 0);
 5309              	 .loc 3 2575 0
 5310 00a2 384B     	 ldr r3,.L377+16
 5311 00a4 1B78     	 ldrb r3,[r3]
 5312 00a6 03F00F03 	 and r3,r3,#15
 5313 00aa DBB2     	 uxtb r3,r3
 5314 00ac 1846     	 mov r0,r3
 5315 00ae 0021     	 movs r1,#0
 5316 00b0 FFF7FEFF 	 bl AL_ControlInd
 5317              	.L369:
2576:../SSC/Src/ecatslv.c ****     }
2577:../SSC/Src/ecatslv.c **** 
2578:../SSC/Src/ecatslv.c ****     if(bEcatWaitForAlControlRes)
 5318              	 .loc 3 2578 0
 5319 00b4 314B     	 ldr r3,.L377+8
 5320 00b6 1B78     	 ldrb r3,[r3]
 5321 00b8 002B     	 cmp r3,#0
 5322 00ba 01D0     	 beq .L370
2579:../SSC/Src/ecatslv.c ****     {
2580:../SSC/Src/ecatslv.c ****         AL_ControlRes();
 5323              	 .loc 3 2580 0
 5324 00bc FFF7FEFF 	 bl AL_ControlRes
 5325              	.L370:
2581:../SSC/Src/ecatslv.c ****     }
2582:../SSC/Src/ecatslv.c ****     /*The order of mailbox event processing was changed to prevent race condition errors.
2583:../SSC/Src/ecatslv.c ****         The SM1 activate Byte (Register 0x80E) was read before reading AL Event register.
2584:../SSC/Src/ecatslv.c ****         1. Handle Mailbox Read event
2585:../SSC/Src/ecatslv.c ****         2. Handle repeat toggle request
2586:../SSC/Src/ecatslv.c ****         3. Handle Mailbox write event
2587:../SSC/Src/ecatslv.c ****     */
2588:../SSC/Src/ecatslv.c ****     if ( bMbxRunning )
 5326              	 .loc 3 2588 0
 5327 00c0 2C4B     	 ldr r3,.L377
 5328 00c2 1B78     	 ldrb r3,[r3]
 5329 00c4 002B     	 cmp r3,#0
 5330 00c6 52D0     	 beq .L365
2589:../SSC/Src/ecatslv.c ****     {
2590:../SSC/Src/ecatslv.c ****         /*SnycManger change event (0x220:4) could be acknowledged by reading the SM1 control regist
2591:../SSC/Src/ecatslv.c ****         => check if the SyncManger 1 is still enabled*/
2592:../SSC/Src/ecatslv.c ****             if (!(sm1Activate & SM_SETTING_ENABLE_VALUE))
 5331              	 .loc 3 2592 0
 5332 00c8 7B79     	 ldrb r3,[r7,#5]
 5333 00ca 03F00103 	 and r3,r3,#1
 5334 00ce 002B     	 cmp r3,#0
 5335 00d0 08D1     	 bne .L372
2593:../SSC/Src/ecatslv.c ****             {
2594:../SSC/Src/ecatslv.c ****                 AL_ControlInd(nAlStatus & STATE_MASK, 0);
 5336              	 .loc 3 2594 0
 5337 00d2 2C4B     	 ldr r3,.L377+16
 5338 00d4 1B78     	 ldrb r3,[r3]
 5339 00d6 03F00F03 	 and r3,r3,#15
 5340 00da DBB2     	 uxtb r3,r3
 5341 00dc 1846     	 mov r0,r3
 5342 00de 0021     	 movs r1,#0
 5343 00e0 FFF7FEFF 	 bl AL_ControlInd
 5344              	.L372:
2595:../SSC/Src/ecatslv.c ****             }
2596:../SSC/Src/ecatslv.c **** 
2597:../SSC/Src/ecatslv.c ****         if ( ALEventReg & (MAILBOX_READ_EVENT) )
 5345              	 .loc 3 2597 0
 5346 00e4 FB88     	 ldrh r3,[r7,#6]
 5347 00e6 03F40073 	 and r3,r3,#512
 5348 00ea 002B     	 cmp r3,#0
 5349 00ec 12D0     	 beq .L373
2598:../SSC/Src/ecatslv.c ****         {
2599:../SSC/Src/ecatslv.c ****             /* SM 1 (Mailbox Read) event is set, when the mailbox was read from the master,
2600:../SSC/Src/ecatslv.c ****                to acknowledge the event the first byte of the mailbox has to be written,
2601:../SSC/Src/ecatslv.c ****                by writing the first byte the mailbox is locked, too */
2602:../SSC/Src/ecatslv.c ****             u8dummy = 0;
 5350              	 .loc 3 2602 0
 5351 00ee 264B     	 ldr r3,.L377+20
 5352 00f0 0022     	 movs r2,#0
 5353 00f2 1A70     	 strb r2,[r3]
2603:../SSC/Src/ecatslv.c ****             HW_EscWriteByte(u8dummy,u16EscAddrSendMbx);
 5354              	 .loc 3 2603 0
 5355 00f4 254B     	 ldr r3,.L377+24
 5356 00f6 1B88     	 ldrh r3,[r3]
 5357 00f8 03F1A843 	 add r3,r3,#1409286144
 5358 00fc 03F58033 	 add r3,r3,#65536
 5359 0100 214A     	 ldr r2,.L377+20
 5360 0102 1278     	 ldrb r2,[r2]
 5361 0104 D2B2     	 uxtb r2,r2
 5362 0106 1A70     	 strb r2,[r3]
2604:../SSC/Src/ecatslv.c **** 
2605:../SSC/Src/ecatslv.c ****             /* the Mailbox Read event in the variable ALEventReg shall be reset before calling
2606:../SSC/Src/ecatslv.c ****                MBX_MailboxReadInd, where a new mailbox datagram (if available) could be stored in t
2607:../SSC/Src/ecatslv.c ****             ALEventReg &= ~(MAILBOX_READ_EVENT);
 5363              	 .loc 3 2607 0
 5364 0108 FB88     	 ldrh r3,[r7,#6]
 5365 010a 23F40073 	 bic r3,r3,#512
 5366 010e FB80     	 strh r3,[r7,#6]
2608:../SSC/Src/ecatslv.c ****             MBX_MailboxReadInd();
 5367              	 .loc 3 2608 0
 5368 0110 FFF7FEFF 	 bl MBX_MailboxReadInd
 5369              	.L373:
2609:../SSC/Src/ecatslv.c ****         }
2610:../SSC/Src/ecatslv.c **** 
2611:../SSC/Src/ecatslv.c ****         /* bMbxRepeatToggle holds the last state of the Repeat Bit (Bit 1) */
2612:../SSC/Src/ecatslv.c **** 
2613:../SSC/Src/ecatslv.c ****         if ( ( (sm1Activate & SM_SETTING_REPAET_REQ_MASK) && !bMbxRepeatToggle )
 5370              	 .loc 3 2613 0
 5371 0114 7B79     	 ldrb r3,[r7,#5]
 5372 0116 03F00203 	 and r3,r3,#2
 5373 011a 002B     	 cmp r3,#0
 5374 011c 06D0     	 beq .L374
 5375              	 .loc 3 2613 0 is_stmt 0 discriminator 1
 5376 011e 1C4B     	 ldr r3,.L377+28
 5377 0120 1B78     	 ldrb r3,[r3]
 5378 0122 83F00103 	 eor r3,r3,#1
 5379 0126 DBB2     	 uxtb r3,r3
 5380 0128 002B     	 cmp r3,#0
 5381 012a 08D1     	 bne .L375
 5382              	.L374:
2614:../SSC/Src/ecatslv.c ****             ||( !(sm1Activate & SM_SETTING_REPAET_REQ_MASK) && bMbxRepeatToggle ))
 5383              	 .loc 3 2614 0 is_stmt 1
 5384 012c 7B79     	 ldrb r3,[r7,#5]
 5385 012e 03F00203 	 and r3,r3,#2
 5386 0132 002B     	 cmp r3,#0
 5387 0134 0CD1     	 bne .L376
 5388              	 .loc 3 2614 0 is_stmt 0 discriminator 1
 5389 0136 164B     	 ldr r3,.L377+28
 5390 0138 1B78     	 ldrb r3,[r3]
 5391 013a 002B     	 cmp r3,#0
 5392 013c 08D0     	 beq .L376
 5393              	.L375:
2615:../SSC/Src/ecatslv.c ****         {
2616:../SSC/Src/ecatslv.c ****             /* Repeat Bit (Bit 1) has toggled, there is a repeat request, in MBX_MailboxRepeatReq t
2617:../SSC/Src/ecatslv.c ****                response will put in the send mailbox again */
2618:../SSC/Src/ecatslv.c ****             MBX_MailboxRepeatReq();
 5394              	 .loc 3 2618 0 is_stmt 1
 5395 013e FFF7FEFF 	 bl MBX_MailboxRepeatReq
2619:../SSC/Src/ecatslv.c ****             /* acknowledge the repeat request after the send mailbox was updated by writing the Rep
2620:../SSC/Src/ecatslv.c ****                in the Repeat Ack Bit (Bit 1) of the PDI Ctrl-Byte of SM 1 (Register 0x80F) */
2621:../SSC/Src/ecatslv.c ****             sm1Activate &= SM_SETTING_REPEAT_ACK;
 5396              	 .loc 3 2621 0
 5397 0142 7B79     	 ldrb r3,[r7,#5]
 5398 0144 03F00203 	 and r3,r3,#2
 5399 0148 7B71     	 strb r3,[r7,#5]
2622:../SSC/Src/ecatslv.c ****             HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
 5400              	 .loc 3 2622 0
 5401 014a 124A     	 ldr r2,.L377+32
 5402 014c 7B79     	 ldrb r3,[r7,#5]
 5403 014e 1370     	 strb r3,[r2]
 5404              	.L376:
2623:../SSC/Src/ecatslv.c ****         }
2624:../SSC/Src/ecatslv.c **** 
2625:../SSC/Src/ecatslv.c ****         /* Reload the AlEvent because it may be changed due to a SM disable, enable in case of an r
2626:../SSC/Src/ecatslv.c ****         ALEventReg = HW_GetALEventRegister();
 5405              	 .loc 3 2626 0
 5406 0150 FFF7FEFF 	 bl HW_GetALEventRegister
 5407 0154 0346     	 mov r3,r0
 5408 0156 FB80     	 strh r3,[r7,#6]
2627:../SSC/Src/ecatslv.c ****         ALEventReg = SWAPWORD(ALEventReg);
2628:../SSC/Src/ecatslv.c **** 
2629:../SSC/Src/ecatslv.c ****         if ( ALEventReg & (MAILBOX_WRITE_EVENT) )
 5409              	 .loc 3 2629 0
 5410 0158 FB88     	 ldrh r3,[r7,#6]
 5411 015a 03F48073 	 and r3,r3,#256
 5412 015e 002B     	 cmp r3,#0
 5413 0160 05D0     	 beq .L365
2630:../SSC/Src/ecatslv.c ****         {
2631:../SSC/Src/ecatslv.c ****             /* SM 0 (Mailbox Write) event is set, when the mailbox was written from the master,
2632:../SSC/Src/ecatslv.c ****                to acknowledge the event the first byte of the mailbox has to be read,
2633:../SSC/Src/ecatslv.c ****                which will be done in MBX_CheckAndCopyMailbox */
2634:../SSC/Src/ecatslv.c ****             /* the Mailbox Write event in the variable ALEventReg shall be reset before calling
2635:../SSC/Src/ecatslv.c ****                MBX_CheckAndCopyMailbox, where the received mailbox datagram will be processed */
2636:../SSC/Src/ecatslv.c ****             ALEventReg &= ~(MAILBOX_WRITE_EVENT);
 5414              	 .loc 3 2636 0
 5415 0162 FB88     	 ldrh r3,[r7,#6]
 5416 0164 23F48073 	 bic r3,r3,#256
 5417 0168 FB80     	 strh r3,[r7,#6]
2637:../SSC/Src/ecatslv.c ****             MBX_CheckAndCopyMailbox();
 5418              	 .loc 3 2637 0
 5419 016a FFF7FEFF 	 bl MBX_CheckAndCopyMailbox
 5420              	.L365:
2638:../SSC/Src/ecatslv.c **** 
2639:../SSC/Src/ecatslv.c ****         }
2640:../SSC/Src/ecatslv.c ****     }
2641:../SSC/Src/ecatslv.c **** }
 5421              	 .loc 3 2641 0
 5422 016e 0837     	 adds r7,r7,#8
 5423              	.LCFI111:
 5424              	 .cfi_def_cfa_offset 8
 5425 0170 BD46     	 mov sp,r7
 5426              	.LCFI112:
 5427              	 .cfi_def_cfa_register 13
 5428              	 
 5429 0172 80BD     	 pop {r7,pc}
 5430              	.L378:
 5431              	 .align 2
 5432              	.L377:
 5433 0174 00000000 	 .word bMbxRunning
 5434 0178 0E080154 	 .word 1409353742
 5435 017c 00000000 	 .word bEcatWaitForAlControlRes
 5436 0180 20010154 	 .word 1409351968
 5437 0184 00000000 	 .word nAlStatus
 5438 0188 00000000 	 .word u8dummy
 5439 018c 00000000 	 .word u16EscAddrSendMbx
 5440 0190 00000000 	 .word bMbxRepeatToggle
 5441 0194 0F080154 	 .word 1409353743
 5442              	 .cfi_endproc
 5443              	.LFE196:
 5445              	 .text
 5446              	.Letext0:
 5447              	 .file 4 "c:\\program files\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 5448              	 .file 5 "c:\\program files\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 5449              	 .file 6 "C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/CMSIS/Infineon/XMC4800_series/Include/XMC4800.h"
 5450              	 .file 7 "../SSC/Src/esc.h"
 5451              	 .file 8 "../SSC/Src/objdef.h"
 5452              	 .file 9 "C:/src/bakalarka_workspace/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/CMSIS/Include/core_cm4.h"
 5453              	 .file 10 "../SSC/Src/ecatslv.h"
 5454              	 .file 11 "../SSC/Src/mailbox.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ecatslv.c
    {standard input}:20     .text.XMC_ECAT_GetALEventRegister:00000000 $t
    {standard input}:24     .text.XMC_ECAT_GetALEventRegister:00000000 XMC_ECAT_GetALEventRegister
    {standard input}:57     .text.XMC_ECAT_GetALEventRegister:00000018 $d
    {standard input}:62     .text.HW_EscRead:00000000 $t
    {standard input}:66     .text.HW_EscRead:00000000 HW_EscRead
    {standard input}:110    .text.HW_GetALEventRegister:00000000 $t
    {standard input}:114    .text.HW_GetALEventRegister:00000000 HW_GetALEventRegister
                            *COM*:00000001 bBootMode
                            *COM*:00000001 bEcatOutputUpdateRunning
                            *COM*:00000001 bEcatInputUpdateRunning
                            *COM*:00000001 bEcatFirstOutputsReceived
                            *COM*:00000001 bWdTrigger
                            *COM*:00000001 bDcSyncActive
                            *COM*:00000002 EsmTimeoutCounter
                            *COM*:00000001 bDcRunning
                            *COM*:00000002 u16SmSync0Counter
                            *COM*:00000002 u16SmSync0Value
                            *COM*:00000001 bSmSyncSequenceValid
                            *COM*:00000002 i16WaitForPllRunningTimeout
                            *COM*:00000002 i16WaitForPllRunningCnt
                            *COM*:00000002 Sync0WdCounter
                            *COM*:00000002 Sync0WdValue
                            *COM*:00000002 Sync1WdCounter
                            *COM*:00000002 Sync1WdValue
                            *COM*:00000002 LatchInputSync0Value
                            *COM*:00000002 LatchInputSync0Counter
                            *COM*:00000001 b32BitDc
                            *COM*:00000001 bEscIntEnabled
                            *COM*:00000001 b3BufferMode
                            *COM*:00000001 bLocalErrorFlag
                            *COM*:00000002 u16LocalErrorCode
                            *COM*:00000001 bApplEsmPending
                            *COM*:00000001 bEcatWaitForAlControlRes
                            *COM*:00000002 nEcatStateTrans
                            *COM*:00000001 u8EcatErrorLed
                            *COM*:00000001 u8EcatRunLed
                            *COM*:00000002 nPdInputSize
                            *COM*:00000002 nPdOutputSize
                            *COM*:00000001 nMaxSyncMan
                            *COM*:00000002 nMaxEscAddress
                            *COM*:00000001 nAlStatus
                            *COM*:00000002 EcatWdValue
                            *COM*:00000002 nEscAddrOutputData
                            *COM*:00000002 nEscAddrInputData
                            *COM*:00000002 u16ALEventMask
                            *COM*:00000001 u8dummy
    {standard input}:180    .bss.SMActivate:00000000 SMActivate
    {standard input}:181    .bss.SMActivate:00000000 $d
                            *COM*:00000008 SyncManInfo
    {standard input}:187    .bss.EepromLoaded:00000000 EepromLoaded
    {standard input}:188    .bss.EepromLoaded:00000000 $d
    {standard input}:190    .text.ResetALEventMask:00000000 $t
    {standard input}:195    .text.ResetALEventMask:00000000 ResetALEventMask
    {standard input}:244    .text.ResetALEventMask:0000002c $d
    {standard input}:249    .text.SetALEventMask:00000000 $t
    {standard input}:254    .text.SetALEventMask:00000000 SetALEventMask
    {standard input}:302    .text.SetALEventMask:0000002c $d
    {standard input}:307    .text.UpdateEEPROMLoadedState:00000000 $t
    {standard input}:312    .text.UpdateEEPROMLoadedState:00000000 UpdateEEPROMLoadedState
    {standard input}:374    .text.UpdateEEPROMLoadedState:0000003c $d
    {standard input}:380    .text.GetSyncMan:00000000 $t
    {standard input}:385    .text.GetSyncMan:00000000 GetSyncMan
    {standard input}:429    .text.GetSyncMan:0000002c $d
    {standard input}:434    .text.DisableSyncManChannel:00000000 $t
    {standard input}:439    .text.DisableSyncManChannel:00000000 DisableSyncManChannel
    {standard input}:506    .text.EnableSyncManChannel:00000000 $t
    {standard input}:511    .text.EnableSyncManChannel:00000000 EnableSyncManChannel
    {standard input}:578    .text.CheckSmSettings:00000000 $t
    {standard input}:583    .text.CheckSmSettings:00000000 CheckSmSettings
    {standard input}:1012   .text.CheckSmSettings:00000294 $d
    {standard input}:1019   .text.CheckSmSettings:000002a8 $t
    {standard input}:1195   .text.CheckSmSettings:000003a0 $d
    {standard input}:1206   .text.StartInputHandler:00000000 $t
    {standard input}:1211   .text.StartInputHandler:00000000 StartInputHandler
    {standard input}:1638   .text.StartInputHandler:000002ac $d
    {standard input}:1658   .text.StartInputHandler:000002f4 $t
    {standard input}:2096   .text.StartInputHandler:00000588 $d
    {standard input}:2115   .text.StartInputHandler:000005cc $t
    {standard input}:2372   .text.StartInputHandler:00000754 $d
    {standard input}:2393   .text.StartOutputHandler:00000000 $t
    {standard input}:2398   .text.StartOutputHandler:00000000 StartOutputHandler
    {standard input}:2478   .text.StartOutputHandler:00000058 $d
    {standard input}:2489   .text.StopOutputHandler:00000000 $t
    {standard input}:2494   .text.StopOutputHandler:00000000 StopOutputHandler
    {standard input}:2529   .text.StopOutputHandler:00000018 $d
    {standard input}:2535   .text.StopInputHandler:00000000 $t
    {standard input}:2540   .text.StopInputHandler:00000000 StopInputHandler
    {standard input}:2698   .text.StopInputHandler:000000d8 $d
    {standard input}:2723   .text.BackToInitTransition:00000000 $t
    {standard input}:2728   .text.BackToInitTransition:00000000 BackToInitTransition
    {standard input}:2759   .text.BackToInitTransition:00000014 $d
    {standard input}:2764   .text.SetALStatus:00000000 $t
    {standard input}:2769   .text.SetALStatus:00000000 SetALStatus
    {standard input}:2906   .text.SetALStatus:000000b0 $d
    {standard input}:2916   .text.AL_ControlInd:00000000 $t
    {standard input}:2921   .text.AL_ControlInd:00000000 AL_ControlInd
    {standard input}:3095   .text.AL_ControlInd:00000110 $d
    {standard input}:3215   .text.AL_ControlInd:000002f0 $t
    {standard input}:3239   .text.AL_ControlInd:00000310 $d
    {standard input}:3249   .text.AL_ControlInd:00000330 $t
    {standard input}:3712   .text.AL_ControlInd:000005f4 $d
    {standard input}:3724   .text.AL_ControlInd:0000061c $t
    {standard input}:3929   .text.AL_ControlInd:00000758 $d
    {standard input}:3941   .text.AL_ControlRes:00000000 $t
    {standard input}:3946   .text.AL_ControlRes:00000000 AL_ControlRes
    {standard input}:4395   .text.AL_ControlRes:0000028c $d
    {standard input}:4415   .text.DC_CheckWatchdog:00000000 $t
    {standard input}:4420   .text.DC_CheckWatchdog:00000000 DC_CheckWatchdog
    {standard input}:4591   .text.DC_CheckWatchdog:000000ec $d
    {standard input}:4607   .text.CheckIfEcatError:00000000 $t
    {standard input}:4612   .text.CheckIfEcatError:00000000 CheckIfEcatError
    {standard input}:4720   .text.CheckIfEcatError:00000088 $d
    {standard input}:4732   .text.ECAT_StateChange:00000000 $t
    {standard input}:4737   .text.ECAT_StateChange:00000000 ECAT_StateChange
    {standard input}:4978   .text.ECAT_StateChange:00000158 $d
    {standard input}:4993   .text.ECAT_Init:00000000 $t
    {standard input}:4998   .text.ECAT_Init:00000000 ECAT_Init
    {standard input}:5171   .text.ECAT_Init:000000f4 $d
    {standard input}:5201   .text.ECAT_Main:00000000 $t
    {standard input}:5206   .text.ECAT_Main:00000000 ECAT_Main
    {standard input}:5433   .text.ECAT_Main:00000174 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
memcpy
DISABLE_ESC_INT
ENABLE_ESC_INT
sSyncManOutPar
sSyncManInPar
u16EscAddrSendMbx
u16SendMbxSize
u16EscAddrReceiveMbx
u16ReceiveMbxSize
bSyncSetByUser
sCycleDiag
PDO_InputMapping
APPL_GenerateMapping
MBX_StartMailboxHandler
APPL_StartMailboxHandler
APPL_StopMailboxHandler
MBX_StopMailboxHandler
BL_Start
BL_Stop
APPL_StartInputHandler
APPL_StopInputHandler
APPL_StartOutputHandler
APPL_StopOutputHandler
APPL_AckErrorInd
bMbxRunning
sErrorSettings
MBX_Init
COE_Init
MBX_Main
EEPROM_CommandHandler
MBX_MailboxReadInd
MBX_MailboxRepeatReq
MBX_CheckAndCopyMailbox
bMbxRepeatToggle
